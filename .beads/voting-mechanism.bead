# Bead: Voting Mechanism - Native Signal Polls

**Status**: Immutable Architectural Constraint  
**Created**: 2026-01-28  
**Context**: Architecture Decision 2.6

---

## Decision: Use Native Signal Polls

**Implementation**: Fork libsignal-service-rs, add protocol v8 poll support

### Why Polls (Not Reactions)

**Critical Reasons:**

1. **Accountability** - Votes are transparent to group members
   - Signal Polls show who voted for what (visible to group during poll)
   - Members remain accountable for their decisions
   - Signal identity can still be separate from real-world identity

2. **Multiple Choices** - Better decision making
   - ‚ùå Reactions are binary (üëç/üëé only)
   - ‚úÖ Polls support multiple options (A, B, C, D, etc.)
   - Enables nuanced decisions

3. **Native UX** - Better user experience
   - ‚úÖ Signal's built-in poll UI (mobile/desktop)
   - ‚úÖ Familiar interface for users
   - ‚úÖ Vote tracking built-in

### Persistence Constraint: Aggregates Only

**‚ö†Ô∏è CRITICAL**: Stroma MUST NOT persist individual votes.

**What Stroma Persists (Freenet contract):**
- ‚úÖ Proposal ID, type, action
- ‚úÖ Aggregate counts (approve: 18, reject: 4)
- ‚úÖ Result (passed/failed)
- ‚úÖ Quorum met (yes/no)
- ‚úÖ Threshold met (yes/no)
- ‚úÖ Timestamps (created, expired)

**What Stroma NEVER Persists:**
- ‚ùå Who voted for what
- ‚ùå Individual vote records
- ‚ùå Voter identities (hashed or cleartext)
- ‚ùå Vote timestamps per voter

**Rationale:**
- Signal shows votes during poll (ephemeral, in Signal's E2E encrypted channel)
- Stroma only stores outcomes (permanent, in Freenet contract)
- If Freenet state is compromised, voting history cannot be reconstructed
- Protects members from retroactive identification of dissent

### Current Status

**Canonical Source**: `.beads/poll-implementation-gastown.bead`

**Signal Protocol:**
- Protocol v8 includes poll support (PollCreate, PollTerminate, PollVote, PinMessage, UnpinMessage)
- Signal-Desktop, Signal-Android, Signal-iOS all support polls

**libsignal-service-rs Fork:** ‚úÖ COMPLETE
- Repository: `github.com/roder/libsignal-service-rs`
- Branch: `feature/protocol-v8-polls-rebased`
- Implemented: `PollCreate` (field 24), `PollTerminate` (field 25), `PollVote` (field 26), `PinMessage` (field 27), `UnpinMessage` (field 28)
- Tests: Unit tests for all poll types (serialization roundtrip)

**Presage:**
- Built on libsignal-service-rs
- Will use poll support via Cargo patch to our fork

### Implementation Strategy

**Use Fork Until Merged Upstream:**

```toml
# Stroma's Cargo.toml

[dependencies]
presage = { git = "https://github.com/roder/presage", branch = "integration/protocol-v8-polls" }
presage-store-sqlite = { git = "https://github.com/roder/presage", branch = "integration/protocol-v8-polls" }
# NOTE: presage-store-sqlite is used ONLY via StromaStore wrapper (no-ops message persistence)
# See: security-constraints.bead ¬ß 10 for StromaStore architecture

[patch."https://github.com/whisperfish/libsignal-service-rs"]
libsignal-service = { 
    git = "https://github.com/roder/libsignal-service-rs", 
    branch = "feature/protocol-v8-polls-rebased" 
}

# Required for presage
curve25519-dalek = { 
    git = 'https://github.com/signalapp/curve25519-dalek', 
    tag = 'signal-curve25519-4.1.3' 
}
```

**No blocking** - we use our fork immediately while PR is reviewed.

### Poll Protocol

**From Signal-Desktop protobuf:**

```protobuf
message DataMessage {
  // ... fields 1-22 (existing) ...
  optional PollCreate pollCreate = 24;
  optional PollTerminate pollTerminate = 25;
  optional PollVote pollVote = 26;
}

message PollCreate {
  optional string question = 1;          // 1-100 characters
  optional bool allowMultiple = 2;       // Allow multiple choices
  repeated string options = 3;           // Poll options
}

message PollVote {
  optional bytes targetAuthorAciBinary = 1;   // Poll creator UUID
  optional uint64 targetSentTimestamp = 2;    // Poll message timestamp
  repeated uint32 optionIndexes = 3;          // Selected options (0-based)
  optional uint32 voteCount = 4;              // Number of times voted
}

message PollTerminate {
  optional uint64 targetSentTimestamp = 1;    // Close poll
}
```

### Stroma Bot Usage

**Create Proposal (with Poll):**
```rust
use presage::libsignal_service::proto::DataMessage;
use presage::libsignal_service::proto::data_message::PollCreate;

async fn create_proposal_poll(
    manager: &Manager,
    group_master_key: &[u8],
    proposal: &Proposal,
) -> Result<String> {
    let poll_message = DataMessage {
        poll_create: Some(PollCreate {
            question: Some(format_proposal_question(proposal)),
            allow_multiple: Some(false),  // Single choice only
            options: vec!["üëç Approve".to_string(), "üëé Reject".to_string()],
        }),
        body: Some(format_proposal_details(proposal)),
        timestamp: Some(now()),
        ..Default::default()
    };
    
    manager.send_message_to_group(
        group_master_key,
        poll_message,
        now(),
    ).await?;
    
    Ok(poll_message_id)
}
```

**Monitor Poll Results:**
```rust
async fn check_poll_results(
    signal: &SignalClient,
    proposal: &ActiveProposal,
) -> Result<ProposalResult> {
    // Fetch poll results from Signal
    let poll_data = signal.get_poll_results(
        proposal.poll_creator_aci,
        proposal.poll_timestamp,
    ).await?;
    
    // Signal returns aggregated results (anonymous)
    let approve_votes = poll_data.options[0].vote_count;  // üëç
    let reject_votes = poll_data.options[1].vote_count;   // üëé
    let total_votes = approve_votes + reject_votes;
    
    if total_votes == 0 {
        return Ok(ProposalResult::NoVotes);
    }
    
    let approval_ratio = approve_votes as f32 / total_votes as f32;
    
    Ok(ProposalResult {
        approved: approval_ratio >= proposal.threshold,
        approve_count: approve_votes,
        reject_count: reject_votes,
        approval_ratio,
    })
}
```

### Anonymity Guarantee

**What Signal Shows (ephemeral, E2E encrypted):**
- During an active poll, Signal clients show who voted for what to group participants
- This is Signal's built-in behavior and cannot be changed by Stroma

**What Stroma Persists (Freenet contract -- permanent):**
- Only aggregate counts (approve: N, reject: M) and outcome (passed/failed)
- NEVER individual voter identities or per-voter choices
- If Freenet state is compromised, voting history cannot be reconstructed

**Privacy boundary**: Signal provides ephemeral vote visibility (disappears with messages). Stroma provides permanent outcome storage (aggregates only). The privacy guarantee is about what Stroma *persists*, not what Signal *shows*.

### Gastown Implementation Task

**For Gastown agents:**

**Bead-01-Poll-Support** (Protocol v8 Implementation)
- Fork libsignal-service-rs
- Copy poll protobuf definitions from Signal-Desktop
- Update protocol version to v8
- Add fields 24-26 to DataMessage
- Test against Signal staging servers
- Submit PR to Whisperfish
- Use fork in Stroma (don't wait for merge)

**Timeline**: 1-2 weeks (COMPLETE)  
**Status**: Fork implemented, compiled, and integrated into Stroma Cargo.toml

### Migration Notes

**When upstream merges:**
```toml
# Remove patch section from Cargo.toml
[dependencies]
presage = { git = "https://github.com/whisperfish/presage" }

# libsignal-service now has polls (no patch needed)
```

**Code remains the same** - poll API doesn't change, just dependency source.

### Code Constraints

**Block These Patterns:**
```rust
// ‚ùå NEVER implement reaction-based voting
pub struct ReactionProposal {  // FORBIDDEN - use polls
    approve_reactions: HashSet<Hash>,  // Exposes who voted
}

// ‚ùå NEVER track individual votes
pub struct VoteRecord {
    member: Hash,
    vote: VoteChoice,  // VIOLATES ANONYMITY
}
```

**Enforce These Patterns:**
```rust
// ‚úÖ ALWAYS use poll aggregates
pub struct ProposalResult {
    approve_count: usize,      // Total approvals
    reject_count: usize,       // Total rejections
    approval_ratio: f32,       // Aggregated ratio
    // NO individual votes
}

// ‚úÖ ALWAYS preserve anonymity
assert!(poll_results.individual_votes.is_none());  // Must be None
```

### Poll Termination (CRITICAL)

**Signal polls remain open indefinitely unless explicitly terminated.** The bot MUST send a `PollTerminate` message when the proposal timeout expires.

```rust
// Send PollTerminate when timeout expires
let terminate_message = DataMessage {
    poll_terminate: Some(PollTerminate {
        target_sent_timestamp: Some(original_poll_timestamp),
    }),
    timestamp: Some(now()),
    ..Default::default()
};
signal.send_message_to_group(group_master_key, terminate_message).await?;
```

**Why This Matters:**
- Prevents late votes after timeout (votes after termination ignored by Signal)
- Provides clear visual feedback in Signal UI (poll shows as closed)
- Ensures result announcement aligns with actual voting window
- Required for consistent UX across Signal clients

**Ordering:**
1. Fetch poll results
2. Terminate poll (PollTerminate)
3. Announce result to group
4. Execute action (if approved)
5. Record in Freenet

### Testing Requirements

**Must verify:**
- [ ] Poll creation works (PollCreate)
- [ ] Voting works (PollVote)
- [ ] Bot can read poll results
- [ ] **Poll termination works (PollTerminate)**
- [ ] **Votes after termination are ignored**
- [ ] Timeout enforcement works
- [ ] Multiple choice polls work (for future features)

### References

- Signal Protocol v8: https://github.com/signalapp/Signal-Desktop/blob/main/protos/SignalService.proto
- libsignal-service-rs: https://github.com/whisperfish/libsignal-service-rs
- Investigation results: docs/POLL-INVESTIGATION-RESULTS.md (temporary)

# Bead: Proposal System Design

**Status**: Immutable Architectural Constraint  
**Created**: 2026-01-28  
**Updated**: 2026-02-08  
**Context**: Architecture Decision 2.4

---

## Overview

The proposal system has two phases:

| Phase | Scope | Voting | Status |
|-------|-------|--------|--------|
| **UAT (Phase 0)** | Binary Approve/Reject | Threshold + Quorum | Implemented |
| **Post-UAT** | Multi-option polls | Plurality + Quorum | Designed, not implemented |

---

## Phase 0: Binary Proposals (UAT)

### Command: `/propose`

**Purpose**: Unified interface for all group decisions via consensus

### Structure

```
/propose <subcommand> [args] [--timeout <duration>]
```

### Discovery: `/mesh settings`

**New command added**: `/mesh settings` shows all available configuration keys with:
- Current values
- Valid ranges/options
- Key descriptions
- Usage examples

This addresses the discoverability problem where users didn't know what keys were available.

**Example output:**
```
‚öôÔ∏è Available Configuration Keys

üìã Stroma Settings (/propose stroma <key> <value>):
  min_vouches: 2 (range: 1-10) - Minimum vouches for standing
  ...

üì° Signal Settings (/propose signal <key> <value>):
  name: "Group Name" (1-32 chars) - Group display name
  disappearing_messages: off (off, 1h, 1d, 7d, 14d, 30d, 90d) - Message timer
  ...
```

### Subcommands

**1. Signal Group Settings (signal)**
```
/propose signal <setting> <value> [--timeout duration]

Examples:
/propose signal name "New Group Name"
/propose signal description "Trust-based activist network"
/propose signal disappearing_messages 7d
/propose signal announcements_only true --timeout 72h
```

**Available Signal Keys:**
- `name` (1-32 chars) - Group display name
- `description` (0-480 chars) - Group description
- `disappearing_messages` (off, 1h, 1d, 7d, 14d, 30d, 90d) - Message retention timer
- `announcements_only` (true/false) - Only admins can send messages

**2. Stroma Trust Settings (stroma)**
```
/propose stroma <setting> <value> [--timeout duration]

Examples:
/propose stroma min_vouches 3
/propose stroma config_change_threshold 0.80
/propose stroma default_poll_timeout_secs 259200
```

**Available Stroma Keys:**
- `min_vouches` (1-10) - Minimum vouches for full standing
- `max_flags` (1-10) - Maximum flags before ejection
- `open_membership` (true/false) - Whether new members can join
- `default_poll_timeout_secs` (3600-604800) - Default timeout in seconds
- `config_change_threshold` (0.50-1.00) - Vote threshold
- `min_quorum` (0.25-1.00) - Minimum participation

**3. Federation (federate)** *(deferred to Phase 4+)*
```
/propose federate <group-id> [--timeout duration]

Example:
/propose federate abc123def456 --timeout 96h
```

### NO Ejection Appeals

**Explicitly Removed**: No `/propose appeal` command.

**Rationale:**
- Appeals should NOT be public debates in the group
- If ejected, member can secure 2 new vouches and get re-invited
- This prevents contentious discussions
- Keeps group focused on coordination, not conflict resolution

**Re-Entry Path:**
1. Member is ejected (Standing < 0 OR vouches < 2)
2. Member contacts members outside Signal group
3. Member secures 2+ new vouches from members in different clusters
4. Member gets re-invited (previous flags persist, see `architectural-decisions-open.bead`)

### Proposal Configuration

**Per-Poll Settings:**
- **Timeout**: REQUIRED, configurable per proposal via `--timeout` (defaults to `GroupConfig.default_poll_timeout`)
- **Threshold**: Always from GroupConfig (NOT per-proposal) ‚Äî % of votes needed to pass
- **Quorum**: Always from GroupConfig (NOT per-proposal) ‚Äî % of members who must vote

**Rationale:**
- Timeout is REQUIRED to ensure decisions finalize (open-ended polls are forbidden)
- Timeout varies by decision urgency (some need 24h, others 96h), so per-proposal override allowed
- Threshold is governance constant (changing it requires proposal itself)
- Quorum prevents small minorities from passing proposals during low participation

**Actual Implementation Structures:**

`src/signal/polls.rs` ‚Äî In-memory poll tracking:
```rust
pub struct PollProposal {
    pub proposal_type: ProposalType,
    pub poll_id: u64,
    pub timeout: u64,           // seconds
    pub threshold: f32,         // copied from GroupConfig at creation
    pub quorum: f32,            // copied from GroupConfig at creation
}
```

`src/freenet/trust_contract.rs` ‚Äî Persistent Freenet storage:
```rust
pub struct ActiveProposal {
    pub poll_id: u64,
    pub proposal_type: String,      // "ConfigChange", "Federation", "Other"
    pub proposal_details: String,   // e.g., "min_vouches=3"
    pub poll_timestamp: u64,
    pub expires_at: u64,            // created_at + timeout (ALWAYS finite)
    pub timeout_secs: u64,
    pub threshold: f32,
    pub quorum: f32,
    pub checked: bool,
    pub result: Option<ProposalResult>,
}
```

**Timeout is REQUIRED**: Every proposal MUST have a finite timeout. Open-ended polls are forbidden because they would prevent decisions from ever being finalized.

### GroupConfig (Actual Implementation)

`src/freenet/trust_contract.rs`:
```rust
pub struct GroupConfig {
    pub min_vouches: u32,                    // Default: 2
    pub max_flags: u32,                      // Default: 3
    pub open_membership: bool,               // Default: false
    pub operators: BTreeSet<MemberHash>,
    pub default_poll_timeout_secs: u64,      // Default: 172800 (48h)
    pub config_change_threshold: f32,        // Default: 0.70 (70%)
    pub min_quorum: f32,                     // Default: 0.50 (50%)
}

// Timeout resolution (in order of precedence):
// 1. Per-proposal --timeout flag (if specified)
// 2. GroupConfig.default_poll_timeout (fallback)
// Open-ended polls are NEVER allowed
```

### User Experience

**With Default Timeout:**
```
Member: "/propose config name 'New Name'"

Bot: "üìã Proposal #42
     Change group name to 'New Name'
     
     Vote: üëç Approve | üëé Reject
     Timeout: 48h (default)
     Threshold: 70% | Quorum: 50%
     Closes: Thu Jan 30, 10:00 AM"
```

**With Custom Timeout:**
```
Member: "/propose federate abc123 --timeout 96h"

Bot: "üìã Proposal #43
     Federate with group abc123
     
     Vote: üëç Approve | üëé Reject
     Timeout: 96h (custom)
     Threshold: 70% | Quorum: 50%
     Closes: Mon Feb 3, 6:00 PM"
```

**Disagreement with Timeout:**
If you disagree with the timeout, you can:
- Vote No
- Abstain (don't vote)
- Create counter-proposal with different timeout

Abstention is valid democratic participation.

### Bot Real-Time Monitoring (NOT Polling)

**Stored in Freenet Contract:**
```rust
pub struct ActiveProposal {
    proposal: Proposal,
    poll_creator_aci: Uuid,     // Bot's ACI for poll lookup
    poll_timestamp: u64,        // Poll creation timestamp
    
    // ‚ö†Ô∏è AGGREGATES ONLY - Individual votes MUST NEVER be stored
    // Signal shows who voted during poll (ephemeral, E2E encrypted)
    // Stroma stores only counts (permanent, in Freenet)
    approve_count: u32,
    reject_count: u32,
    
    // Status
    checked: bool,              // False until timeout expires
    result: Option<ProposalResult>,
}

// ‚ùå FORBIDDEN - Never create structures like this:
// struct VoteRecord { voter: Hash, choice: Choice, timestamp: u64 }
// Vec<VoteRecord> individual_votes;
```

**Bot Event Loop (Real-Time Stream - NOT Polling):**
```rust
// ‚úÖ REQUIRED: Real-time state stream monitoring
async fn proposal_monitoring_stream(
    signal: &SignalClient,
    freenet: &FreenetClient,
) {
    // Subscribe to state changes (NOT polling with sleep loops)
    let mut state_stream = freenet.subscribe_to_state_changes().await.unwrap();
    
    while let Some(change) = state_stream.next().await {
        match change {
            StateChange::ProposalExpired(proposal_id) => {
                let proposal = freenet.get_proposal(proposal_id).await?;
                
                // 1. Fetch poll results from Signal
                let poll_results = signal
                    .get_poll_results(proposal.poll_creator_aci, proposal.poll_timestamp)
                    .await?;
                
                // 2. Update vote counts (aggregates only)
                let approve_count = poll_results.option_counts[0];  // "Approve" option
                let reject_count = poll_results.option_counts[1];   // "Reject" option
                
                // 3. TERMINATE the Signal Poll (prevents late votes)
                signal.terminate_poll(
                    proposal.group_master_key,
                    proposal.poll_timestamp,
                ).await?;
                
                // 4. Calculate result (quorum + threshold)
                let total_votes = approve_count + reject_count;
                let total_members = freenet.get_member_count().await?;
                let result = calculate_proposal_result(
                    approve_count, 
                    reject_count, 
                    total_members,
                    &config
                );
                
                // 5. Announce result to group
                signal.send_message_to_group(
                    proposal.group_master_key,
                    format_result_announcement(&proposal, &result),
                ).await?;
                
                // 6. If approved (quorum met AND threshold met), execute
                if result.approved {
                    execute_action(&proposal.action, signal).await?;
                }
                
                // 7. Record in Freenet
                freenet.record_proposal_result(proposal.id, result).await?;
                
                // 8. Mark as checked (never check again)
                proposal.checked = true;
            }
        }
    }
}

// ‚úÖ REQUIRED: Terminate poll on Signal when timeout expires
async fn terminate_poll(
    signal: &SignalClient,
    group_master_key: &[u8],
    poll_timestamp: u64,
) -> Result<()> {
    use presage::libsignal_service::proto::data_message::PollTerminate;
    
    let terminate_message = DataMessage {
        poll_terminate: Some(PollTerminate {
            target_sent_timestamp: Some(poll_timestamp),
        }),
        timestamp: Some(now()),
        ..Default::default()
    };
    
    signal.send_message_to_group(group_master_key, terminate_message).await?;
    Ok(())
}
```

**Key Points:**
- Use real-time state stream (NOT polling with sleep loops)
- React to `StateChange::ProposalExpired` events immediately
- **TERMINATE poll on Signal** before announcing result (prevents late votes)
- Only check proposals that haven't been checked AND are expired
- After timeout: terminate ‚Üí announce ‚Üí execute (if approved) ‚Üí record ‚Üí mark checked
- Never check same proposal twice

**Why Poll Termination is Required:**
- Signal polls remain open indefinitely unless explicitly terminated via `PollTerminate`
- Without termination, members could vote after the timeout (confusing UX)
- Termination provides clear visual feedback in Signal UI (poll shows as closed)
- Votes cast after termination are ignored by Signal

### Proposal Result Calculation (Actual Implementation)

**Implemented in**: `src/signal/polls.rs`

```rust
/// Vote aggregate (only counts, never individual voters)
pub struct VoteAggregate {
    pub approve: u32,
    pub reject: u32,
    pub total_members: u32,
}

/// Poll outcome
pub enum PollOutcome {
    Passed {
        approve_count: u32,
        reject_count: u32,
    },
    Failed {
        approve_count: u32,
        reject_count: u32,
    },
    QuorumNotMet {
        participation_rate: f32,
        required_quorum: f32,
    },
}

fn check_poll_outcome(poll_id: u64, votes: &VoteAggregate) -> Option<PollOutcome> {
    let proposal = self.active_polls.get(&poll_id)?;
    let total_voters = votes.approve + votes.reject;
    let total_members = votes.total_members;

    // Check quorum (% of members who must vote)
    let participation_rate = total_voters as f32 / total_members as f32;
    if participation_rate < proposal.quorum {
        return Some(PollOutcome::QuorumNotMet {
            participation_rate,
            required_quorum: proposal.quorum,
        });
    }

    // Check threshold (% of votes to pass)
    let approve_rate = votes.approve as f32 / total_voters as f32;
    if approve_rate >= proposal.threshold {
        Some(PollOutcome::Passed { approve_count: votes.approve, reject_count: votes.reject })
    } else {
        Some(PollOutcome::Failed { approve_count: votes.approve, reject_count: votes.reject })
    }
}
```

**Result stored in Freenet** (`src/freenet/trust_contract.rs`):

```rust
pub enum ProposalResult {
    Passed { approve_count: u32, reject_count: u32 },
    Failed { approve_count: u32, reject_count: u32 },
    QuorumNotMet { participation_rate: f32 },
}
```

**Failure Messages:**
- If `QuorumNotMet`: "Proposal failed: Quorum not met (X% participated, Y% required)"
- If `Failed`: "Proposal failed: Threshold not met (X% approved, Y% required)"
- If `Passed`: "Proposal passed: X% approved (quorum: Y%, threshold: Z%)"

### Code Constraints

**Block These Patterns:**
```rust
// ‚ùå NEVER let users set per-proposal thresholds or quorum
// (PollProposal stores threshold/quorum, but values MUST come from GroupConfig)
pub fn parse_propose_args(...) {
    // WRONG: accepting --threshold or --quorum flags
    threshold: user_provided_threshold,  // FORBIDDEN
    quorum: user_provided_quorum,        // FORBIDDEN
}
// CORRECT: Copy from GroupConfig at poll creation time (see lifecycle.rs:65-66)

// ‚ùå NEVER allow open-ended polls (no timeout)
pub struct Proposal {
    timeout: Option<Duration>,  // WRONG - timeout is REQUIRED, not optional
}
// Correct: timeout: Duration (always finite, defaults to group config)

// ‚ùå NEVER have urgency levels
pub enum ProposalUrgency {
    Normal,
    Urgent,  // FORBIDDEN - adds complexity
}

// ‚ùå NEVER implement ejection appeals
match subcommand {
    "appeal" => { /* FORBIDDEN - removed from system */ }
}
```

**Enforce These Patterns:**
```rust
// ‚úÖ ALWAYS use config threshold AND quorum
let threshold = group_config.config_change_threshold;  // Not per-proposal
let quorum = group_config.min_quorum;                  // Not per-proposal

// ‚úÖ ALWAYS have a finite timeout (required, never open-ended)
let timeout = args.timeout.unwrap_or(group_config.default_poll_timeout);
// timeout is ALWAYS set - either from --timeout flag or default

// ‚úÖ ALWAYS check both quorum AND threshold
let result = calculate_proposal_result(approve, reject, total_members, &config);
if !result.approved {
    return Err(format!("Quorum: {}, Threshold: {}", result.quorum_met, result.threshold_met));
}
```

### Gastown Agent Instructions (Phase 0)

**When implementing `/propose` command:**
1. Parse subcommand (config, stroma, federate)
2. Parse timeout from `--timeout` flag or use config default
3. Use GroupConfig.config_change_threshold (NEVER per-proposal threshold)
4. Use GroupConfig.min_quorum (NEVER per-proposal quorum)
5. NO "appeal" subcommand (explicitly removed)

**When implementing voting:**
1. Use Signal Polls for voting (structured options, native UX)
2. ‚ùå DO NOT use emoji reactions (binary only, harder to tally)
3. Check poll results ONCE after timeout expires
4. Record result in Freenet (pass/fail, aggregate counts ONLY)
5. ‚ùå NEVER persist who voted for what (see security-constraints.bead)
6. Check BOTH quorum AND threshold before executing
7. Execute if approved (quorum_met AND threshold_met)

**When implementing bot loop:**
1. ‚úÖ Use real-time state stream (subscribe to state changes)
2. ‚ùå DO NOT use polling with sleep loops
3. Only check expired, unchecked proposals
4. Mark as checked after first check
5. Never re-check same proposal

---

## Post-UAT: Multi-Option Proposals

**Problem**: Binary Approve/Reject is insufficient for config changes where the question is "what value?" not "should we change?"

**Solution**: Extend the proposal system to support N-option polls using Signal Protocol v8's native multi-option poll support.

### Extended Command Syntax

```
/propose config --key <key> --value <val1> --value <val2> [--value <valN>...] --timeout <duration> --proposal "<question>"

/propose stroma --key <key> --value <val1> --value <val2> [--value <valN>...] --timeout <duration> --proposal "<question>"
```

**Examples:**
```
/propose config --key disappearing_messages --value "1 day" --value "7 days" --value "30 days" --timeout 24h --proposal "What should our disappearing message timer be?"

/propose stroma --key min_vouches --value "2" --value "3" --value "4" --timeout 48h --proposal "Adjust minimum vouch threshold"
```

### Configuration Key Registry

The proposal system must expose all configurable keys from both Signal's group API and Stroma's `GroupConfig`. Each key needs type validation and allowed values.

**Stroma Config Keys** (from `src/freenet/trust_contract.rs`):

| Key | Type | Default | Range/Values | Description |
|-----|------|---------|--------------|-------------|
| `min_vouches` | `u32` | 2 | 1-10 | Minimum vouches for full standing |
| `max_flags` | `u32` | 3 | 1-10 | Maximum flags before ejection |
| `open_membership` | `bool` | false | true/false | Whether new members can join |
| `default_poll_timeout_secs` | `u64` | 172800 (48h) | 3600-604800 (1h-168h) | Default timeout for proposals |
| `config_change_threshold` | `f32` | 0.70 | 0.50-1.00 | Fraction of votes needed to pass |
| `min_quorum` | `f32` | 0.50 | 0.25-1.00 | Fraction of members who must vote |

**Signal Group Config Keys** (from libsignal-service-rs `GroupV2` API):

| Key | Type | Values | Description |
|-----|------|--------|-------------|
| `name` | string | 1-32 chars | Display name of the group (implemented) |
| `description` | string | 0-480 chars | Group description (implemented) |
| `disappearing_messages` | duration | off, 1h, 1d, 7d, 14d, 30d, 90d | Message expiration timer (implemented) |
| `announcements_only` | bool | true/false | Only admins can send messages (implemented) |
| `add_members` | permission | all_members, only_admins | Who can add new members (future) |
| `edit_attributes` | permission | all_members, only_admins | Who can edit group info (future) |

**Implementation Status:**
- ‚úÖ Implemented keys: `name`, `description`, `disappearing_messages`, `announcements_only`
- ‚è≥ Future keys: `add_members`, `edit_attributes` (require AccessControl enum mapping)

**Validation:**
- `name`: Validated in `src/signal/proposals/command.rs` (1-32 chars)
- `description`: Validated in `src/signal/proposals/command.rs` (0-480 chars)
- `disappearing_messages`: Parsed via `humantime` crate in `src/signal/proposals/duration_parse.rs`
- `announcements_only`: Bool parsing with error on invalid values

### Data Model Changes

```rust
pub struct ProposeArgs {
    pub subcommand: ProposalSubcommand,
    pub timeout: Option<Duration>,
    pub custom_question: Option<String>,  // --proposal flag
}

pub enum ProposalSubcommand {
    Config {
        key: String,
        values: Vec<String>,  // multiple --value flags (N >= 2)
    },
    Stroma {
        key: String,
        values: Vec<String>,
    },
    // Federate deferred to Phase 4+
}

pub struct VoteAggregate {
    pub votes_per_option: Vec<u32>,  // votes[i] = count for option i
    pub total_members: u32,
}

pub enum PollOutcome {
    WinnerSelected {
        winning_option: u32,
        winning_value: String,
        vote_count: u32,
        total_votes: u32,
    },
    Tie {
        tied_options: Vec<u32>,
    },
    QuorumNotMet {
        participation_rate: f32,
        required_quorum: f32,
    },
}
```

### Voting Logic: Plurality with Quorum

Multi-option proposals use **plurality voting** (highest vote count wins) with **quorum requirement** (minimum participation):

```rust
fn calculate_multi_option_result(
    votes_per_option: &[u32],
    total_members: u32,
    config: &GroupConfig,
) -> PollOutcome {
    let total_votes: u32 = votes_per_option.iter().sum();
    let participation_rate = total_votes as f32 / total_members as f32;
    
    // Check quorum first
    if participation_rate < config.min_quorum {
        return PollOutcome::QuorumNotMet {
            participation_rate,
            required_quorum: config.min_quorum,
        };
    }
    
    // Find winner(s) by plurality
    let max_votes = *votes_per_option.iter().max().unwrap_or(&0);
    let winners: Vec<u32> = votes_per_option
        .iter()
        .enumerate()
        .filter(|(_, &count)| count == max_votes)
        .map(|(i, _)| i as u32)
        .collect();
    
    if winners.len() > 1 {
        PollOutcome::Tie { tied_options: winners }
    } else {
        PollOutcome::WinnerSelected {
            winning_option: winners[0],
            winning_value: /* map option index to --value string */,
            vote_count: max_votes,
            total_votes,
        }
    }
}
```

**Note**: Threshold (`config_change_threshold`) does NOT apply to multi-option polls ‚Äî only quorum. The winner is determined by plurality (most votes), not by meeting a percentage threshold.

### UX Flow

```
User: /propose config --key disappearing_messages --value "1 day" --value "7 days" --value "30 days" --timeout 24h --proposal "What should our disappearing message timer be?"

Bot creates Signal poll:
  Question: "What should our disappearing message timer be?"
  Options: 1 day | 7 days | 30 days
  Timeout: 24h | Quorum: 50%

[Members vote via Signal's native poll UI]

After 24h, bot terminates poll:
  Results: 1 day (3), 7 days (8), 30 days (4)
  Winner: "7 days" (plurality, 8 of 15 votes)
  Quorum: 100% (15/15 voted)

  Bot announces: "Proposal PASSED: Disappearing messages set to 7 days (8 of 15 votes)"
  Bot executes: Changes Signal group disappearing_messages to 7 days
```

### Tie-Breaking

When multiple options receive the same highest vote count:

1. **Announce the tie**: "Proposal tied between: 1 day (5), 7 days (5)"
2. **No automatic execution**: Status quo preserved
3. **Proposer can re-submit** with modified options or extended timeout

### Gastown Agent Instructions (Post-UAT)

**New modules to create:**
- `src/signal/proposals/config_registry.rs` ‚Äî `ConfigKeyRegistry` with validation rules per key

**Modules to extend:**
- `src/signal/proposals/command.rs` ‚Äî Parse `--key`, `--value` (N times), `--proposal`
- `src/signal/polls.rs` ‚Äî `VoteAggregate` with `votes_per_option: Vec<u32>`, `PollOutcome` with `WinnerSelected`/`Tie`/`QuorumNotMet`
- `src/signal/proposals/lifecycle.rs` ‚Äî Generate poll options from `--value` flags, use `--proposal` as question
- `src/signal/proposals/executor.rs` ‚Äî Map winning option to original `--value`, call Signal API for Signal keys

---

## Roadmap

### Phase 0: Binary Proposals (UAT) ‚Äî COMPLETE

| Component | File | Status |
|-----------|------|--------|
| Command parsing | `src/signal/proposals/command.rs` | ‚úÖ Complete (signal, stroma subcommands) |
| Duration parsing | `src/signal/proposals/duration_parse.rs` | ‚úÖ Complete (humantime support) |
| Poll creation | `src/signal/proposals/lifecycle.rs` | ‚úÖ Complete (multi-option API ready) |
| Config execution | `src/signal/proposals/executor.rs` | ‚úÖ Complete (Signal + Stroma) |
| Signal execution | `src/signal/bot.rs` | ‚úÖ Complete (execute_signal_setting) |
| Poll management | `src/signal/polls.rs` | ‚úÖ Complete |
| Freenet storage | `src/freenet/trust_contract.rs` | ‚úÖ Complete |
| Settings discovery | `src/signal/pm.rs` | ‚úÖ Complete (/mesh settings) |

**Current syntax**: 
- `/propose signal <key> <value> [--timeout <duration>]`
- `/propose stroma <key> <value> [--timeout <duration>]`

**Implemented Signal keys:**
- ‚úÖ `name` (1-32 chars) - Group display name
- ‚úÖ `description` (0-480 chars) - Group description
- ‚úÖ `disappearing_messages` (off, 1h, 1d, 7d, etc.) - Message timer
- ‚úÖ `announcements_only` (true/false) - Admin-only messages

**Current limitations**:
- Binary Approve/Reject only (multi-option API ready but not wired)
- Single value per proposal (multi-value via `--value` flags planned for post-UAT)
- Federation deferred (returns `NotImplemented`)

### Post-UAT: Multi-Option Proposals ‚Äî NOT STARTED

| Deliverable | Priority | Depends On |
|-------------|----------|------------|
| `ConfigKeyRegistry` module | P1 | None |
| Extended command parsing (`--key`, `--value` N times, `--proposal`) | P1 | ConfigKeyRegistry |
| Multi-option `VoteAggregate` and `PollOutcome` | P1 | None |
| Plurality voting logic | P1 | Multi-option VoteAggregate |
| Signal config execution (presage API calls) | P2 | UAT validation |

**Target syntax**: `/propose config --key disappearing_messages --value "1 day" --value "7 days" --timeout 24h --proposal "Choose timer"`

**Blocking UAT?**: No. Binary proposals sufficient for UAT. Multi-option is enhancement.

### Phase 4+: Federation Proposals ‚Äî DEFERRED

| Deliverable | Status |
|-------------|--------|
| `/propose federate <group-id>` command | Parses, returns `NotImplemented` |
| `FederationDelta` variant in `StateDelta` | Not implemented |
| PSI-CA discovery integration | Designed in architecture beads |

**Blocking UAT?**: No. Federation is Phase 4+.

# Bead: Proposal System Design

**Status**: Immutable Architectural Constraint  
**Created**: 2026-01-28  
**Context**: Architecture Decision 2.4

---

## Command: `/propose`

**Purpose**: Unified interface for all group decisions via consensus

### Structure

```
/propose <subcommand> [args] [--timeout <duration>]
```

### Subcommands

**1. Signal Group Settings (config)**
```
/propose config <setting> <value> [--timeout duration]

Examples:
/propose config name "New Group Name"
/propose config description "Trust-based activist network"
/propose config disappearing_messages 24h
/propose config disappearing_messages 24h --timeout 72h
```

**2. Stroma Trust Settings (stroma)**
```
/propose stroma <setting> <value> [--timeout duration]

Examples:
/propose stroma min_vouch_threshold 3
/propose stroma config_change_threshold 0.80
/propose stroma default_poll_timeout 72h
```

**3. Federation (federate)**
```
/propose federate <group-id> [--timeout duration]

Example:
/propose federate abc123def456 --timeout 96h
```

### NO Ejection Appeals

**Explicitly Removed**: No `/propose appeal` command.

**Rationale:**
- Appeals should NOT be public debates in the group
- If ejected, member can secure 2 new vouches and get re-invited
- This prevents contentious discussions
- Keeps group focused on coordination, not conflict resolution

**Re-Entry Path:**
1. Member is ejected (Standing < 0 OR vouches < 2)
2. Member contacts members outside Signal group
3. Member secures 2 new vouches from members in different clusters
4. Member gets re-invited (fresh start)

### Proposal Configuration

**Per-Poll Settings:**
- **Timeout**: Configurable per proposal (default from GroupConfig)
- **Threshold**: Always from GroupConfig (NOT per-proposal)

**Rationale:**
- Timeout varies by decision urgency (some need 24h, others 96h)
- Threshold is governance constant (changing it requires proposal itself)

```rust
pub struct Proposal {
    id: ProposalId,
    proposer: Hash,
    proposal_type: ProposalType,
    
    // Configuration
    timeout: Duration,              // Configurable per poll
    threshold: f32,                 // From GroupConfig (fixed)
    
    // Execution
    action: FreenetAction,
    
    // Timestamps
    created_at: Timestamp,
    expires_at: Timestamp,          // created_at + timeout
}
```

### Default Timeouts

```rust
pub struct GroupConfig {
    // Default if --timeout not specified
    default_poll_timeout: Duration,  // e.g., 48h
    
    // Threshold for ALL proposals (not configurable per-poll)
    config_change_threshold: f32,    // e.g., 0.70 (70%)
}
```

### User Experience

**With Default Timeout:**
```
Member: "/propose config name 'New Name'"

Bot: "üìã Proposal #42
     Change group name to 'New Name'
     
     Vote: üëç Approve | üëé Reject
     Timeout: 48h (default)
     Threshold: 70%
     Closes: Thu Jan 30, 10:00 AM"
```

**With Custom Timeout:**
```
Member: "/propose federate abc123 --timeout 96h"

Bot: "üìã Proposal #43
     Federate with group abc123
     
     Vote: üëç Approve | üëé Reject
     Timeout: 96h (custom)
     Threshold: 70%
     Closes: Mon Feb 3, 6:00 PM"
```

**Disagreement with Timeout:**
If you disagree with the timeout, you can:
- Vote No
- Abstain (don't vote)
- Create counter-proposal with different timeout

Abstention is valid democratic participation.

### Bot Real-Time Monitoring (NOT Polling)

**Stored in Freenet Contract:**
```rust
pub struct ActiveProposal {
    proposal: Proposal,
    poll_creator_aci: Uuid,     // Bot's ACI for poll lookup
    poll_timestamp: u64,        // Poll creation timestamp
    
    // Voting state (aggregates only - never individual votes)
    approve_count: u32,         // Signal provides only counts
    reject_count: u32,          // Signal provides only counts
    
    // Status
    checked: bool,              // False until timeout expires
    result: Option<ProposalResult>,
}
```

**Bot Event Loop (Real-Time Stream - NOT Polling):**
```rust
// ‚úÖ REQUIRED: Real-time state stream monitoring
async fn proposal_monitoring_stream(
    signal: &SignalClient,
    freenet: &FreenetClient,
) {
    // Subscribe to state changes (NOT polling with sleep loops)
    let mut state_stream = freenet.subscribe_to_state_changes().await.unwrap();
    
    while let Some(change) = state_stream.next().await {
        match change {
            StateChange::ProposalExpired(proposal_id) => {
                let proposal = freenet.get_proposal(proposal_id).await?;
                
                // 1. Fetch poll results from Signal (anonymous - only counts)
                let poll_results = signal
                    .get_poll_results(proposal.poll_creator_aci, proposal.poll_timestamp)
                    .await?;
                
                // 2. Update vote counts (aggregates only)
                let approve_count = poll_results.option_counts[0];  // "Approve" option
                let reject_count = poll_results.option_counts[1];   // "Reject" option
                
                // 3. Calculate result
                let result = calculate_proposal_result(approve_count, reject_count, &config);
                
                // 4. If approved, execute
                if result.approved {
                    execute_action(&proposal.action, signal).await?;
                }
                
                // 5. Record in Freenet
                freenet.record_proposal_result(proposal.id, result).await?;
                
                // 6. Mark as checked (never check again)
                proposal.checked = true;
            }
        }
    }
}
```

**Key Points:**
- Use real-time state stream (NOT polling with sleep loops)
- React to `StateChange::ProposalExpired` events immediately
- Only check proposals that haven't been checked AND are expired
- After timeout: check ONCE, record result, mark checked
- Never check same proposal twice

### Code Constraints

**Block These Patterns:**
```rust
// ‚ùå NEVER have per-proposal thresholds
pub struct Proposal {
    threshold: f32,  // WRONG - use GroupConfig.config_change_threshold
}

// ‚ùå NEVER have urgency levels
pub enum ProposalUrgency {
    Normal,
    Urgent,  // FORBIDDEN - adds complexity
}

// ‚ùå NEVER implement ejection appeals
match subcommand {
    "appeal" => { /* FORBIDDEN - removed from system */ }
}
```

**Enforce These Patterns:**
```rust
// ‚úÖ ALWAYS use config threshold
let threshold = group_config.config_change_threshold;  // Not per-proposal

// ‚úÖ ALWAYS allow custom timeout
let timeout = args.timeout.unwrap_or(group_config.default_poll_timeout);

// ‚úÖ ALWAYS check Freenet before execution
if !freenet.is_approved(proposal.id).await? {
    return Err("Not approved");
}
```

### Gastown Agent Instructions

**When implementing `/propose` command:**
1. Parse subcommand (config, stroma, federate)
2. Parse timeout from `--timeout` flag or use config default
3. Use GroupConfig.config_change_threshold (NEVER per-proposal threshold)
4. NO "appeal" subcommand (explicitly removed)

**When implementing voting:**
1. Use Signal Polls for voting (anonymous - Signal doesn't expose who voted)
2. ‚ùå DO NOT use emoji reactions (exposes voter identity)
3. Check poll results ONCE after timeout expires
4. Record aggregated result in Freenet (counts only, never individuals)
5. Execute if approved

**When implementing bot loop:**
1. ‚úÖ Use real-time state stream (subscribe to state changes)
2. ‚ùå DO NOT use polling with sleep loops
3. Only check expired, unchecked proposals
4. Mark as checked after first check
5. Never re-check same proposal

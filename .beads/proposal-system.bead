# Bead: Proposal System Design

**Status**: Immutable Architectural Constraint  
**Created**: 2026-01-28  
**Context**: Architecture Decision 2.4

---

## Command: `/propose`

**Purpose**: Unified interface for all group decisions via consensus

### Structure

```
/propose <subcommand> [args] [--timeout <duration>]
```

### Subcommands

**1. Signal Group Settings (config)**
```
/propose config <setting> <value> [--timeout duration]

Examples:
/propose config name "New Group Name"
/propose config description "Trust-based activist network"
/propose config disappearing_messages 24h
/propose config disappearing_messages 24h --timeout 72h
```

**2. Stroma Trust Settings (stroma)**
```
/propose stroma <setting> <value> [--timeout duration]

Examples:
/propose stroma min_vouch_threshold 3
/propose stroma config_change_threshold 0.80
/propose stroma default_poll_timeout 72h
```

**3. Federation (federate)**
```
/propose federate <group-id> [--timeout duration]

Example:
/propose federate abc123def456 --timeout 96h
```

### NO Ejection Appeals

**Explicitly Removed**: No `/propose appeal` command.

**Rationale:**
- Appeals should NOT be public debates in the group
- If ejected, member can secure 2 new vouches and get re-invited
- This prevents contentious discussions
- Keeps group focused on coordination, not conflict resolution

**Re-Entry Path:**
1. Member is ejected (Standing < 0 OR vouches < 2)
2. Member contacts members outside Signal group
3. Member secures 2+ new vouches from members in different clusters
4. Member gets re-invited (previous flags persist, see `architectural-decisions-open.bead`)

### Proposal Configuration

**Per-Poll Settings:**
- **Timeout**: REQUIRED, configurable per proposal via `--timeout` (defaults to `GroupConfig.default_poll_timeout`)
- **Threshold**: Always from GroupConfig (NOT per-proposal) ‚Äî % of votes needed to pass
- **Quorum**: Always from GroupConfig (NOT per-proposal) ‚Äî % of members who must vote

**Rationale:**
- Timeout is REQUIRED to ensure decisions finalize (open-ended polls are forbidden)
- Timeout varies by decision urgency (some need 24h, others 96h), so per-proposal override allowed
- Threshold is governance constant (changing it requires proposal itself)
- Quorum prevents small minorities from passing proposals during low participation

```rust
pub struct Proposal {
    id: ProposalId,
    proposer: Hash,
    proposal_type: ProposalType,
    
    // Configuration
    timeout: Duration,              // REQUIRED - defaults to GroupConfig.default_poll_timeout
    threshold: f32,                 // From GroupConfig (fixed) - % of votes to pass
    quorum: f32,                    // From GroupConfig (fixed) - % of members who must vote
    
    // Execution
    action: FreenetAction,
    
    // Timestamps
    created_at: Timestamp,
    expires_at: Timestamp,          // created_at + timeout (ALWAYS finite)
}
```

**Timeout is REQUIRED**: Every proposal MUST have a finite timeout. Open-ended polls are forbidden because they would prevent decisions from ever being finalized.

### Timeout Configuration

```rust
pub struct GroupConfig {
    // Default timeout when --timeout not specified (REQUIRED field)
    default_poll_timeout: Duration,  // e.g., 48h - applied when proposer doesn't specify
    
    // Threshold for ALL proposals (not configurable per-poll)
    config_change_threshold: f32,    // e.g., 0.70 (70%) - % of votes to pass
    
    // Quorum for ALL proposals (not configurable per-poll)
    min_quorum: f32,                 // e.g., 0.50 (50%) - % of members who must vote
}

// Timeout resolution (in order of precedence):
// 1. Per-proposal --timeout flag (if specified)
// 2. GroupConfig.default_poll_timeout (fallback)
// Open-ended polls are NEVER allowed
```

### User Experience

**With Default Timeout:**
```
Member: "/propose config name 'New Name'"

Bot: "üìã Proposal #42
     Change group name to 'New Name'
     
     Vote: üëç Approve | üëé Reject
     Timeout: 48h (default)
     Threshold: 70% | Quorum: 50%
     Closes: Thu Jan 30, 10:00 AM"
```

**With Custom Timeout:**
```
Member: "/propose federate abc123 --timeout 96h"

Bot: "üìã Proposal #43
     Federate with group abc123
     
     Vote: üëç Approve | üëé Reject
     Timeout: 96h (custom)
     Threshold: 70% | Quorum: 50%
     Closes: Mon Feb 3, 6:00 PM"
```

**Disagreement with Timeout:**
If you disagree with the timeout, you can:
- Vote No
- Abstain (don't vote)
- Create counter-proposal with different timeout

Abstention is valid democratic participation.

### Bot Real-Time Monitoring (NOT Polling)

**Stored in Freenet Contract:**
```rust
pub struct ActiveProposal {
    proposal: Proposal,
    poll_creator_aci: Uuid,     // Bot's ACI for poll lookup
    poll_timestamp: u64,        // Poll creation timestamp
    
    // ‚ö†Ô∏è AGGREGATES ONLY - Individual votes MUST NEVER be stored
    // Signal shows who voted during poll (ephemeral, E2E encrypted)
    // Stroma stores only counts (permanent, in Freenet)
    approve_count: u32,
    reject_count: u32,
    
    // Status
    checked: bool,              // False until timeout expires
    result: Option<ProposalResult>,
}

// ‚ùå FORBIDDEN - Never create structures like this:
// struct VoteRecord { voter: Hash, choice: Choice, timestamp: u64 }
// Vec<VoteRecord> individual_votes;
```

**Bot Event Loop (Real-Time Stream - NOT Polling):**
```rust
// ‚úÖ REQUIRED: Real-time state stream monitoring
async fn proposal_monitoring_stream(
    signal: &SignalClient,
    freenet: &FreenetClient,
) {
    // Subscribe to state changes (NOT polling with sleep loops)
    let mut state_stream = freenet.subscribe_to_state_changes().await.unwrap();
    
    while let Some(change) = state_stream.next().await {
        match change {
            StateChange::ProposalExpired(proposal_id) => {
                let proposal = freenet.get_proposal(proposal_id).await?;
                
                // 1. Fetch poll results from Signal
                let poll_results = signal
                    .get_poll_results(proposal.poll_creator_aci, proposal.poll_timestamp)
                    .await?;
                
                // 2. Update vote counts (aggregates only)
                let approve_count = poll_results.option_counts[0];  // "Approve" option
                let reject_count = poll_results.option_counts[1];   // "Reject" option
                
                // 3. TERMINATE the Signal Poll (prevents late votes)
                signal.terminate_poll(
                    proposal.group_master_key,
                    proposal.poll_timestamp,
                ).await?;
                
                // 4. Calculate result (quorum + threshold)
                let total_votes = approve_count + reject_count;
                let total_members = freenet.get_member_count().await?;
                let result = calculate_proposal_result(
                    approve_count, 
                    reject_count, 
                    total_members,
                    &config
                );
                
                // 5. Announce result to group
                signal.send_message_to_group(
                    proposal.group_master_key,
                    format_result_announcement(&proposal, &result),
                ).await?;
                
                // 6. If approved (quorum met AND threshold met), execute
                if result.approved {
                    execute_action(&proposal.action, signal).await?;
                }
                
                // 7. Record in Freenet
                freenet.record_proposal_result(proposal.id, result).await?;
                
                // 8. Mark as checked (never check again)
                proposal.checked = true;
            }
        }
    }
}

// ‚úÖ REQUIRED: Terminate poll on Signal when timeout expires
async fn terminate_poll(
    signal: &SignalClient,
    group_master_key: &[u8],
    poll_timestamp: u64,
) -> Result<()> {
    use presage::libsignal_service::proto::data_message::PollTerminate;
    
    let terminate_message = DataMessage {
        poll_terminate: Some(PollTerminate {
            target_sent_timestamp: Some(poll_timestamp),
        }),
        timestamp: Some(now()),
        ..Default::default()
    };
    
    signal.send_message_to_group(group_master_key, terminate_message).await?;
    Ok(())
}
```

**Key Points:**
- Use real-time state stream (NOT polling with sleep loops)
- React to `StateChange::ProposalExpired` events immediately
- **TERMINATE poll on Signal** before announcing result (prevents late votes)
- Only check proposals that haven't been checked AND are expired
- After timeout: terminate ‚Üí announce ‚Üí execute (if approved) ‚Üí record ‚Üí mark checked
- Never check same proposal twice

**Why Poll Termination is Required:**
- Signal polls remain open indefinitely unless explicitly terminated via `PollTerminate`
- Without termination, members could vote after the timeout (confusing UX)
- Termination provides clear visual feedback in Signal UI (poll shows as closed)
- Votes cast after termination are ignored by Signal

### Proposal Result Calculation

```rust
pub struct ProposalResult {
    pub approved: bool,
    pub quorum_met: bool,
    pub threshold_met: bool,
    pub approve_count: u32,
    pub reject_count: u32,
    pub participation_rate: f32,  // total_votes / total_members
    pub approval_rate: f32,       // approve_count / total_votes
}

fn calculate_proposal_result(
    approve_count: u32,
    reject_count: u32,
    total_members: u32,
    config: &GroupConfig,
) -> ProposalResult {
    let total_votes = approve_count + reject_count;
    let participation_rate = total_votes as f32 / total_members as f32;
    let approval_rate = if total_votes > 0 {
        approve_count as f32 / total_votes as f32
    } else {
        0.0
    };
    
    let quorum_met = participation_rate >= config.min_quorum;
    let threshold_met = approval_rate >= config.config_change_threshold;
    
    ProposalResult {
        approved: quorum_met && threshold_met,
        quorum_met,
        threshold_met,
        approve_count,
        reject_count,
        participation_rate,
        approval_rate,
    }
}
```

**Failure Messages:**
- If `!quorum_met`: "Proposal failed: Quorum not met (X% participated, Y% required)"
- If `quorum_met && !threshold_met`: "Proposal failed: Threshold not met (X% approved, Y% required)"
- If `approved`: "Proposal passed: X% approved (quorum: Y%, threshold: Z%)"

### Code Constraints

**Block These Patterns:**
```rust
// ‚ùå NEVER have per-proposal thresholds or quorum
pub struct Proposal {
    threshold: f32,  // WRONG - use GroupConfig.config_change_threshold
    quorum: f32,     // WRONG - use GroupConfig.min_quorum
}

// ‚ùå NEVER allow open-ended polls (no timeout)
pub struct Proposal {
    timeout: Option<Duration>,  // WRONG - timeout is REQUIRED, not optional
}
// Correct: timeout: Duration (always finite, defaults to group config)

// ‚ùå NEVER have urgency levels
pub enum ProposalUrgency {
    Normal,
    Urgent,  // FORBIDDEN - adds complexity
}

// ‚ùå NEVER implement ejection appeals
match subcommand {
    "appeal" => { /* FORBIDDEN - removed from system */ }
}
```

**Enforce These Patterns:**
```rust
// ‚úÖ ALWAYS use config threshold AND quorum
let threshold = group_config.config_change_threshold;  // Not per-proposal
let quorum = group_config.min_quorum;                  // Not per-proposal

// ‚úÖ ALWAYS have a finite timeout (required, never open-ended)
let timeout = args.timeout.unwrap_or(group_config.default_poll_timeout);
// timeout is ALWAYS set - either from --timeout flag or default

// ‚úÖ ALWAYS check both quorum AND threshold
let result = calculate_proposal_result(approve, reject, total_members, &config);
if !result.approved {
    return Err(format!("Quorum: {}, Threshold: {}", result.quorum_met, result.threshold_met));
}
```

### Gastown Agent Instructions

**When implementing `/propose` command:**
1. Parse subcommand (config, stroma, federate)
2. Parse timeout from `--timeout` flag or use config default
3. Use GroupConfig.config_change_threshold (NEVER per-proposal threshold)
4. Use GroupConfig.min_quorum (NEVER per-proposal quorum)
5. NO "appeal" subcommand (explicitly removed)

**When implementing voting:**
1. Use Signal Polls for voting (structured options, native UX)
2. ‚ùå DO NOT use emoji reactions (binary only, harder to tally)
3. Check poll results ONCE after timeout expires
4. Record result in Freenet (pass/fail, aggregate counts ONLY)
5. ‚ùå NEVER persist who voted for what (see security-constraints.bead)
6. Check BOTH quorum AND threshold before executing
7. Execute if approved (quorum_met AND threshold_met)

**When implementing bot loop:**
1. ‚úÖ Use real-time state stream (subscribe to state changes)
2. ‚ùå DO NOT use polling with sleep loops
3. Only check expired, unchecked proposals
4. Mark as checked after first check
5. Never re-check same proposal

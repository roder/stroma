# Bead: Technology Stack

**Status**: Immutable Architectural Constraint  
**Created**: 2026-01-28  
**Updated**: 2026-02-01
**Context**: Architecture Decision 2.5

---

## Target Architecture

**Core Stack:** Rust Static Binary | Signal Protocol | Freenet (Dark) | ZK-Proofs

### Architecture Principles
- **Static Binary**: Must produce statically linked MUSL binary
- **Minimal Attack Surface**: Keep dependencies minimal, monitor binary size
- **Privacy-First**: All integrations must preserve anonymity
- **Decentralized**: No centralized trust authority or coordination

---

## Core Cryptographic Libraries

### `ring`
- **Purpose**: HMAC-SHA256 for identity masking
- **Usage**: Keyed hashing with Signal ACI-derived key (not group pepper)
- **Version**: Use latest stable, audited version
- **Pattern**:
  ```rust
  use ring::hmac;
  use hkdf::Hkdf;
  use sha2::Sha256;
  
  // Derive HMAC key from Signal ACI identity (NOT group pepper)
  fn derive_identity_masking_key(aci_identity: &IdentityKeyPair) -> [u8; 32] {
      let hk = Hkdf::<Sha256>::new(
          Some(b"stroma-identity-masking-v1"),
          aci_identity.private_key().serialize().as_slice()
      );
      let mut key = [0u8; 32];
      hk.expand(b"hmac-sha256-key", &mut key).unwrap();
      key
  }
  
  let key_bytes = derive_identity_masking_key(&aci_identity);
  let key = hmac::Key::new(hmac::HMAC_SHA256, &key_bytes);
  let tag = hmac::sign(&key, signal_id.as_bytes());
  ```
- **See**: `.beads/security-constraints.bead` for complete pattern with zeroization

### `zeroize`
- **Purpose**: Memory hygiene - purge sensitive buffers
- **Usage**: **Mandatory** for all identity masking operations
- **Requirement**: Must zeroize immediately after hashing
- **Pattern**:
  ```rust
  use zeroize::Zeroize;
  buffer.zeroize();
  ```

### `winterfell`
- **Purpose**: STARK proof generation and verification
- **Usage**: Trust verification, recursive ZK vouching
- **Requirement**: Must implement recursive proofs for scalability
- **Why STARKs over SNARKs**: No trusted setup ceremony, post-quantum secure, transparent
- **Integration**: Bot-side verification (Phase 0), outcomes submitted to Freenet
- **See**: `.beads/architecture-decisions.bead` for rationale on STARK choice

---

## Signal Integration: Presage (High-Level Rust)

### Architecture Layers

```
Signal Protocol (specification)
        ‚Üì
libsignal-service-rs (Rust low-level implementation)
        ‚Üì
Presage (Rust high-level convenience API)
        ‚Üì
Stroma Bot (our implementation)
```

### Technology Choice

**Primary: Presage**
- Repository: https://github.com/whisperfish/presage
- Built on: libsignal-service-rs
- Maintained by: Whisperfish
- License: AGPL-3.0
- Provides: Manager, device linking, message handling, connection lifecycle

**When Presage is insufficient:**
- Drop to libsignal-service-rs directly
- Access raw protobuf types
- Implement custom message handling

**Both are Rust. Presage wraps libsignal-service-rs.**

### Signal Device Model

Stroma links as a **secondary device** to an existing Signal account:

- Operator is responsible for having a Signal account (prepaid SIM, SMSpool, etc.)
- Stroma links via QR code using `Manager::link_secondary_device()`
- Linked devices have **full group management capabilities**
- No primary registration (`Manager::register()`) implemented in Stroma

**Rationale:**
- Keeps Stroma's scope minimal (doesn't need SMS/captcha integration)
- Operator controls account creation (their choice of number source)
- Linked devices can do everything Stroma needs (messaging, groups, admin ops)

### What Presage Provides

```rust
use presage::Manager;
// ‚ùå DO NOT USE: use presage_store_sqlite::SqliteStore;
// SqliteStore stores ALL messages - server seizure risk!
// See: security-constraints.bead ¬ß 10 for custom minimal store requirement

use stroma::store::StromaProtocolStore;  // ‚úÖ Custom minimal store

// Link as secondary device (operator scans QR code)
let (tx, rx) = oneshot::channel();
let manager = Manager::link_secondary_device(store, servers, device_name, tx).await?;
let url = rx.await?;
qr2term::print_qr(url.to_string())?;

// After linking, full capabilities available
let messages = manager.receive_messages().await?;
manager.send_message_to_group(master_key, message, timestamp).await?;
```

### What libsignal-service-rs Provides

```rust
use libsignal_service::proto::DataMessage;
use libsignal_service::proto::data_message::Poll;
// ‚ùå DO NOT USE Reaction for voting (exposes voter identity)

// Low-level protobuf access
let reaction = DataMessage {
    reaction: Some(Reaction {
        emoji: Some("üëç".to_string()),
        target_sent_timestamp: Some(timestamp),
        ..Default::default()
    }),
    ..Default::default()
};
```

### Poll Support (Protocol v8)
- **Status**: libsignal-service-rs currently on protocol v7 (polls missing)
- **Solution**: Fork libsignal-service-rs, add protocol v8 poll support
- **Strategy**: Use our fork until upstream merges
- **Implementation**: Gastown Agent-Signal task (see `.beads/poll-implementation-gastown.bead`)

**Why Polls Critical:**
- Structured voting (clear options, easy tallying)
- Multiple choice options (better than binary reactions)
- Native Signal UX (familiar interface)
- Accountability (members can see who voted for what)

### Custom Store Requirement (SERVER SEIZURE PROTECTION)

**CRITICAL**: Default SqliteStore stores ALL messages - violates security model.

**Implementation:**
```rust
pub struct StromaProtocolStore {
    // In-memory (ephemeral, never persisted)
    sessions: HashMap<ServiceId, Session>,
    pre_keys_cache: HashMap<u32, PreKey>,
    
    // Minimal encrypted file (~100KB) for restart only
    protocol_state_file: EncryptedProtocolState,
    
    // NO message history
    // NO contact database
    // NO conversation content
}

impl presage::Store for StromaProtocolStore {
    // Implement protocol requirements only
    // NO message persistence methods
}

// Use with Presage Manager
let manager = Manager::with_store(stroma_store, options).await?;
```

**Why Necessary:**
- Server seizure should reveal NO vetting conversations
- Message history exposes relationship context
- Contact database links Signal IDs to topology
- Protocol state (~100KB) sufficient for encryption continuity

**See**: `.beads/security-constraints.bead` section 10

---

## Freenet Integration

### Freenet Crates (Q1 Validated)

**`freenet` crate** ‚Äî For running the node:
- **Entry Points**:
  - `freenet::dev_tool::SimNetwork` ‚Äî Deterministic multi-node testing
  - `freenet::local_node::Executor::new_mock_in_memory()` ‚Äî Unit testing
  - `freenet::local_node::NodeConfig::build()` ‚Äî Production node
- **See**: [docs.rs/freenet](https://docs.rs/freenet/latest/freenet/)

**`freenet-stdlib` crate** ‚Äî For writing Wasm contracts:
- **Trait**: `ContractInterface` (validate_state, update_state, summarize_state, get_state_delta)
- **Q1 Finding**: Delta operations MUST be commutative (contract's responsibility)
- **Pattern**: Set-based state (BTreeSet) with tombstones for remove-wins
- **Merkle Trees**: Generate on-demand from sets (not stored in contract)
- **See**: `docs/spike/q1/RESULTS.md` for validated patterns

### Freenet Integration Guardrails
- ‚úÖ **DO**: Use `freenet` crate for node embedding (NodeConfig::build())
- ‚úÖ **DO**: Use `freenet-stdlib` for contracts (ContractInterface trait)
- ‚úÖ **DO**: Use set-based structures (BTreeSet, HashMap) for mergeability
- ‚úÖ **DO**: Generate Merkle Trees on-demand (not stored in contract)
- ‚úÖ **DO**: Implement summary-delta synchronization
- ‚úÖ **DO**: Test delta commutativity (same result regardless of order)
- ‚úÖ **DO**: Use tombstones for deletions (remove-wins semantics)
- ‚ùå **DON'T**: Store Merkle Trees as primary state (not mergeable)
- ‚ùå **DON'T**: Use Vec for state (order matters, not easily mergeable)
- ‚ùå **DON'T**: Expect Freenet to enforce commutativity (contract's job)
- ‚ùå **DON'T**: Expose member identities in contract state (use hashes)

---

## Serialization: CBOR (Not JSON)

### Decision

**Freenet works with raw bytes** (`Vec<u8>`). Serialization is our responsibility.

**Format**: CBOR via `ciborium` crate

### Why CBOR

| Criterion | JSON | CBOR |
|-----------|------|------|
| Size | Large (baseline) | **60% smaller** |
| Deterministic | No* | **Yes** (canonical mode) |
| Speed | Slow | **Fast** |
| Cross-language | Yes | **Yes** |

*JSON key ordering varies between serializers

### Dependencies

```toml
[dependencies]
serde = { version = "1.0", features = ["derive"] }
ciborium = "0.2"
```

### Pattern

```rust
use ciborium::{from_reader, into_writer};

impl TrustNetworkState {
    pub fn to_bytes(&self) -> Result<Vec<u8>, Error> {
        let mut bytes = Vec::new();
        into_writer(self, &mut bytes)?;
        Ok(bytes)
    }
    
    pub fn from_bytes(bytes: &[u8]) -> Result<Self, Error> {
        from_reader(bytes).map_err(Into::into)
    }
}
```

### Rules

- ‚úÖ **CBOR**: All Freenet state, deltas, persistence snapshots
- ‚úÖ **Protobuf**: Signal messages (Signal's format, non-negotiable)
- ‚ùå **JSON**: NOT for Freenet state (too large, non-deterministic)

**See**: `.beads/serialization-format.bead` for full rationale

---

## Build Requirements

### Static MUSL Binary
- **Requirement**: Must produce statically linked MUSL binary
- **Target**: `x86_64-unknown-linux-musl` or equivalent
- **Configuration**: Use `cross` or `cargo build --target` with musl toolchain
- **Rationale**: Minimal attack surface, no dynamic linking vulnerabilities

### Binary Size Monitoring
- **Requirement**: Monitor binary size in CI/CD
- **Tool**: Gastown Deacon or custom script
- **Action**: Alert on significant size increases (indicates dependency bloat)
- **Constraint**: Keep attack surface minimal

### Rust Version
- **Minimum**: Rust 1.93+ (released Jan 22, 2026)
- **Edition**: 2021
- **Rationale**: 
  - Bundled musl 1.2.5 with major DNS resolver improvements
  - More reliable networking for Signal and freenet-core
  - Better handling of large DNS records and recursive name servers
  - Security updates and modern features

---

## Mandatory Tooling

### Supply Chain Security

#### `cargo-deny`
- **Purpose**: Dependency auditing
- **Requirement**: **Mandatory** in CI/CD pipeline
- **Usage**: Check for security vulnerabilities, license issues, duplicate dependencies
- **Configuration**: Must run before every merge

#### `cargo-crev`
- **Purpose**: Cryptographic verification of dependencies
- **Requirement**: **Mandatory** in CI/CD pipeline
- **Usage**: Verify crate authenticity and security reviews
- **Integration**: Part of Gastown CI/CD pipeline

### Testing Tooling

#### `cargo-nextest`
- **Purpose**: Test execution framework
- **Requirement**: Use for all test runs
- **Usage**: `cargo nextest run` for deterministic test execution

#### Coverage Tools
- **Options**: `cargo-llvm-cov` or `cargo-tarpaulin`
- **Requirement**: Enforce 100% code coverage
- **Integration**: Generate coverage reports in CI/CD

### Development Tools

#### `rustfmt`
- **Purpose**: Code formatting
- **Requirement**: All code must be formatted
- **Usage**: Run automatically in pre-commit hooks

#### `clippy`
- **Purpose**: Linting and code quality
- **Requirement**: Fix all warnings before merging
- **Usage**: `cargo clippy -- -D warnings`

---

## Runtime Requirements

### Sandboxing (Production)
- **Tool**: seccomp
- **Requirement**: Production bot runs in restricted sandbox
- **Allowed**: Only Signal and Freenet node traffic
- **Blocked**: All other network access
- **Rationale**: Minimize attack surface

### Memory Safety
- **Requirement**: No `unsafe` blocks without security review
- **Tool**: `zeroize` for sensitive buffer cleanup
- **Pattern**: Zeroize immediately after cryptographic operations
- **Audit**: Review all `unsafe` usage in code review

---

## Dependencies Configuration

### Cargo.toml Requirements
```toml
[package]
name = "stroma"
version = "0.1.0"
edition = "2021"

[dependencies]
# Cryptography
ring = { version = "...", features = ["std"] }
zeroize = { version = "...", features = ["zeroize_derive"] }
winterfell = { version = "..." }  # STARKs (not arkworks/SNARKs)
hkdf = { version = "..." }  # Key derivation from Signal ACI

# Serialization
serde = { version = "1.0", features = ["derive"] }
ciborium = "0.2"  # CBOR for Freenet contracts (NOT JSON)

# Signal integration (uses forked presage with protocol v8 polls)
presage = { git = "https://github.com/roder/presage", branch = "feature/protocol-v8-polls-compatibility" }

# Freenet integration
freenet-stdlib = { version = "...", features = ["full"] }

[dev-dependencies]
proptest = "..."  # For property-based testing

[patch."https://github.com/whisperfish/libsignal-service-rs"]
libsignal-service = {
    git = "https://github.com/roder/libsignal-service-rs",
    branch = "feature/protocol-v8-polls-rebased"
}

[patch.crates-io]
curve25519-dalek = { git = 'https://github.com/signalapp/curve25519-dalek', tag = 'signal-curve25519-4.1.3' }
# Security patches for unmaintained crates (see patches/ directory):
# paste -> pastey (RUSTSEC-2024-0436)
# rustls-pemfile -> rustls-pki-types (RUSTSEC-2025-0134)
# bincode -> bincode2 (RUSTSEC-2025-0141)

[profile.release]
opt-level = "z"  # Optimize for size
lto = true  # Link-time optimization
strip = true  # Strip symbols
```

---

## Prohibited Dependencies

- ‚ùå **NEVER** use crates that require network access (except Signal/Freenet)
- ‚ùå **NEVER** use crates that log or expose identifiers
- ‚ùå **NEVER** use crates with known security vulnerabilities
- ‚ùå **NEVER** use crates that bypass zeroization requirements
- ‚ùå **NEVER** use logging frameworks that might leak identifiers
- ‚ùå **NEVER** use database libraries (use Freenet for state)
- ‚ùå **NEVER** use convenience libraries that add significant bloat
- ‚ùå **NEVER** use unmaintained or security-vulnerable crates

---

## Anti-Patterns

### Code Constraints

**Block These Patterns:**
```rust
// ‚ùå FORBIDDEN - Default store with message persistence
let store = SqliteStore::open_with_passphrase(...).await?;

// ‚ùå FORBIDDEN - Storing messages
async fn save_message(&mut self, message: &Message) -> Result<()> {
    self.db.insert_message(message).await?;  // NEVER do this
}
```

**Enforce These Patterns:**
```rust
// ‚úÖ REQUIRED - Custom minimal store
pub struct StromaProtocolStore { /* protocol state only */ }

// ‚úÖ REQUIRED - Use Presage Manager with custom store
let manager = Manager::with_store(stroma_store, options).await?;

// ‚úÖ REQUIRED - Ephemeral message handling
async fn handle_message(&mut self, message: Message) -> Result<()> {
    process_command(&message)?;
    // Message NOT stored - ephemeral only
    Ok(())
}
```

---

## CI/CD Pipeline Requirements

1. **Build**: Static MUSL binary
2. **Test**: `cargo nextest run` with 100% coverage
3. **Audit**: `cargo-deny check` and `cargo-crev verify`
4. **Lint**: `cargo clippy -- -D warnings`
5. **Format**: `cargo fmt --check`
6. **Size**: Monitor binary size (alert on increases)

---

## Gastown Agent Instructions

**When implementing Signal integration:**
1. Use Presage as primary API
2. Check Presage docs first: https://whisperfish.github.io/presage
3. If Presage doesn't expose feature, use libsignal-service-rs directly
4. Both are Rust - no language boundary

**‚ö†Ô∏è CRITICAL: Custom Store Required (Security Guardrail)**
- ‚ùå **NEVER use `presage-store-sqlite`** - it stores message history (security violation)
- ‚úÖ **ALWAYS use `StromaProtocolStore`** - custom store that stores only protocol state
- Custom store implements: `IdentityKeyStore`, `PreKeyStore`, `SessionStore`, `SenderKeyStore`
- No message content, no conversation history, no metadata beyond protocol needs
- See: `.beads/security-constraints.bead` for complete rationale

```rust
// ‚ùå FORBIDDEN - stores message history
use presage_store_sqlite::SqliteStore;
let store = SqliteStore::open("path/to/db")?;

// ‚úÖ REQUIRED - custom store, protocol state only
use crate::signal::StromaProtocolStore;
let store = StromaProtocolStore::new(config.store_path)?;
```

**Common misconception to avoid:**
- NOT a choice between Java (signal-cli) and Rust (Presage)
- It's: low-level (libsignal-service-rs) vs high-level (Presage)
- Both are Rust, both maintained by Whisperfish

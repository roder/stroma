# Bead: Technology Stack

**Status**: Immutable Architectural Constraint  
**Created**: 2026-01-28  
**Context**: Architecture Decision 2.5

---

## Signal Integration: Presage (High-Level Rust)

### Architecture Layers

```
Signal Protocol (specification)
        ‚Üì
libsignal-service-rs (Rust low-level implementation)
        ‚Üì
Presage (Rust high-level convenience API)
        ‚Üì
Stroma Bot (our implementation)
```

### Technology Choice

**Primary: Presage**
- Repository: https://github.com/whisperfish/presage
- Built on: libsignal-service-rs
- Maintained by: Whisperfish
- License: AGPL-3.0
- Provides: Manager, registration, message handling, connection lifecycle

**When Presage is insufficient:**
- Drop to libsignal-service-rs directly
- Access raw protobuf types
- Implement custom message handling

**Both are Rust. Presage wraps libsignal-service-rs.**

### What Presage Provides

```rust
use presage::Manager;
// ‚ùå DO NOT USE: use presage_store_sqlite::SqliteStore;
// SqliteStore stores ALL messages - server seizure risk!
// See: security-constraints.bead ¬ß 10 for custom minimal store requirement

use stroma::store::StromaProtocolStore;  // ‚úÖ Custom minimal store

// High-level operations
let store = StromaProtocolStore::new()?;
let manager = Manager::with_store(store, options).await?;
let messages = manager.receive_messages().await?;
manager.send_message_to_group(master_key, message, timestamp).await?;
```

### What libsignal-service-rs Provides

```rust
use libsignal_service::proto::DataMessage;
use libsignal_service::proto::data_message::Poll;
// ‚ùå DO NOT USE Reaction for voting (exposes voter identity)

// Low-level protobuf access
let reaction = DataMessage {
    reaction: Some(Reaction {
        emoji: Some("üëç".to_string()),
        target_sent_timestamp: Some(timestamp),
        ..Default::default()
    }),
    ..Default::default()
};
```

### When to Use Each

**Use Presage for:**
- Registration
- Message sending/receiving
- Group management
- Contact handling
- Connection lifecycle

**Use libsignal-service-rs for:**
- Custom protobuf messages (when Presage doesn't expose)
- Raw Signal protocol operations
- Features Presage doesn't wrap yet

### Dependencies

```toml
[dependencies]
# High-level Signal client API
presage = { git = "https://github.com/whisperfish/presage" }
# DO NOT use presage-store-sqlite (stores message history - server seizure risk)
# Implement custom minimal StromaProtocolStore instead

# For custom store encryption (if using file persistence)
sqlcipher = "0.34"

# Patch for curve25519 (required by Presage)
[patch.crates-io]
curve25519-dalek = { git = 'https://github.com/signalapp/curve25519-dalek', tag = 'signal-curve25519-4.1.3' }

# Use forked libsignal-service with protocol v8 poll support
libsignal-service = {
    git = "https://github.com/roder/libsignal-service-rs",
    branch = "feature/protocol-v8-polls"
}
```

### Custom Store Requirement (SERVER SEIZURE PROTECTION)

**CRITICAL**: Default SqliteStore stores ALL messages - violates security model.

**Implementation:**
```rust
pub struct StromaProtocolStore {
    // In-memory (ephemeral, never persisted)
    sessions: HashMap<ServiceId, Session>,
    pre_keys_cache: HashMap<u32, PreKey>,
    
    // Minimal encrypted file (~100KB) for restart only
    protocol_state_file: EncryptedProtocolState,
    
    // NO message history
    // NO contact database
    // NO conversation content
}

impl presage::Store for StromaProtocolStore {
    // Implement protocol requirements only
    // NO message persistence methods
}

// Use with Presage Manager
let manager = Manager::with_store(stroma_store, options).await?;
```

**Why Necessary:**
- Server seizure should reveal NO vetting conversations
- Message history exposes relationship context
- Contact database links Signal IDs to topology
- Protocol state (~100KB) sufficient for encryption continuity

**See**: `.beads/security-constraints.bead` section 10

### Code Constraints

**Block These Patterns:**
```rust
// ‚ùå FORBIDDEN - Default store with message persistence
let store = SqliteStore::open_with_passphrase(...).await?;

// ‚ùå FORBIDDEN - Storing messages
async fn save_message(&mut self, message: &Message) -> Result<()> {
    self.db.insert_message(message).await?;  // NEVER do this
}
```

**Enforce These Patterns:**
```rust
// ‚úÖ REQUIRED - Custom minimal store
pub struct StromaProtocolStore { /* protocol state only */ }

// ‚úÖ REQUIRED - Use Presage Manager with custom store
let manager = Manager::with_store(stroma_store, options).await?;

// ‚úÖ REQUIRED - Ephemeral message handling
async fn handle_message(&mut self, message: Message) -> Result<()> {
    // Process message (vouch, flag, etc.)
    process_command(&message)?;
    
    // Message NOT stored - ephemeral only
    // (no persistence call)
    
    Ok(())
}
```

### Gastown Agent Instructions

**When implementing Signal integration:**
1. Use Presage as primary API
2. Check Presage docs first: https://whisperfish.github.io/presage
3. If Presage doesn't expose feature, use libsignal-service-rs directly
4. Both are Rust - no language boundary

**Common misconception to avoid:**
- NOT a choice between Java (signal-cli) and Rust (Presage)
- It's: low-level (libsignal-service-rs) vs high-level (Presage)
- Both are Rust, both maintained by Whisperfish

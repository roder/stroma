# Bead: Technology Stack

**Status**: Immutable Architectural Constraint  
**Created**: 2026-01-28  
**Context**: Architecture Decision 2.5

---

## Signal Integration: Presage (High-Level Rust)

### Architecture Layers

```
Signal Protocol (specification)
        ‚Üì
libsignal-service-rs (Rust low-level implementation)
        ‚Üì
Presage (Rust high-level convenience API)
        ‚Üì
Stroma Bot (our implementation)
```

### Technology Choice

**Primary: Presage**
- Repository: https://github.com/whisperfish/presage
- Built on: libsignal-service-rs
- Maintained by: Whisperfish
- License: AGPL-3.0
- Provides: Manager, device linking, message handling, connection lifecycle

**When Presage is insufficient:**
- Drop to libsignal-service-rs directly
- Access raw protobuf types
- Implement custom message handling

**Both are Rust. Presage wraps libsignal-service-rs.**

### Signal Device Model

Stroma links as a **secondary device** to an existing Signal account:

- Operator is responsible for having a Signal account (prepaid SIM, SMSpool, etc.)
- Stroma links via QR code using `Manager::link_secondary_device()`
- Linked devices have **full group management capabilities**
- No primary registration (`Manager::register()`) implemented in Stroma

**Rationale:**
- Keeps Stroma's scope minimal (doesn't need SMS/captcha integration)
- Operator controls account creation (their choice of number source)
- Linked devices can do everything Stroma needs (messaging, groups, admin ops)

### What Presage Provides

```rust
use presage::Manager;
// ‚ùå DO NOT USE: use presage_store_sqlite::SqliteStore;
// SqliteStore stores ALL messages - server seizure risk!
// See: security-constraints.bead ¬ß 10 for custom minimal store requirement

use stroma::store::StromaProtocolStore;  // ‚úÖ Custom minimal store

// Link as secondary device (operator scans QR code)
let (tx, rx) = oneshot::channel();
let manager = Manager::link_secondary_device(store, servers, device_name, tx).await?;
let url = rx.await?;
qr2term::print_qr(url.to_string())?;

// After linking, full capabilities available
let messages = manager.receive_messages().await?;
manager.send_message_to_group(master_key, message, timestamp).await?;
```

### What libsignal-service-rs Provides

```rust
use libsignal_service::proto::DataMessage;
use libsignal_service::proto::data_message::Poll;
// ‚ùå DO NOT USE Reaction for voting (exposes voter identity)

// Low-level protobuf access
let reaction = DataMessage {
    reaction: Some(Reaction {
        emoji: Some("üëç".to_string()),
        target_sent_timestamp: Some(timestamp),
        ..Default::default()
    }),
    ..Default::default()
};
```

### When to Use Each

**Use Presage for:**
- Device linking (link_secondary_device)
- Message sending/receiving
- Group management
- Contact handling
- Connection lifecycle

**Use libsignal-service-rs for:**
- Custom protobuf messages (when Presage doesn't expose)
- Raw Signal protocol operations
- Features Presage doesn't wrap yet

### Dependencies

```toml
[dependencies]
# High-level Signal client API
presage = { git = "https://github.com/whisperfish/presage" }
# DO NOT use presage-store-sqlite (stores message history - server seizure risk)
# Implement custom minimal StromaProtocolStore instead

# For custom store encryption (if using file persistence)
sqlcipher = "0.34"

# Patch for curve25519 (required by Presage)
[patch.crates-io]
curve25519-dalek = { git = 'https://github.com/signalapp/curve25519-dalek', tag = 'signal-curve25519-4.1.3' }

# Use forked libsignal-service with protocol v8 poll support
libsignal-service = {
    git = "https://github.com/roder/libsignal-service-rs",
    branch = "feature/protocol-v8-polls"
}
```

### Custom Store Requirement (SERVER SEIZURE PROTECTION)

**CRITICAL**: Default SqliteStore stores ALL messages - violates security model.

**Implementation:**
```rust
pub struct StromaProtocolStore {
    // In-memory (ephemeral, never persisted)
    sessions: HashMap<ServiceId, Session>,
    pre_keys_cache: HashMap<u32, PreKey>,
    
    // Minimal encrypted file (~100KB) for restart only
    protocol_state_file: EncryptedProtocolState,
    
    // NO message history
    // NO contact database
    // NO conversation content
}

impl presage::Store for StromaProtocolStore {
    // Implement protocol requirements only
    // NO message persistence methods
}

// Use with Presage Manager
let manager = Manager::with_store(stroma_store, options).await?;
```

**Why Necessary:**
- Server seizure should reveal NO vetting conversations
- Message history exposes relationship context
- Contact database links Signal IDs to topology
- Protocol state (~100KB) sufficient for encryption continuity

**See**: `.beads/security-constraints.bead` section 10

---

## Serialization: CBOR (Not JSON)

### Decision

**Freenet works with raw bytes** (`Vec<u8>`). Serialization is our responsibility.

**Format**: CBOR via `ciborium` crate

### Why CBOR

| Criterion | JSON | CBOR |
|-----------|------|------|
| Size | Large (baseline) | **60% smaller** |
| Deterministic | No* | **Yes** (canonical mode) |
| Speed | Slow | **Fast** |
| Cross-language | Yes | **Yes** |

*JSON key ordering varies between serializers

### Dependencies

```toml
[dependencies]
serde = { version = "1.0", features = ["derive"] }
ciborium = "0.2"
```

### Pattern

```rust
use ciborium::{from_reader, into_writer};

impl TrustNetworkState {
    pub fn to_bytes(&self) -> Result<Vec<u8>, Error> {
        let mut bytes = Vec::new();
        into_writer(self, &mut bytes)?;
        Ok(bytes)
    }
    
    pub fn from_bytes(bytes: &[u8]) -> Result<Self, Error> {
        from_reader(bytes).map_err(Into::into)
    }
}
```

### Rules

- ‚úÖ **CBOR**: All Freenet state, deltas, persistence snapshots
- ‚úÖ **Protobuf**: Signal messages (Signal's format, non-negotiable)
- ‚ùå **JSON**: NOT for Freenet state (too large, non-deterministic)

**See**: `.beads/serialization-format.bead` for full rationale

---

### Code Constraints

**Block These Patterns:**
```rust
// ‚ùå FORBIDDEN - Default store with message persistence
let store = SqliteStore::open_with_passphrase(...).await?;

// ‚ùå FORBIDDEN - Storing messages
async fn save_message(&mut self, message: &Message) -> Result<()> {
    self.db.insert_message(message).await?;  // NEVER do this
}
```

**Enforce These Patterns:**
```rust
// ‚úÖ REQUIRED - Custom minimal store
pub struct StromaProtocolStore { /* protocol state only */ }

// ‚úÖ REQUIRED - Use Presage Manager with custom store
let manager = Manager::with_store(stroma_store, options).await?;

// ‚úÖ REQUIRED - Ephemeral message handling
async fn handle_message(&mut self, message: Message) -> Result<()> {
    // Process message (vouch, flag, etc.)
    process_command(&message)?;
    
    // Message NOT stored - ephemeral only
    // (no persistence call)
    
    Ok(())
}
```

### Gastown Agent Instructions

**When implementing Signal integration:**
1. Use Presage as primary API
2. Check Presage docs first: https://whisperfish.github.io/presage
3. If Presage doesn't expose feature, use libsignal-service-rs directly
4. Both are Rust - no language boundary

**Common misconception to avoid:**
- NOT a choice between Java (signal-cli) and Rust (Presage)
- It's: low-level (libsignal-service-rs) vs high-level (Presage)
- Both are Rust, both maintained by Whisperfish

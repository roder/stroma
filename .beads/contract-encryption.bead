# Contract Encryption Model (IMMUTABLE)

**Status**: Pinned - Cannot be modified without explicit unpinning ceremony
**Last Updated**: 2026-02-12
**Applies To**: State encryption, persistence fragments, Agent-Crypto

---

## WHY: Encryption is Required

### The Threat Model

Persistence peers are **adversaries**. They hold your encrypted fragments but should learn nothing.

| Without Encryption | With Encryption |
|-------------------|-----------------|
| Peer sees your members | Peer sees random bytes |
| Peer learns vouch graph | Peer learns nothing |
| Peer can reconstruct state | Peer cannot decrypt |
| Trust map seizure possible | Trust map protected |

### Connection to Core Goal

> A crashed bot recovers its trust map from **adversarial peers who cannot read** that data.

Encryption is what makes "adversarial peers" safe to use.

### Why Full State Encryption (Not Delta Encryption)

Analysis of delta-then-encrypt vs full-state encryption:

| Approach | Recovery Complexity | Update Efficiency | Security |
|----------|--------------------|--------------------|----------|
| Full state per update | Simple (get latest) | Acceptable (infrequent) | Strong |
| Delta encryption | Complex (replay all) | Better | Complex analysis needed |

**Decision:** Full state encryption because:
- Trust state changes are **infrequent** (human timescale: ~10-100/month)
- Chunk creation is fast (< 100ms for typical state)
- Encryption nonces produce different ciphertext each time
- No deduplication benefit from content-addressing
- Simplicity > optimization for rare operations

---

## Encrypted State Structure (REQUIRED)

```rust
pub struct EncryptedTrustNetworkState {
    // Encrypted payload
    ciphertext: Vec<u8>,           // AES-256-GCM encrypted trust state
    nonce: [u8; 12],               // GCM nonce (unique per encryption)
    
    // Authority (mnemonic-derived signing key)
    signature: Vec<u8>,            // Ed25519 signature using state_signing_key
    signing_pubkey: Vec<u8>,       // Public key for verification
    
    // Public commitment (for ZK-proof verification)
    member_merkle_root: Hash,      // Generated on-demand from BTreeSet
    
    // Versioning (recovery + anti-replay)
    version: u64,                  // Monotonic, increments on each write
    previous_hash: Hash,           // Chain integrity
    timestamp: Timestamp,          // When state was created
    
    // Key epoch (rotation tracking)
    key_epoch: u64,                // Which derivation generation created this state
}
```

### Field Requirements

| Field | Requirement | Rationale |
|-------|-------------|-----------|
| `ciphertext` | AES-256-GCM | Industry standard authenticated encryption |
| `nonce` | Random, never reuse | GCM security requires unique nonce |
| `signature` | Mnemonic-derived signing key | Signs using `state_signing_key` from StromaKeyring |
| `signing_pubkey` | Derived from StromaKeyring | Identifies authoritative writer |
| `member_merkle_root` | Generated on demand | Public for ZK-proofs, doesn't leak membership |
| `version` | Strictly monotonic | Anti-replay, recovery ordering |
| `previous_hash` | Hash of previous state | Chain integrity detection |
| `timestamp` | Wall clock time | Debugging, freshness hints |
| `key_epoch` | From StromaKeyring | Tracks which key generation created this state |

---

## Encryption Algorithm (FIXED)

### AES-256-GCM

```rust
use ring::aead::{Aead, AES_256_GCM, Nonce, UnboundKey, LessSafeKey};

fn encrypt_state(plaintext: &[u8], key: &[u8; 32]) -> Result<(Vec<u8>, [u8; 12])> {
    // Generate random nonce (NEVER reuse)
    let nonce_bytes: [u8; 12] = rand::random();
    let nonce = Nonce::assume_unique_for_key(nonce_bytes);
    
    // Create cipher
    let unbound_key = UnboundKey::new(&AES_256_GCM, key)?;
    let key = LessSafeKey::new(unbound_key);
    
    // Encrypt with authentication tag
    let mut ciphertext = plaintext.to_vec();
    key.seal_in_place_append_tag(nonce, Aad::empty(), &mut ciphertext)?;
    
    Ok((ciphertext, nonce_bytes))
}

fn decrypt_state(ciphertext: &[u8], nonce: &[u8; 12], key: &[u8; 32]) -> Result<Vec<u8>> {
    let nonce = Nonce::assume_unique_for_key(*nonce);
    let unbound_key = UnboundKey::new(&AES_256_GCM, key)?;
    let key = LessSafeKey::new(unbound_key);
    
    let mut plaintext = ciphertext.to_vec();
    key.open_in_place(nonce, Aad::empty(), &mut plaintext)?;
    
    // Remove auth tag
    plaintext.truncate(plaintext.len() - AES_256_GCM.tag_len());
    Ok(plaintext)
}
```

### Why AES-256-GCM

- **Authenticated**: Detects tampering (AEAD)
- **Standard**: Widely audited, well-understood
- **Performance**: Hardware acceleration (AES-NI)
- **Key size**: 256-bit provides long-term security

---

## Signature Algorithm (FIXED)

### Mnemonic-Derived Signing Key

The bot signs state using `state_signing_key` derived from the mnemonic:

```rust
use ed25519_dalek::{SigningKey, VerifyingKey, Signature, Signer, Verifier};
use stroma::crypto::StromaKeyring;

fn sign_state(state_hash: &Hash, signing_key: &[u8; 32]) -> Vec<u8> {
    let key = SigningKey::from_bytes(signing_key);
    key.sign(state_hash.as_bytes()).to_bytes().to_vec()
}

fn verify_signature(state_hash: &Hash, signature: &[u8], pubkey: &[u8; 32]) -> bool {
    let verifying_key = VerifyingKey::from_bytes(pubkey).ok()?;
    let sig = Signature::from_slice(signature).ok()?;
    verifying_key.verify(state_hash.as_bytes(), &sig).is_ok()
}

// Usage with StromaKeyring:
let keyring = StromaKeyring::from_mnemonic(&passphrase)?;
let signature = sign_state(&state_hash, keyring.state_signing_key());
```

### What Gets Signed

**Sign the hash of**: `(ciphertext || nonce || version || previous_hash || timestamp)`

```rust
fn compute_state_hash(state: &EncryptedTrustNetworkState) -> Hash {
    let mut hasher = Sha256::new();
    hasher.update(&state.ciphertext);
    hasher.update(&state.nonce);
    hasher.update(&state.version.to_le_bytes());
    hasher.update(&state.previous_hash);
    hasher.update(&state.timestamp.to_le_bytes());
    Hash(hasher.finalize().into())
}
```

### Why Ed25519

- **Fast**: 15,000+ verifications/second
- **Compact**: 64-byte signatures
- **Secure**: No known attacks
- **Deterministic**: Same input = same signature (testable)

---

## Key Derivation (REQUIRED)

### BIP-39 Mnemonic as Cryptographic Foundation

**All keys are derived from the 24-word BIP-39 mnemonic** via `StromaKeyring`.

| Purpose | Key Source | HKDF Info |
|---------|------------|-----------|
| Identity Masking | StromaKeyring | `"identity-masking-v1"` |
| Voter Dedup | StromaKeyring | `"voter-dedup-v1"` |
| Chunk Encryption | StromaKeyring | `"chunk-encryption-v1"` |
| Chunk Signing | StromaKeyring | `"chunk-signing-v1"` |
| State Encryption | StromaKeyring | `"state-encryption-v1"` |
| State Signing | StromaKeyring | `"state-signing-v1"` |

```rust
use stroma::crypto::StromaKeyring;

// At bot startup: derive all keys from 24-word BIP-39 mnemonic
let keyring = StromaKeyring::from_mnemonic(&passphrase)?;

// Use derived keys for cryptographic operations
let state_encryption_key = keyring.state_encryption_key();
let chunk_encryption_key = keyring.chunk_encryption_key();
let identity_masking_key = keyring.identity_masking_key();

// Key hierarchy (from crypto/keyring.rs):
// BIP-39 Mnemonic (24 words)
//         │
//         ▼
// bip39::to_seed("")  → [u8; 64] master seed
//         │
//         ▼
// HKDF-SHA256(salt="stroma-master-v1", seed)
//         │
//         ├─► HKDF expand("identity-masking-v1") → identity_masking_key
//         ├─► HKDF expand("voter-dedup-v1")      → voter_pepper
//         ├─► HKDF expand("chunk-encryption-v1") → chunk_encryption_key
//         ├─► HKDF expand("chunk-signing-v1")    → chunk_signing_key
//         ├─► HKDF expand("state-encryption-v1") → state_encryption_key
//         └─► HKDF expand("state-signing-v1")    → state_signing_key
```

### Why Use Mnemonic (not Signal ACI)

| Benefit | Explanation |
|---------|-------------|
| **Stable root** | Mnemonic never changes (ACI can change on re-registration/ban) |
| **Operator control** | Mnemonic is entered at startup, not managed by Signal |
| **Rotation support** | `key_epoch` tracks derivation generation for migration |
| **Consistent derivation** | All keys derived from same source via HKDF |
| **Separate concerns** | Mnemonic for Stroma crypto, Signal store for protocol state |

**Key Insight**: Operators need to back up:
1. **Mnemonic** (24 words) - root of all Freenet chunk encryption/signing
2. **Signal store** - for protocol state recovery (sessions, identity, etc.)

**Rotation Strategy**:
- `StromaKeyring.epoch()` returns current derivation generation (default: 1)
- `TrustNetworkState.key_epoch` tracks which epoch created the MemberHashes
- Domain strings include "v1" suffix for future versioning
- On rotation: increment epoch, re-invite members with new hashes

**Signal ACI is DEPRECATED for key derivation**: Previously, some keys were derived from Signal ACI. This is now replaced by mnemonic-derived keys for stability across Signal account changes.

---

## Version Chain (REQUIRED)

### Monotonic Versioning

```rust
impl EncryptedTrustNetworkState {
    pub fn new(plaintext: &TrustState, previous: Option<&Self>, keyring: &StromaKeyring) -> Self {
        let version = previous.map(|p| p.version + 1).unwrap_or(1);
        let previous_hash = previous.map(|p| p.hash()).unwrap_or(Hash::zero());
        
        let (ciphertext, nonce) = encrypt_state(
            &serialize(plaintext),
            keyring.state_encryption_key()
        ).unwrap();
        
        let mut state = Self {
            ciphertext,
            nonce,
            signature: Vec::new(),
            signing_pubkey: derive_pubkey(keyring.state_signing_key()),
            member_merkle_root: plaintext.compute_merkle_root(),
            version,
            previous_hash,
            timestamp: now(),
            key_epoch: keyring.epoch(),
        };
        
        state.signature = sign_state(&state.hash(), keyring.state_signing_key());
        state
    }
}
```

### Anti-Replay Properties

| Attack | Prevention |
|--------|------------|
| Replay old state | Version must be strictly > previous |
| Fork chain | previous_hash must match |
| Tamper timestamp | Signature covers all fields |

### Recovery Ordering

During recovery, version determines which state is authoritative:
- Collect fragments from multiple holders
- If versions differ, use highest version
- Verify chain integrity (previous_hash links)

---

## Merkle Root (PUBLIC COMMITMENT)

### Purpose

The `member_merkle_root` is PUBLIC (not encrypted). It allows:

1. **ZK-proof verification**: Prove membership without decryption
2. **Cross-mesh verification**: Other bots can verify membership claims
3. **No privacy leak**: Root doesn't reveal individual members

### Generation

```rust
impl TrustState {
    pub fn compute_merkle_root(&self) -> Hash {
        // Members are HMAC-hashed identities (already anonymous)
        let leaves: Vec<Hash> = self.members.iter().cloned().collect();
        merkle_root(&leaves)
    }
}
```

### What Merkle Root Reveals

| Reveals | Does NOT Reveal |
|---------|-----------------|
| Number of members (indirectly via tree depth) | Individual member identities |
| State version changed | Vouch/flag relationships |
| Something about membership | Who vouched for whom |

---

## Chunk Structure (AFTER ENCRYPTION)

```rust
pub struct Chunk {
    data: Vec<u8>,             // 64KB of encrypted state
    chunk_index: u32,          // Position in sequence (0, 1, 2, ...)
    chunk_hash: Hash,          // For integrity verification
    version: u64,              // Must match across chunks
}
```

### Chunking Flow

```
TrustState (plaintext)
     │
     ▼ serialize
Raw bytes
     │
     ▼ AES-256-GCM encrypt
EncryptedTrustNetworkState
     │
     ▼ serialize (full struct)
Encrypted bytes (e.g., 500KB)
     │
     ▼ split into 64KB chunks
Chunk[0], Chunk[1], ... Chunk[7]
     │
     ▼ for each chunk: compute 2 holders via rendezvous hashing
     ▼ distribute 2 replicas per chunk
Holder-X,Y (chunk 0), Holder-Z,W (chunk 1), ... Holder-P,Q (chunk 7)
```

### Security Properties

| Layer | Protection |
|-------|------------|
| Encryption | Holders can't read even if they have all chunks |
| Distribution | Need ALL chunks + mnemonic-derived key to reconstruct |
| Combined | Defense in depth: need mnemonic AND all chunks |

---

## Nonce Management (CRITICAL)

### Never Reuse Nonces

GCM security **requires** unique nonces. Reusing a nonce with the same key is catastrophic.

```rust
// ❌ NEVER
fn bad_encrypt() {
    let nonce = [0u8; 12]; // Fixed nonce
    encrypt(&key, &nonce, &data); // BROKEN SECURITY
}

// ✅ ALWAYS
fn good_encrypt() {
    let nonce: [u8; 12] = rand::random(); // Random nonce
    encrypt(&key, &nonce, &data); // Secure
}
```

### Nonce Storage

Nonce is stored alongside ciphertext (it's not secret):

```rust
pub struct EncryptedTrustNetworkState {
    ciphertext: Vec<u8>,
    nonce: [u8; 12],  // Public, stored with ciphertext
    // ...
}
```

---

## Constraints Checklist (VERIFY BEFORE MERGE)

| Constraint | Verification |
|------------|--------------|
| AES-256-GCM | No other symmetric cipher |
| Ed25519 | No other signature scheme |
| Random nonces | Never hardcoded or sequential |
| Version monotonic | Strictly increasing |
| Chain integrity | previous_hash links states |
| Sign all fields | Hash covers ciphertext, nonce, version, previous_hash, timestamp |
| Merkle root public | Not encrypted, for ZK-proofs |
| Zeroization | Keys zeroized after use |

---

## Anti-Patterns (BLOCK)

### ❌ NEVER

- Reuse nonces (catastrophic GCM failure)
- Use ECB mode (no authentication)
- Skip signature verification (allows forgery)
- Store encryption key in plaintext (defeats purpose)
- Use predictable nonces (counter, timestamp alone)
- Sign only ciphertext (version/timestamp tamperable)
- Encrypt merkle root (breaks ZK-proofs)

### ✅ ALWAYS

- Generate random nonces for each encryption
- Use authenticated encryption (GCM, not CBC)
- Verify signature before decryption
- Derive all keys from BIP-39 mnemonic via StromaKeyring
- Include version in signed hash
- Keep merkle root unencrypted (public commitment)
- Zeroize sensitive key material after use (StromaKeyring implements Drop)
- Back up mnemonic separately from Signal store

---

## Implementation Dependencies

```toml
[dependencies]
ring = "0.17"               # AES-256-GCM, HKDF
bip39 = "2"                 # BIP-39 mnemonic parsing and seed derivation
ed25519-dalek = "2"         # State signing
zeroize = "1.7"             # Secure key erasure
```

---

## Related Constraints

- **persistence-model.bead**: Overall persistence architecture
- **security-constraints.bead**: Zeroization, identity masking
- **technology-stack.bead**: Approved cryptographic libraries

---

## Summary

Encryption makes the adversarial peer model safe:

1. **Encrypt** trust state with AES key derived from mnemonic (via StromaKeyring)
2. **Sign** the encrypted state using mnemonic-derived signing key
3. **Chunk** the encrypted state into 64KB pieces
4. **Distribute** 2 replicas per chunk to deterministic holders

Peers hold encrypted chunks. Even with all chunks, they cannot decrypt without the 24-word mnemonic (which derives all keys). Need ALL chunks + mnemonic to reconstruct.

**Key Hierarchy**: All cryptographic keys derive from the BIP-39 mnemonic via `StromaKeyring`. Operators must securely back up:
1. **24-word mnemonic** - root of all Freenet encryption/signing
2. **Signal store** - for protocol state (sessions, identity) - separate concern

**Rotation Support**: `key_epoch` field tracks which derivation generation created the state, enabling future key rotation without full membership re-bootstrapping.

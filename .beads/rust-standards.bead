# Bead: Rust Standards

**Status**: Operational Guidance  
**Created**: 2026-02-01  
**Context**: Rust Code Standards

---

## Core Dependencies

### Required Crates
- `ring`: For HMAC-SHA256 identity masking with ACI-derived key
- `zeroize`: For memory hygiene (purge raw buffers immediately after hashing)
- `winterfell`: For STARK proof generation and verification (not arkworks)
- `hkdf`: For key derivation from Signal ACI identity
- `libsignal-service-rs`: For Signal protocol integration
- `freenet-stdlib`: For Freenet Wasm contract development (ContractInterface trait)
- **See**: `.beads/technology-stack.bead` for complete dependency list

### Supply Chain Security
- **Mandatory**: Use `cargo-deny` for dependency auditing
- **Mandatory**: Use `cargo-crev` for cryptographic verification
- Run these checks in CI/CD pipeline

---

## Memory Safety & Hygiene

### Identity Masking Pattern
```rust
use ring::hmac;
use hkdf::Hkdf;
use sha2::Sha256;
use zeroize::Zeroize;
use libsignal_protocol::IdentityKeyPair;

/// Derive HMAC key from Signal ACI identity (replaces deprecated group pepper)
fn derive_identity_masking_key(aci_identity: &IdentityKeyPair) -> [u8; 32] {
    let hk = Hkdf::<Sha256>::new(
        Some(b"stroma-identity-masking-v1"),
        aci_identity.private_key().serialize().as_slice()
    );
    let mut key = [0u8; 32];
    hk.expand(b"hmac-sha256-key", &mut key).unwrap();
    key
}

pub fn mask_identity(signal_id: &str, aci_identity: &IdentityKeyPair) -> [u8; 32] {
    let key_bytes = derive_identity_masking_key(aci_identity);
    let key = hmac::Key::new(hmac::HMAC_SHA256, &key_bytes);
    let tag = hmac::sign(&key, signal_id.as_bytes());
    let mut result = [0u8; 32];
    result.copy_from_slice(tag.as_ref());
    // Note: key_bytes is stack-allocated and will be overwritten
    result
}
```

**See**: `.beads/security-constraints.bead` for complete pattern with zeroization

### Unsafe Code Policy
- **Audit all `unsafe` blocks**: Review manually before merging
- Prefer safe abstractions over unsafe code
- Document why unsafe is necessary if used

---

## Binary Requirements

### Static Linking
- Must produce statically linked MUSL binary
- Minimize binary size to reduce attack surface
- Monitor build size - significant increases indicate dependency bloat

### Sandboxing
- Production bot runs in restricted seccomp sandbox
- Only allow Signal and Freenet node traffic
- Block all other network access

---

## Module Organization

### Core Modules (as declared in `src/lib.rs`)
1. **`identity`**: HMAC identity masking with ACI-derived keys (`src/identity.rs`)
2. **`stark`**: ZK-STARK vouch verification circuits (`src/stark/`)
3. **`gatekeeper`**: Ejection, rate limiting, health monitoring, audit trail (`src/gatekeeper/`)
4. **`signal`**: Bot logic, commands, vetting, polls, proposals (`src/signal/`)
5. **`freenet`**: Contract state, embedded kernel, state stream (`src/freenet/`)
6. **`matchmaker`**: Cluster detection, DVR, strategic introductions (`src/matchmaker/`)
7. **`persistence`**: Chunk encryption, distribution, recovery, write-blocking (`src/persistence/`)
8. **`crypto`**: PSI-CA for federation discovery (`src/crypto/`)
9. **`federation`**: Social anchor computation (`src/federation/`)
10. **`serialization`**: CBOR via ciborium (`src/serialization/`)
11. **`cli`**: Operator commands (`src/cli/`)

### Error Handling
- Use `Result<T, E>` for all fallible operations
- Never silently swallow errors
- Log security-critical errors appropriately (without leaking sensitive data)

---

## Code Style

- Follow standard Rust formatting (`rustfmt`)
- Use `clippy` for linting
- Prefer explicit types over type inference in security-critical paths
- Document all public APIs, especially cryptographic functions

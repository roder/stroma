# Bead: Signal Integration Standards

**Status**: Immutable Architectural Constraint  
**Created**: 2026-02-01  
**Updated**: 2026-02-08  
**Context**: Signal Protocol Integration

---

## Implementation Status

| Component | File | Status |
|-----------|------|--------|
| `SignalClient` trait | `src/signal/traits.rs` | ‚úÖ Complete (9 methods: 8 async + `service_id()`) |
| `MockSignalClient` | `src/signal/mock.rs` | ‚úÖ Complete (all tests pass) |
| `LibsignalClient` | `src/signal/client.rs` | ‚ùå 100% stubbed (8/8 return `NotImplemented`) |
| `StromaStore` | `src/signal/stroma_store.rs` | üîÑ Planned (wraps encrypted SqliteStore, no-ops messages) |
| `link_secondary_device()` | `src/signal/linking.rs` | ‚ùå Returns `NotImplemented` |
| `register` CLI command | `src/cli/register.rs` | üîÑ Planned (new phone number registration) |
| `PollManager` | `src/signal/polls.rs` | ‚úÖ Complete (logic works against mock) |
| `StromaBot` | `src/signal/bot.rs` | ‚úÖ Complete (logic works against mock) |
| Presage poll support | `roder/presage` integration branch | ‚úÖ UAT-validated (create/vote/terminate E2E on live Signal) |

**Blocking UAT**: Yes ‚Äî Steps 1-2 in TODO.md must complete before UAT.

**Note**: `StromaProtocolStore` (`src/signal/store.rs`) has been superseded by the `StromaStore` wrapper architecture. The old file will be removed as part of the StromaStore migration convoy.

---

## Signal Account & Device Linking

### Bot Links as Secondary Device

Stroma links to an **existing Signal account** as a secondary device. The operator is responsible for having a Signal account ‚Äî how they obtain it is their concern.

**Device Model:**
- Signal supports 1 primary device + up to 5 linked devices
- Stroma bot links as a **secondary device** via QR code
- Linked devices have **full messaging and group management capabilities**

**Linking Flow:**
1. Operator starts `stroma link-device --device-name "Stroma Bot"`
2. Bot displays QR code in terminal
3. Operator scans QR code with Signal app
4. Bot receives ACI/PNI identity from primary device
5. Bot saves identity to encrypted `StromaStore`

**Registration**: Stroma also supports `Manager::register()` via the `stroma register` CLI command for operators who want to register a dedicated phone number for the bot.

**Current Status**: Both `link_secondary_device()` and `register` are not yet wired. See TODO.md Step 2.

---

## Bot Behavior Principles

### Bot Roles
- **Protocol Gatekeeper**: Enforces vouch threshold (per GroupConfig) for admission
- **Blind Matchmaker (Internal)**: Two distinct functions:
  - *Admission Vetting*: Select cross-cluster assessor to evaluate invitees (`signal/matchmaker.rs`)
  - *Mesh Optimization*: Suggest strategic introductions between existing members (`matchmaker/strategic_intro.rs`)
- **Diplomat (External)**: Federation proposals with other Stroma groups
- **Health Monitor**: Continuous monitoring of trust standing

### Gatekeeper Pattern
- Presence in Signal group is **binary** and strictly tied to Freenet state
- **Core Invariant**: Every member must maintain ‚â•2 vouches from DIFFERENT CLUSTERS
- **Invitees**: OUTSIDE Signal group (1 vouch, being vetted)
- **Bridges**: IN Signal group (2 vouches, minimum)
- **Validators**: IN Signal group (3+ vouches)
- Monitor Freenet state stream continuously (real-time, not polling)

---

## Immediate Ejection Protocol

**Two Independent Triggers:**

```
Effective_Vouches = |All_Vouchers| - |Voucher_Flaggers|
Regular_Flags = |All_Flaggers| - |Voucher_Flaggers|
Standing = Effective_Vouches - Regular_Flags

# Trigger 1: Standing negative
IF Standing < 0: EJECT

# Trigger 2: Effective vouch count below minimum
IF Effective_Vouches < MIN_VOUCH_THRESHOLD: EJECT
```

**Vouch Invalidation**: If a voucher flags a member, that vouch is invalidated.

**No Grace Periods**: Immediate removal when trigger condition met.

---

## Privacy-First UX

### Command Interface
All vetting/vouching occurs in **1-on-1 PMs** with bot (prevents metadata leakage).

**Critical constraint**: The bot belongs to exactly ONE Signal group (per `bot-deployment-model.bead`). It NEVER creates 3-person chats, secondary groups, or any other Signal group. During admission vetting, the bot PMs the assessor with the invitee's contact info. The assessor contacts the invitee independently of the bot.

**Member Commands:**
- `/invite @username [context]` - Invite someone (counts as first vouch)
- `/vouch @username` - Vouch for invitee or existing member
- `/flag @username [reason]` - Flag member for trust violation
- `/reject-intro @username` - Decline an assessment request (assessor only; bot selects another cross-cluster member)
- `/propose <subcommand> [args]` - Propose group decision
- `/status` - View personal trust standing
- `/mesh` - View network overview

### Voting: Native Signal Polls

**Why Polls (Not Reactions):**
- ‚úÖ Structured voting - Clear options, easy tallying
- ‚úÖ Multiple choice - Beyond binary approve/reject
- ‚úÖ Native UX - Signal's built-in poll interface
- ‚ùå Reactions - Binary only, harder to tally

**Poll Structure:**
- Options: Binary (Approve/Reject) or multiple choice
- Visibility: Group members can see who voted for what
- Timeout: Configurable per proposal (48h, 72h, etc.)
- Threshold: From GroupConfig.config_change_threshold (% of votes to pass)
- Quorum: From GroupConfig.min_quorum (% of members who must vote)

---

## Data Handling

### Store Architecture (Security Critical)

**Implementation**: `src/signal/stroma_store.rs` (COMPLETE - dual-database architecture)

- ‚ùå **NEVER use bare `SqliteStore`** - it stores message history (server seizure risk)
- ‚úÖ **ALWAYS use `StromaStore`** - dual-database wrapper, no-ops message/sticker persistence

**Dual-Database Architecture:**

1. **signal.db** - presage SqliteStore (protocol state, groups, contacts, profiles)
2. **stroma.db** - Stroma-specific data (poll state, vote aggregates, ephemeral data)

Both databases are encrypted with the **SAME 24-word BIP-39 passphrase** (SQLCipher AES-256).

**What's Persisted:**
- signal.db: protocol state, group config, profile keys (survives restart)
- stroma.db: poll state, HMAC'd voter dedup maps, vote aggregates (ephemeral)

**What's Never Persisted:**
- Message content, conversation history, sticker packs

**Current Status**: `StromaStore` wrapper is COMPLETE. Old `StromaProtocolStore` removed.

```rust
// src/signal/stroma_store.rs (implemented structure)
pub struct StromaStore {
    signal_store: SqliteStore,  // presage's encrypted protocol store
    stroma_db: SqlitePool,      // separate encrypted SQLite for poll state
}

impl StromaStore {
    pub async fn open(path: &Path, passphrase: String) -> Result<Self> {
        // Open both databases with SAME passphrase
        let signal_store = SqliteStore::open_with_passphrase(
            path.join("signal.db"),
            Some(&passphrase),
            OnNewIdentity::Trust,
        ).await?;
        
        let stroma_db = SqlitePoolOptions::new()
            .connect_with(
                SqliteConnectOptions::new()
                    .filename(path.join("stroma.db"))
                    .create_if_missing(true)
                    .pragma("key", passphrase)  // Same passphrase
            )
            .await?;
        
        sqlx::migrate!("./src/signal/stroma_store_migrations").run(&stroma_db).await?;
        Ok(Self { signal_store, stroma_db })
    }
    
    // KV methods for poll state
    pub async fn store_data(&self, key: &str, value: &[u8]) -> Result<(), StoreError>;
    pub async fn retrieve_data(&self, key: &str) -> Result<Option<Vec<u8>>, StoreError>;
    pub async fn delete_data(&self, key: &str) -> Result<(), StoreError>;
}

impl presage::Store for StromaStore {
    // Delegates: protocol state, groups, contacts, profiles -> signal_store
    // No-ops: save_message -> Ok(()), message -> Ok(None), stickers -> no-op
}
```

### Never Store Signal IDs
- **Critical**: Bot must never store Signal IDs in cleartext
- **HMAC-based hashing**: Use keyed hashing with ACI-derived key (`src/identity.rs`)
- **Ephemeral Memory**: Raw Signal IDs wiped immediately after hashing via `zeroize`
- **Ephemeral State**: Vetting session data deleted after admission
- **Transient Mapping**: `MemberResolver` provides ServiceId ‚Üî MemberHash lookup (never persisted)

---

## Vouch Permissions

### Who Can Vouch
- **ANY Member** in the Stroma Signal group can vouch
- Includes both Bridges (2 vouches) and Validators (3+ vouches)
- Invitees (people being vetted) CANNOT vouch

### Vouch Validity
- Vouches must be from members in DIFFERENT CLUSTERS (cross-cluster mandatory) to enter a Group
- Bot verifies via Freenet that voucher is current Member
- First vouch = invitation itself (no separate token)

---

## SignalClient Trait (Actual Implementation)

**File**: `src/signal/traits.rs`

```rust
#[async_trait]
pub trait SignalClient: Send + Sync + Clone {
    async fn send_message(&self, recipient: &ServiceId, text: &str) -> SignalResult<()>;
    async fn send_group_message(&self, group: &GroupId, text: &str) -> SignalResult<()>;
    async fn create_group(&self, name: &str) -> SignalResult<GroupId>;
    async fn add_group_member(&self, group: &GroupId, member: &ServiceId) -> SignalResult<()>;
    async fn remove_group_member(&self, group: &GroupId, member: &ServiceId) -> SignalResult<()>;
    
    // Poll support (multi-option, up to 10 options)
    async fn create_poll(&self, group: &GroupId, question: &str, options: Vec<String>, allow_multiple: bool) -> SignalResult<u64>;
    async fn terminate_poll(&self, group: &GroupId, poll_timestamp: u64) -> SignalResult<()>;
    
    // Group settings support (for /propose signal)
    async fn get_group_info(&self, group: &GroupId) -> SignalResult<GroupInfo>;
    async fn set_group_name(&self, group: &GroupId, name: &str) -> SignalResult<()>;
    async fn set_group_description(&self, group: &GroupId, description: &str) -> SignalResult<()>;
    async fn set_disappearing_messages(&self, group: &GroupId, seconds: u32) -> SignalResult<()>;
    async fn set_announcements_only(&self, group: &GroupId, enabled: bool) -> SignalResult<()>;
    
    async fn receive_messages(&self) -> SignalResult<Vec<Message>>;
    fn service_id(&self) -> &ServiceId;
}
```

**Implementations**:
- `MockSignalClient` ‚Äî In-memory mock for all tests (complete, passing)
- `LibsignalClient` ‚Äî Production client using presage (100% stubbed)

---

## Roadmap

### Step 1: Rig Presage ‚Äî PARTIALLY COMPLETE

**Repo**: `presage/` (fork at `/Users/matt/gt/presage`, branch `integration/protocol-v8-polls`)

**Completed**:
- [x] Poll create/vote/terminate works (Protocol v8) -- UAT-validated against live Signal
- [x] GroupContextV2 fix applied (messages arrive in group context, not as DMs)
- [x] CLI consistency fixes (poll-author-uuid, -o append, master-key in docs)

**Remaining** (separate convoy: GV2 Group CRUD):
- [ ] Validate group creation/management works (presage has no create_group API yet)
- [ ] Validate secondary device linking works via StromaStore

**Blocking**: Step 2 depends on validated presage APIs + StromaStore.

### Step 2: Real Signal Integration ‚Äî IN PROGRESS

**Deliverables**:

- [ ] Create `StromaStore` wrapper around encrypted `SqliteStore`:
  - Wraps `presage-store-sqlite::SqliteStore` with SQLCipher encryption
  - No-ops message/sticker persistence (server seizure protection)
  - Persists protocol state, groups, profiles (restart recovery)

- [ ] Implement passphrase management:
  - 24-word BIP-39 recovery phrase generated at link/register time
  - Delivery via file/stdin/env (container-native)

- [ ] Wire `LibsignalClient` to presage `Manager` APIs:
  - `send_message()` ‚Üí `manager.send_message()`
  - `send_group_message()` ‚Üí `manager.send_message_to_group()`
  - `create_group()` ‚Üí `manager.create_group()` (blocked on GV2 convoy)
  - `add_group_member()` / `remove_group_member()` ‚Üí (blocked on GV2 convoy)
  - `create_poll()` ‚Üí `manager.send_poll()` (API exists in presage fork)
  - `terminate_poll()` ‚Üí `manager.terminate_poll()` (API exists in presage fork)
  - `receive_messages()` ‚Üí `manager.receive_messages()`

- [ ] Add `stroma register` CLI command (new phone number registration)

- [ ] Implement vote aggregate + HMAC'd voter dedup persistence in PollManager

- [ ] Implement `link_secondary_device()` in `src/signal/linking.rs`

- [ ] Enable 16 CLI integration tests in `tests/cli_integration.rs`

**Test Strategy**:

| Level | Tool | Purpose |
|-------|------|---------|
| Unit | `MockSignalClient` | All logic tests (existing, passing) |
| Integration | `MockSignalClient` + recording proxy | Verify message flow |
| E2E | Real Signal account (manual) | Device linking, group creation, polls |

### Step 5: UAT ‚Äî BLOCKED BY Steps 1-4

**Manual Test Script** (when ready):

1. **Link bot**: `stroma link-device --name "test-bot"` ‚Äî scan QR code, bot links as secondary device
2. **Create group**: Send `/create-group "UAT Test Group"` as PM to bot
3. **Invite member**: Send `/invite @alice "friend from work"`
4. **Vouch**: Alice sends `/vouch @bob` ‚Äî admission flow completes
5. **Propose**: Any member sends `/propose config --key min_vouches --value 3 --timeout 24h`
6. **Verify persistence**: Restart bot ‚Äî trust state recovers from Freenet

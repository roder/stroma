# Bead: Non-Hierarchical Governance

**Status**: Immutable Architectural Constraint  
**Created**: 2026-01-28  
**Context**: Architecture Decision 2.3

---

## Principle: Bot as Execute-Only Agent

**Core Rule**: Bot is Signal admin (technical requirement), but exercises **ZERO decision-making power**. All actions require Freenet contract approval (consensus).

### Authority Model

```
Signal Admin Powers = Technical Capability (bot has)
Freenet Contract = Decision Authority (group has)
Operator = Service Runner (NO special privileges)
```

### Bot's Role

**Technical Admin:**
- Bot MUST be Signal group admin (required to add/remove members)
- Bot has capability to change group settings
- Bot can execute all Signal group operations

**Execute-Only:**
- Bot MUST NOT make any decisions independently
- Bot MUST verify Freenet contract before EVERY action
- Bot MUST wait for consensus approval before execution
- Bot monitors Freenet state stream for approved actions

```rust
pub struct GroupGovernance {
    // Bot's Signal role
    signal_admin: bool,  // Always true (technical requirement)
    
    // But decisions require consensus
    config_change_threshold: f32,  // e.g., 0.70 (70%) - % of votes to pass
    min_quorum: f32,               // e.g., 0.50 (50%) - % of members who must vote
    
    // Bot never decides, only executes
    auto_enforcement: bool,  // true - bot enforces contract
    operator_privileges: Vec<Privilege>,  // EMPTY - no special powers
}
```

### Decision Flow

```
Member proposes action
        ‚Üì
Freenet contract records proposal
        ‚Üì
Group votes (via Signal Polls)
        ‚Üì
Timeout expires
        ‚Üì
Bot checks: threshold met? (aggregated counts only)
        ‚Üì YES
Freenet contract records approval
        ‚Üì
Bot executes action (uses Signal admin power)
        ‚Üì
Signal group updated
        ‚Üì
Bot announces completion
```

**Bot NEVER skips Freenet verification.**

### Operator Constraints

**Operator Role**: Service Runner ONLY

**Can Do:**
- ‚úÖ Start/stop bot service (systemd)
- ‚úÖ Monitor logs for errors
- ‚úÖ Restart on crashes
- ‚úÖ Update bot software
- ‚úÖ View service health metrics

**Cannot Do:**
- ‚ùå Manually add/remove members
- ‚ùå Change group settings
- ‚ùå Override consensus decisions
- ‚ùå Bypass trust thresholds
- ‚ùå Execute group actions directly
- ‚ùå See cleartext Signal IDs (only hashes)
- ‚ùå Modify GroupConfig without group vote

### Audit Trail

```rust
pub struct OperatorAction {
    action_type: ActionType,  // ServiceStart, ServiceRestart, ServiceStop
    timestamp: Timestamp,
    operator_hash: Hash,      // Operator is just another member
}

pub enum ActionType {
    ServiceStart,
    ServiceRestart,
    ServiceStop,
    // NO "ManualExecution" - not allowed
    // NO "ConfigOverride" - not allowed
}
```

**Any member can query:**
```
Member: "/audit operator"

Bot: "Operator actions (last 30 days):
      - 2026-01-15 10:23 UTC: Service started
      - 2026-01-20 03:15 UTC: Service restarted (crash recovery)
      - 2026-01-22 14:00 UTC: Service stopped (maintenance)
      - 2026-01-22 14:30 UTC: Service started"
```

### Signal Group Settings Management

**All settings manageable via consensus:**

```rust
pub enum SignalGroupSetting {
    Name,
    Description,
    Avatar,
    DisappearingMessages,
    LinkPermissions,
    AddMembersPermission,
    EditGroupPermission,
    // ... any setting Signal exposes
}
```

**Workflow:**
```
Member: "/propose config disappearing_messages 24h"

Bot: "üìã Proposal #8
     Enable disappearing messages: 24h
     
     Timeout: 48h
     Threshold: 70%"

[Bot creates Signal Poll with options: "Approve", "Reject"]
[Group votes via Signal Poll]

Bot (after timeout, if approved):
     "‚úÖ Proposal #8 approved (18 Approve, 4 Reject = 82%)
     
     Enabling disappearing messages: 24h"

[Bot uses Signal admin power to change setting]

Bot: "‚úÖ Disappearing messages enabled: 24h"
```

### Code Constraints

**Block These Patterns:**
```rust
// ‚ùå NEVER bypass Freenet verification
async fn add_member(signal: &SignalClient, member: Hash) {
    signal.add_to_group(member).await?;  // WRONG - no verification
}

// ‚ùå NEVER give operator special commands
match command {
    "/operator-add" => { /* FORBIDDEN */ }
    "/operator-override" => { /* FORBIDDEN */ }
}

// ‚ùå NEVER make autonomous decisions
if member.standing < 0 {
    signal.remove_member(member).await?;  // WRONG - must verify contract first
}
```

**Enforce These Patterns:**
```rust
// ‚úÖ ALWAYS verify Freenet contract first
async fn enforce_membership(
    signal: &SignalClient,
    freenet: &FreenetClient,
) {
    let contract_state = freenet.get_current_state().await?;
    
    for action in contract_state.approved_actions {
        match action {
            ApprovedAction::AddMember(hash) => {
                signal.add_to_group(hash).await?;
            },
            ApprovedAction::RemoveMember(hash) => {
                signal.remove_from_group(hash).await?;
            },
            _ => {}
        }
    }
}

// ‚úÖ ALWAYS check contract before execution
async fn execute_proposal(proposal: &Proposal, freenet: &FreenetClient) -> Result<()> {
    // Verify proposal was approved in contract
    if !freenet.is_proposal_approved(proposal.id).await? {
        return Err("Proposal not approved in Freenet contract");
    }
    
    // Now execute
    execute_action(&proposal.action).await?;
}
```

### Gastown Agent Instructions

**When implementing bot logic:**
1. Bot is Signal admin (set admin flag in group creation)
2. Bot NEVER executes without Freenet contract approval
3. All membership changes flow through Freenet state stream
4. Operator has NO privileged commands (only systemd service management)
5. All group decisions use `/propose` system

**When implementing operator CLI:**
1. NO commands for manual member management
2. NO commands for config overrides
3. ONLY commands for service health and monitoring
4. Audit trail for operator actions (service management only)

**If agent suggests operator override:**
- **REJECT** - violates non-hierarchical principle
- **REDIRECT** - use `/propose` for group decisions
- **BLOCK** - do not implement operator privileges

### Capability Governance

**Capability activation requires two gates:**
1. **Trust gate** (for agent capabilities): Bot must be vouched before capability proposal
2. **Governance gate** (for all capabilities): Group votes on capability activation

**Workflow:**
```
1. Member: /propose capability @mutualaibot
2. Bot: PMs @mutualaibot with /capabilities
3. Bot: Creates Signal Poll: "Enable capability: MutualAI?"
4. Group votes
5. If approved: Namespace registered, commands available
```

**Commands from capabilities:**
- **Binary commands** (e.g., `/phyllotaxis enable`): Create Approve/Reject poll
- **Direct commands** (e.g., `/mutualai record-impact`): Bot verifies standing, executes immediately
- **Proposal commands** (e.g., `/mutualai verify-impact`): Create custom poll

**Config changes:**
```
/propose mutualai poi_contract <freenet-hash>
```

Bot verifies:
1. Capability is active
2. Config key is registered in manifest
3. Value matches type/validation rules

After group vote approval: Bot updates capability config in `GroupConfig.capabilities`.

See `.beads/extensible-contracts.bead` for complete capability governance model.

### Testing Requirements

**Must test:**
- [ ] Bot cannot add member without Freenet approval
- [ ] Bot cannot remove member without Freenet approval
- [ ] Bot cannot change settings without Freenet approval
- [ ] Bot cannot activate capability without group vote
- [ ] Bot verifies capability config changes via /propose
- [ ] Operator commands limited to service management
- [ ] Audit trail records operator actions correctly

# Federation Roadmap (IMMUTABLE - North Star)

**Status**: Pinned - Cannot be modified without explicit unpinning ceremony
**Last Updated**: 2026-01-26
**Purpose**: Guide all design decisions toward ultimate goal

## Ultimate Objective

**Connect as many people as possible anonymously via trust through federated groups.**

This is the **north star** for all architectural decisions. Even though federation is NOT implemented in the MVP (Phase 0-3), it is the **ultimate objective** that guides EVERY design choice.

## Critical Principle: Federation-Ready Design

### Why This Matters
If we design for single-group only and retrofit federation later:
- Costly refactoring required
- Privacy model may not scale
- Contract schema may need breaking changes
- Identity hashing may need redesign

If we design for federation from the start (but implement single-group first):
- Clean architecture that scales naturally
- Validated privacy model at scale
- No breaking changes needed later
- Smooth transition to Phase 4

### Design for Federation, Build for MVP
**Strategy**: All design decisions optimize for federation, but MVP implements only single-group functionality.

**This means:**
- Contract schema includes federation hooks (present but unused)
- Identity hashing is re-computable (group-scoped HMAC)
- Module structure includes `federation/` (disabled via feature flag)
- Node types support cross-mesh scenarios
- Social Anchor hashing computed locally (not broadcast)

## MVP Scope (Phase 0-3): Single Group

### What's Implemented in MVP
✅ **Bootstrap (Phase 1)**
- 3-member seed group
- Initial triangle vouching
- Freenet state initialization

✅ **Core Trust Mechanics (Phase 1)**
- Invitation (first vouch)
- Vetting with second Member
- Admission (2 vouches + ZK-proof)
- Ejection (two independent triggers)
- Flagging system

✅ **Internal Mesh Optimization (Phase 2)**
- Blind Matchmaker (graph analysis)
- Internal cluster detection
- Strategic cross-cluster introductions
- MST optimization

✅ **Configuration Management (Phase 2)**
- GroupConfig in Freenet contract
- Signal Poll voting (config_change_threshold)
- Automatic config updates

✅ **Bot Commands**
- `/invite`, `/vouch`, `/flag`
- `/status`, `/mesh`, `/mesh strength`, `/mesh config`
- `/propose config|stroma|federate`, `/audit operator`

### What's NOT Implemented in MVP
❌ **Federation Discovery**
- No Shadow Beacon broadcast
- No bot-to-bot discovery
- No PSI-CA handshake protocol

❌ **Federation Decision**
- No federation proposals to other groups
- No Signal Poll for federation approval
- No contract signing with other groups

❌ **Cross-Mesh Vouching**
- No vouching across federated groups
- No shadow vouches
- No expedited vetting for federated members

❌ **Federated State**
- No shared Merkle Trees
- No cross-group state synchronization
- No global trust context

❌ **Bot Identity Rotation (Shadow Handover)**
- No Signal phone number rotation capability
- No cryptographic succession protocol
- No automated handover between old/new bot instances
- Note: Operator must manually handle Signal bans in MVP

### Federation Infrastructure (Present but Disabled)
Even though federation is NOT implemented, the infrastructure is PRESENT:

```rust
// Contract schema includes federation hooks (UNUSED in MVP)
pub struct TrustNetworkState {
    // ... current state ...
    
    // Federation hooks (PRESENT but EMPTY in MVP)
    federation_contracts: Vec<ContractHash>,  // Empty: []
    validator_anchors: BloomFilter,           // Computed but not broadcast
}
```

```rust
// Module structure includes federation/ (DISABLED in MVP)
// src/federation/mod.rs
#[cfg(feature = "federation")] // Feature flag DISABLED in MVP
pub mod shadow_beacon;
#[cfg(feature = "federation")]
pub mod psi_ca;
#[cfg(feature = "federation")]
pub mod diplomat;
```

## Phase 4+ (Future): Federation Implementation

### Objective
Enable multiple independent Stroma groups to discover each other and federate without admin coordination or revealing social graph structure.

### Design Principles

#### 1. Emergent Discovery (No Pre-Coordination)
**Problem**: Traditional federation requires admins to exchange keys/URLs.

**Solution**: Bots discover each other organically via "social frequency."

**Method**: Social Anchor Hashing
- Hash of top-N validators (percentile-based, not fixed)
- Groups with shared validators have similar social anchors
- Discovery URI derived from social anchor
- No pre-shared keys needed

#### 2. Blind Rendezvous (Privacy-Preserving)
**Problem**: Calculating overlap reveals member identities.

**Solution**: Private Set Intersection Cardinality (PSI-CA)

**Method**:
1. Each bot generates Bloom filter from member hashes
2. Bots publish encrypted Bloom filters at discovery URIs
3. Bots scan URIs to find potential matches
4. PSI-CA handshake reveals ONLY overlap count (not identities)
5. Both groups evaluate: `overlap / union > threshold?`

**Privacy Guarantee**: No member identities revealed, only counts.

#### 3. BidirectionalMin (Asymmetric Thresholds)
**Problem**: Small group federating with large group risks absorption.

**Solution**: Each group sets their own threshold independently.

**Example**:
- Group-A (20 members): Requires 30% overlap (6 members)
- Group-B (100 members): Requires 10% overlap (10 members)
- Overlap: 8 members
- Result: Group-A satisfied (8 > 6), but Group-B NOT satisfied (8 < 10)
- Federation REJECTED (both must approve)

**Benefit**: Small groups can protect themselves from large group dominance.

#### 4. Human Control (No Automatic Federation)
**Problem**: Bot could federate without group consent.

**Solution**: Signal Poll for every federation proposal.

**Process**:
1. Bot detects overlap meets threshold
2. Bot proposes federation to group (Signal Poll)
3. Members vote: ✅ Approve / ❌ Reject / ⏸️ Abstain
4. Requires `config_change_threshold` approval (e.g., 70%)
5. Both groups must approve for federation to proceed

**Human Override**: Members can reject federation even if technically viable.

### Federation Discovery Protocol (Phase 4)

#### Step 1: Social Anchor Calculation
```rust
fn calculate_social_anchor(
    members: &[Member],
    validator_percentile: u32,
) -> SocialAnchor {
    // Sort members by vouch count
    let mut sorted = members.clone();
    sorted.sort_by_key(|m| m.vouch_count);
    
    // Take top percentile (e.g., top 20%)
    let threshold_idx = (members.len() * validator_percentile / 100).max(3);
    let top_validators = &sorted[threshold_idx..];
    
    // Hash top validators to create social anchor
    let mut hasher = Sha256::new();
    for validator in top_validators {
        hasher.update(validator.hash.as_bytes());
    }
    
    SocialAnchor::from(hasher.finalize())
}
```

#### Step 2: Discovery URI Generation
```rust
fn generate_discovery_uris(anchor: &SocialAnchor) -> Vec<Uri> {
    // Generate multiple URIs using different percentiles
    // Increases chance of discovery
    vec![
        format!("freenet://stroma/discovery/{}:10", anchor),  // Top 10%
        format!("freenet://stroma/discovery/{}:20", anchor),  // Top 20%
        format!("freenet://stroma/discovery/{}:30", anchor),  // Top 30%
        format!("freenet://stroma/discovery/{}:50", anchor),  // Top 50%
    ]
}
```

#### Step 3: Bloom Filter Broadcast
```rust
fn broadcast_presence(
    anchor: &SocialAnchor,
    members: &[Hash],
) -> Result<(), Error> {
    // Create Bloom filter from member hashes
    let bloom = BloomFilter::new(members);
    
    // Encrypt for anonymous publication
    let encrypted = encrypt_bloom_filter(&bloom)?;
    
    // Publish at discovery URIs
    for uri in generate_discovery_uris(anchor) {
        freenet.publish(&uri, &encrypted).await?;
    }
    
    Ok(())
}
```

#### Step 4: PSI-CA Handshake
```rust
async fn calculate_overlap(
    our_bloom: &BloomFilter,
    their_encrypted_bloom: &[u8],
) -> Result<OverlapInfo, Error> {
    // PSI-CA (Private Set Intersection Cardinality)
    // Reveals ONLY the count of overlap, not identities
    
    // Commutative encryption for double-blinding
    let overlap_count = psi_ca::calculate_intersection_count(
        our_bloom,
        their_encrypted_bloom,
    ).await?;
    
    // We know counts, but NOT which members overlap
    Ok(OverlapInfo {
        overlap_count,
        our_size: our_bloom.len(),
        their_size_estimate: estimate_bloom_size(their_encrypted_bloom),
    })
}
```

#### Step 5: Threshold Evaluation (BidirectionalMin)
```rust
fn evaluate_federation_threshold(
    overlap: &OverlapInfo,
    our_threshold: f32,
) -> bool {
    // Calculate intersection density from OUR perspective
    let union_size = overlap.our_size + overlap.their_size_estimate - overlap.overlap_count;
    let density = overlap.overlap_count as f32 / union_size as f32;
    
    // Check if it meets OUR threshold
    density >= our_threshold
}
```

#### Step 6: Human Vote (Signal Poll)
```rust
async fn propose_federation(
    other_group: GroupInfo,
    overlap: OverlapInfo,
) -> Result<bool, Error> {
    // Create Signal Poll for voting
    let poll = signal.create_poll(Poll {
        question: format!("Federate with {}?", other_group.name),
        details: format!(
            "Overlap: {} members ({}% of our group)\n\
             Their size: ~{} members\n\
             Voting closes in 48 hours",
            overlap.overlap_count,
            overlap.overlap_count * 100 / overlap.our_size,
            overlap.their_size_estimate,
        ),
        options: vec![
            "✅ Approve Federation",
            "❌ Reject Federation",
            "⏸️ Abstain",
        ],
    }).await?;
    
    // Wait for poll to close
    let result = poll.wait_for_result().await?;
    
    // Check if approval exceeds threshold
    let approval_rate = result.approve_count as f32 / result.total_votes as f32;
    Ok(approval_rate >= config.config_change_threshold)
}
```

#### Step 7: Federation Contract Signing
```rust
async fn establish_federation(
    our_group: &GroupContract,
    their_group: &GroupContract,
) -> Result<FederationContract, Error> {
    // Both groups have voted to approve
    // Sign federation contract on Freenet
    
    let federation = FederationContract {
        group_a: our_group.hash(),
        group_b: their_group.hash(),
        established: Timestamp::now(),
        shared_validators: calculate_bridge_members().await?,
    };
    
    // Both bots sign contract
    let signed = federation.sign(our_group.key())?;
    freenet.publish_contract(signed).await?;
    
    Ok(federation)
}
```

### Cross-Mesh Vouching (Phase 4)

#### Concept: Shadow Vouch
After federation is established, members from Group-B can vouch for invitees to Group-A.

**Example Flow:**
1. Alice (Group-A) invites Dan to Group-A
2. Dan is ALREADY a member of Group-B (federated)
3. Bot detects Dan's presence in Group-B via shared contract
4. Bot requests vouch from Group-A validator (first vouch from Alice)
5. Bob (Group-A validator) vouches for Dan (second vouch)
6. Dan admitted to Group-A (now in BOTH groups)

**Why This Works:**
- Dan's trust identity precedes him across meshes
- Groups act as mutual buffers for each other
- Expedited vetting (already trusted in sister group)
- No duplicate vetting for federated members

#### Federated Merkle Trees
```rust
pub struct FederatedTrustNetworkState {
    // Local state (our group)
    local_members: MerkleTree<MemberHash>,
    local_vouches: Vec<VouchProof>,
    
    // Federated state (sister groups)
    federation_contracts: Vec<ContractHash>,
    federated_members: HashMap<GroupHash, MerkleTree<MemberHash>>,
    
    // Bridge members (present in multiple groups)
    bridge_members: HashSet<MemberHash>,
}
```

### Bot Identity Rotation: Shadow Handover Protocol (Phase 4+)

#### Concept: Cryptographic Succession
**Purpose**: Enable bot to rotate Signal phone number while maintaining cryptographic identity and trust continuity

**Use Cases**:
- Signal ban recovery (fast failover to new number)
- Operator anonymity enhancement (periodic rotation)
- Multi-bot federation (different numbers for different groups)
- Operational security (limit exposure of any single number)

#### Shadow Handover Protocol (Phase 4+)

**Process**:
```
1. Bot-Old (Current Signal Number) prepares to expire
   - Generates new keypair for Bot-New
   - Creates Succession Document signed with Bot-Old's key
   
2. Succession Document structure:
   - old_bot_pubkey: Current bot's public key
   - new_bot_pubkey: New bot's public key
   - timestamp: When succession occurs
   - signature: Signed by old_bot_privkey
   - reason: "rotation" | "ban_recovery" | "security_upgrade"
   
3. Bot-Old deploys Succession Document to Freenet contract
   - Contract verifies signature matches old_bot_pubkey
   - Contract updates: authorized_bot_keys.add(new_bot_pubkey)
   - Contract maintains: Trust context remains unchanged
   
4. Bot-New (New Signal Number) arises
   - Authenticates with new Signal phone number
   - Presents Succession Document to Freenet contract
   - Proves possession of new_bot_privkey (signs challenge)
   
5. Freenet Contract validates succession
   - Verifies Succession Document signature (old bot signed it)
   - Verifies Bot-New possesses new_bot_privkey
   - Updates authorized bot identity
   - Trust graph remains unchanged (members' vouches persist)
   
6. Bot-New announces to Signal group
   "I am the same Stroma node. My Signal identity has changed,
    but my cryptographic signature is valid. Trust continuity
    maintained via Freenet contract."
```

#### Operator CLI Command (Phase 4+)
```bash
# Operator manually registers new Signal account first
# Then initiates rotation
stroma rotate \
  --config /etc/stroma/config.toml \
  --new-phone "+0987654321" \
  --reason "Signal ban recovery"

# Bot orchestrates Shadow Handover automatically
```

#### Security Properties
- ✅ Cryptographic proof of succession (not just operator assertion)
- ✅ Trust context preserved (members' vouches unchanged)
- ✅ Freenet contract authorizes transition (not centralized)
- ✅ Signal identity is ephemeral, cryptographic identity persists
- ✅ Aligns with fluid identity philosophy

#### Implementation Considerations (Phase 4+)
- [ ] Add bot keypair to Freenet contract schema
- [ ] Add succession document structure
- [ ] Add signature verification in contract verify()
- [ ] Add `stroma rotate` CLI command
- [ ] Add graceful Bot-Old shutdown (after handover complete)
- [ ] Add Bot-New startup with succession verification
- [ ] Add Signal group membership transfer logic
- [ ] Test: Prevent replay attacks on succession documents
- [ ] Test: Handle concurrent Bot-Old and Bot-New (race conditions)

**Not in MVP**: Operator must manually handle Signal bans by re-registering with backup phone number.

### Scaling Beyond Federation

#### Multi-Hop Federation (Phase 5+)
- Group-A federates with Group-B
- Group-B federates with Group-C
- Group-A does NOT automatically federate with Group-C
- But Group-A can discover Group-C via Group-B's social anchor

#### Recursive Proofs (Phase 5+)
- Batch ZK-proofs for efficiency
- Constant-time verification regardless of network size
- Enables mass scale (2000+ members per federated network)

#### Sybil Detection (Phase 5+)
- Multi-bot consensus for suspicious patterns
- Anomaly detection (sudden spike in flags)
- Cross-group reputation correlation
- Automated ejection recommendations

## Design Validation (Phase 3)

### Phase 3 Objectives
Even though federation is NOT implemented in MVP, Phase 3 validates the design:

1. **Social Anchor Hashing** (Computed Locally)
   - Calculate top-N validators
   - Generate discovery URIs
   - Store for Phase 4 (don't broadcast)

2. **PSI-CA** (Tested with Mock Data)
   - Generate Bloom filters
   - Test commutative encryption
   - Calculate intersection density (simulate two groups)

3. **Contract Schema** (Validated)
   - Confirm federation hooks work
   - Verify identity hashes are re-computable
   - Test BidirectionalMin logic

**Deliverable**: Proof that federation design is viable before Phase 4 implementation.

## Migration Path: MVP → Federation

### Step 1: Enable Feature Flag
```rust
// Cargo.toml
[features]
default = []
federation = []  # Enable with: cargo build --features federation
```

### Step 2: Activate Federation Modules
```rust
// src/federation/mod.rs
#[cfg(feature = "federation")]
pub mod shadow_beacon;
// ... other modules ...
```

### Step 3: Broadcast Social Anchor
```rust
// Previously computed locally, now broadcast
#[cfg(feature = "federation")]
async fn start_discovery(anchor: &SocialAnchor) {
    broadcast_presence(anchor, &members).await?;
}
```

### Step 4: Monitor Discovery URIs
```rust
#[cfg(feature = "federation")]
async fn monitor_discovery_uris(uris: &[Uri]) {
    for uri in uris {
        if let Some(other_group) = freenet.fetch(uri).await? {
            evaluate_federation(other_group).await?;
        }
    }
}
```

**Key Point**: No breaking changes needed. Federation is activated by enabling feature flag and deploying new bot version.

## Success Criteria for Federation (Phase 4)

- [ ] Bots discover each other without admin coordination
- [ ] PSI-CA reveals only overlap count (no identities)
- [ ] BidirectionalMin protects small groups from absorption
- [ ] Signal Poll voting for federation approval
- [ ] Both groups must approve before federation
- [ ] Cross-mesh vouching works after federation
- [ ] No social graph structure exposed during discovery
- [ ] Federation dissolves gracefully if bridge members leave

## Summary: Federation as North Star

**Core Philosophy**: Every design decision in Phase 0-3 MUST optimize for future federation.

**Key Invariants:**
1. Identity hashing is re-computable (group-scoped HMAC)
2. Contract schema supports federation hooks
3. Module structure includes federation/ (disabled)
4. Discovery is emergent (no pre-shared keys)
5. Privacy is preserved (PSI-CA reveals only counts)
6. Human control (no automatic federation)
7. Asymmetric thresholds (BidirectionalMin)

**Ultimate Goal**: Build the world's most private, scalable trust network where trust emerges from authentic human relationships, not centralized authority.

Federation is not just a feature—it's the **reason Stroma exists**.

# Bead: Architectural Decisions (Open Questions Resolution)

**Status**: Immutable Architectural Constraint  
**Created**: 2026-01-31  
**Context**: Resolution of open architectural questions beyond Spike Week

---

## Resolved Decisions

### 1. Flag History on Re-Entry

**Decision**: **Flags persist**

When a member is ejected and re-enters with 2 new cross-cluster vouches, their previous flags carry over.

**Rationale**: 
- Accountability: Community memory of past concerns
- Prevents gaming: Can't clear history by briefly leaving
- New vouchers know they're vouching for someone with history

**Implementation**:
```rust
// On re-entry, member starts with:
// - 2 new effective vouches (from new vouchers)
// - Previous flags still in place
// - Standing = 2 - previous_flags

// Example: Alice was ejected with 3 flags
// Alice re-enters with 2 new vouches
// Standing = 2 - 3 = -1 â†’ STILL EJECTED
// Alice needs MORE than 2 vouches to overcome history
```

**UX Implication**: Bot should inform inviter of invitee's flag history before vetting.

---

### 2. Multiple Flags

**Decision**: **One flag per person** (use Set, not Multiset)

Each member can flag another member at most once.

**Rationale**:
- Prevents spam/brigading
- Simpler mental model for users
- One concern = one flag (express it once)

**Implementation**:
```rust
pub struct TrustNetworkState {
    // HashSet ensures one flag per flagger
    pub flags: HashMap<Hash, HashSet<Hash>>,  // flagged â†’ {flaggers}
}

// Duplicate flag attempts are no-ops
fn flag(&mut self, flagger: Hash, target: Hash) -> Result<(), Error> {
    let flaggers = self.flags.entry(target).or_default();
    if flaggers.contains(&flagger) {
        return Err(Error::AlreadyFlagged);  // Idempotent, not error to user
    }
    flaggers.insert(flagger);
    Ok(())
}
```

---

### 3. Vouch Revocation

**Decision**: **Revoke = Flag** (no neutral state)

There is no "neutral" state. To withdraw a vouch, you must flag.

**Rationale**:
- Simplicity: Binary trust (vouch or flag)
- Accountability: Revoking support is an active statement
- Aligns with "fluid identity" â€” trust is current position, not accumulator

**Trust States**:
```
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚ Unknown â”‚  (never interacted)
         â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
              â”‚ /vouch
              â–¼
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚ Vouched â”‚  (trusts)
         â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
              â”‚ /flag (voucher-flagger path)
              â–¼
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚ Flagged â”‚  (distrusts, vouch invalidated)
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**No path back**: Once flagged, cannot re-vouch same person (would require implementation discussion for future "unflag" capability â€” not in MVP).

---

### 4. Signal API Failure During Ejection

**Decision**: **Retry with logarithmic backoff until achieved**

If Freenet confirms ejection but Signal API fails, bot MUST retry until Signal reflects truth.

**Rationale**:
- Freenet is source of truth
- Signal must eventually reflect Freenet state
- Logarithmic backoff prevents API abuse while ensuring completion

**Implementation**:
```rust
async fn sync_ejection_to_signal(member_hash: Hash) -> Result<()> {
    let mut attempt = 0;
    loop {
        match signal.remove_member(member_hash).await {
            Ok(_) => return Ok(()),
            Err(e) if e.is_transient() => {
                attempt += 1;
                // Logarithmic backoff: 1s, 2s, 4s, 8s... capped at 1 hour
                let delay = Duration::from_secs(2u64.pow(attempt).min(3600));
                tracing::warn!(
                    "Signal ejection failed (attempt {}), retrying in {:?}: {}",
                    attempt, delay, e
                );
                tokio::time::sleep(delay).await;
            }
            Err(e) => return Err(e),  // Non-transient error
        }
    }
}
```

**Invariant**: `signal_state.members âŠ† freenet_state.members` (Signal may lag, but never lead)

---

### 5. Rate Limiting / Action Cooldowns

**Decision**: **Progressive cooldown** (starts low, increases with repeated actions)

Minimum time between user's actions with the stroma bot on same target increases with action count.

**Rationale**:
- Allows initial corrections (vouch, then realize mistake, flag)
- Identifies bad actors (rapid cycling = suspicious)
- Provides repair path while preventing abuse

**Implementation**:
```rust
pub struct ActionCooldown {
    target: Hash,
    action_count: u32,
}

impl ActionCooldown {
    /// Returns cooldown duration based on action history
    fn cooldown_duration(&self) -> Duration {
        match self.action_count {
            0 => Duration::ZERO,           // First action: immediate
            1 => Duration::from_secs(60),  // Second: 1 minute
            2 => Duration::from_secs(300), // Third: 5 minutes
            3 => Duration::from_secs(3600), // Fourth: 1 hour
            _ => Duration::from_secs(86400), // Fifth+: 24 hours
        }
    }
}

// Track in bot memory (not Freenet - ephemeral)
// Resets on bot restart (acceptable for MVP)
```

**UX**: Bot responds "Please wait X before taking another action on this member."

---

### 6. Contract Schema Migration

**Decision**: **Versioned state with serde(default)**

Use CBOR with `#[serde(default)]` for backward-compatible schema evolution.

**Rationale**:
- CBOR handles optional fields gracefully
- No migration contracts needed for additive changes
- Breaking changes require explicit migration (rare)

**Implementation**:
```rust
#[derive(Serialize, Deserialize)]
pub struct TrustNetworkState {
    pub members: BTreeSet<Hash>,
    pub vouches: HashMap<Hash, HashSet<Hash>>,
    pub flags: HashMap<Hash, HashSet<Hash>>,
    pub tombstones: BTreeSet<Hash>,
    pub version: u64,
    
    // Added in v2 â€” old states deserialize with empty vec
    #[serde(default)]
    pub federation_contracts: Vec<ContractHash>,
    
    // Added in v3 â€” old states deserialize with None
    #[serde(default)]
    pub config: Option<GroupConfig>,
}
```

**Version Field**: Track schema version for debugging, not migration logic.

---

### 7. Privacy Settings for Mesh Queries

**Decision**: **No privacy controls** for mesh visibility

- Members CANNOT hide their vouch count from others
- Members CANNOT opt out of Blind Matchmaker suggestion
- Members CANNOT directly query another member's vouch count
- Members CAN query mesh for aggregate results only (ie: network health metric)

**Rationale**:
- Transparency is core to trust network
- Hiding information enables gaming
- Mesh health depends on visibility
- "Privacy from external threats, transparency within community"
- Members must maintain privacy individually, but have visibility of the group's members in aggregate metrics. 
- Inviting members should be warned about an invitee's flags on re-entry (See #1)

**Note**: External observers (non-members) cannot see anything. This applies only to fellow members.

---

### 8. Bootstrap Cross-Cluster Exemption

**Decision**: **Grandfathered** (existing members don't need retroactive cross-cluster vouches)

When multiple clusters form, existing members are NOT required to get new vouches.

**Rationale**:
- Founders established trust before clusters existed
- Retroactive requirements would be disruptive
- New members must meet cross-cluster requirement

**Trigger for "clusters exist"**: See Decision #12 (Cluster Formation Trigger) below.

---

### 9. Logging Verbosity & Security

**Decision**: **Logs must not enable trust map reconstruction or state recovery**

| Level | Audience | Content |
|-------|----------|---------|
| ERROR | Operators | Failures requiring attention |
| WARN | Operators | Recoverable issues |
| INFO | Operators | Operations completed (sanitized) |
| DEBUG | Contributors | Internal flow (no sensitive data) |
| TRACE | Contributors | Detailed flow (dev only, ephemeral) |

**Four-Layer Log Security**:

| Layer | What's Protected | Logging Rule |
|-------|------------------|--------------|
| **PII** | Signal IDs, phone numbers, names | âŒ NEVER log |
| **Trust Map** | Relational data (who vouched for whom) | âŒ NEVER log |
| **Persistence** | Chunk holder locations, attestations | âŒ NEVER log (even if computable) |
| **Federation** | Federated group identities, overlap data | âŒ NEVER log |

**Why This Matters**:
If a bot is compromised, its logs must NOT provide:
1. Member identities (PII protection)
2. Trust relationships (trust map protection)
3. Path to reconstruct state (persistence protection)
4. Which groups are federated or their relationships (federation protection)

**Logging Rules**:

```rust
// âŒ FORBIDDEN - reveals trust map
tracing::info!("Vouch recorded: {} vouched for {}", voucher_hash, target_hash);
tracing::debug!("Flag from {} to {}", flagger_hash, target_hash);
tracing::info!("Ejecting {} (standing: {})", member_hash, standing);

// âŒ FORBIDDEN - reveals persistence locations
tracing::info!("Chunk stored at peer {}", holder_hash);
tracing::debug!("Attestation received from {}", holder_hash);
tracing::info!("Recovering from holders: {:?}", holder_list);

// âŒ FORBIDDEN - reveals PII
tracing::info!("Processing message from {}", signal_id);
tracing::debug!("Adding member: {}", phone_number);

// âŒ FORBIDDEN - reveals federation relationships
tracing::info!("Federated with group {}", other_group_hash);
tracing::debug!("PSI-CA overlap with {}: {} members", group_id, overlap_count);
tracing::info!("Cross-mesh vouch from {}", federated_group_name);
tracing::debug!("Discovery: found group {} at URI {}", group_hash, uri);

// âœ… ALLOWED - operation types only
tracing::info!("Vouch recorded");
tracing::info!("Flag recorded");
tracing::info!("Member admitted");
tracing::info!("Member ejected");
tracing::info!("Chunk distribution completed (all chunks 3/3)");
tracing::info!("State recovery initiated");
tracing::info!("Federation proposal created");
tracing::info!("Federation established");

// âœ… ALLOWED - aggregate counts (no identifiers)
tracing::info!("Network state: {} members, {} pending invites", count, pending);
tracing::debug!("Cluster detection: {} clusters found", cluster_count);
tracing::info!("Federated groups: {}", federation_count);  // count only, no IDs

// âœ… ALLOWED - error context without identifiers
tracing::error!("Signal API failed: {}", error_type);
tracing::warn!("Chunk distribution partial: 7/8 chunks fully replicated");
```

**Implementation**:
- Use structured logging (tracing crate)
- Create sanitized log macros that strip identifiers
- Log review in CI/CD (grep for hash patterns)
- Production logs should pass "compromised bot" test

**Compromised Bot Test**:
> If an adversary has full access to bot logs, can they reconstruct:
> 1. Who is in the group? **NO** (no PII, no hashes logged)
> 2. Who vouched for whom? **NO** (no relational data logged)
> 3. Where are persistence fragments? **NO** (no holder locations logged)
> 4. Which groups are federated? **NO** (no group IDs, names, or URIs logged)
>
> If any answer is YES, logging is too verbose.

---

### 10. Tombstone Intent and Re-Entry

**Decision**: **"Ejected" state, not permanent tombstone** (Option C)

No permanent bans. "Ejected + flags persist" is sufficient accountability.

**Data Model**:
```rust
pub struct TrustNetworkState {
    pub members: BTreeSet<Hash>,        // Active members
    pub ejected: BTreeSet<Hash>,        // Currently ejected (can return)
    pub vouches: HashMap<Hash, HashSet<Hash>>,  // All vouches (including for ejected)
    pub flags: HashMap<Hash, HashSet<Hash>>,    // All flags (persist across ejection)
}
```

**Behavior**:
- Ejected members keep their hash, vouch history, and flag history
- Re-entry moves them from `ejected` back to `members`
- CRDT correctness: `ejected` set operations are commutative
- No "permanent ban" concept â€” aligns with forgiveness philosophy

**Re-entry Requirements**:
- Secure 2+ new cross-cluster vouches
- Standing must be positive: `new_vouches - persisted_flags > 0`
- More flags = more vouches needed to re-enter

**Rationale**: Stroma's philosophy emphasizes "accountability AND forgiveness." Permanent bans collapse toward punishment; ejection with repair path maintains the duality.

---

### 11. Multi-Bot Consensus Intent

**Decision**: **Multi-bot = federation coordination, NOT redundancy**

| Scope | Bots | Trust Model |
|-------|------|-------------|
| **MVP (single group)** | 1 bot | Trusted (operator accountability) |
| **Federation (Phase 4+)** | N bots (one per group) | Coordinate via Freenet |

**Explicitly OUT OF SCOPE**: Multi-bot verification redundancy within a single group.

**Rationale**:
- Single-group redundancy adds complexity without proportional benefit
- Operator accountability is sufficient for MVP
- Federation naturally introduces multiple bots (each group has one)
- Cross-group operations require bot-to-bot coordination

**Documentation**: "Multi-bot" in Stroma always means federation, never redundancy. Perfer "Federation" over "Multi-bot".

---

### 12. Cluster Formation Trigger

**Decision**: **Automatic detection when `clusters >= 2`** (no member count threshold)

**Trigger**: Bridge Removal algorithm detects 2+ distinct clusters

```rust
fn should_require_cross_cluster(state: &TrustNetworkState) -> bool {
    let clusters = bridge_removal_detect_clusters(&state.vouches);
    clusters.len() >= 2
}
```

**Why no member count threshold**:
- 10 tight friends = 1 cluster â†’ no cross-cluster needed
- 6 from 2 peer groups = 2 clusters â†’ cross-cluster required
- Algorithm detects actual social structure, not arbitrary numbers

**Announcement**: When triggered, bot posts to group:
> "ðŸ“Š Network update: Your group now has distinct sub-communities! Cross-cluster vouching is now required for new members. This means new members need vouches from people in different peer circles. Existing members are grandfathered."

**Grandfathering**: Existing members at time of trigger are NOT required to get new vouches.

**Timing**: Run cluster detection on every membership change (fast: <1ms per Q3 Spike)

---

### 8. Self-Query of Own Vouchers/Flags

**Decision**: **Users MAY see their own vouchers and flaggers by name**

A user can query `/status` to see who vouched for them and who flagged them, displayed with Signal display names (not hashes).

**Rationale**:
- **No new information leaked**: User already participated in vouching conversations â€” they know who vouched for them
- **Actionable UX**: Knowing "Alice vouched for you" lets user assess risk if Alice leaves
- **No third-party queries**: User CANNOT see who vouched for *other* members
- **Consistent with threat model**: Threat is adversarial third-party queries, not self-knowledge

**What IS allowed**:
```
/status â†’ Shows YOUR vouchers: "Alice, Bob"
/status â†’ Shows YOUR flaggers: "Carol"
```

**What is FORBIDDEN**:
```
/status @Charlie â†’ âŒ REJECTED (cannot query others)
/whois vouched @Charlie â†’ âŒ REJECTED (cannot query others' relationships)
```

**Security Constraint Clarification**:

The existing constraint "NEVER reveal who vouched for whom in cleartext" applies to:
- âŒ Third-party queries (who vouched for X?)
- âŒ Group announcements ("Alice vouched for Bob")
- âŒ Logs or persistent storage of vouch relationships

It does NOT prohibit:
- âœ… User seeing their own vouchers (self-query)
- âœ… User seeing their own flaggers (self-query)

**Implementation**:
```rust
fn handle_status_command(requester: &MemberId, target: Option<&MemberId>) -> Result<StatusResponse> {
    match target {
        Some(other) if other != requester => {
            // âŒ FORBIDDEN: Cannot query other members' relationships
            Err(Error::PrivacyViolation("Cannot view other members' vouchers"))
        }
        _ => {
            // âœ… ALLOWED: Self-query
            let vouchers = get_vouchers_for(requester);
            let flaggers = get_flaggers_for(requester);
            Ok(StatusResponse { vouchers, flaggers, ... })
        }
    }
}
```

**UX Note**: Display names come from Signal (ephemeral, not persisted by bot). Bot resolves hashâ†’name at display time using Signal API, never stores the mapping.

---


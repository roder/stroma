# Discovery Protocols (IMMUTABLE)

**Status**: Pinned - Cannot be modified without explicit unpinning ceremony
**Last Updated**: 2026-01-31
**Applies To**: Persistence peer discovery, federation discovery, Agent-Freenet

---

## WHY: Two Distinct Protocols

### The Critical Distinction

Stroma has TWO discovery protocols for TWO different purposes:

| Protocol | Purpose | Trust Model |
|----------|---------|-------------|
| **Persistence Discovery** | Find bots to hold your fragments | ADVERSARIAL (zero trust) |
| **Federation Discovery** | Find groups to federate with | ESTABLISHED TRUST (shared validators) |

**THESE MUST NOT BE CONFLATED.** They have fundamentally different trust models.

---

## Protocol #1: Persistence Peer Discovery

### Purpose

Find other Stroma bots to participate in the Reciprocal Persistence Network.

### Trust Model: ADVERSARIAL

**ALL persistence peers are assumed to be adversaries.**

| Assumption | Implication |
|------------|-------------|
| Peer may be malicious | Encrypt chunks |
| Peer may refuse to return chunks | 3 copies per chunk (any 1 of 3 works) |
| Peer may collude | Chunks encrypted; need ALL chunks + ACI key |
| Peer may be fake (Sybil) | Defense mechanisms (Q8 spike) |
| Peer may delete chunks | Verification mechanisms (Q9, Q13 spike) |
| Peer knows who holds whose chunks | Deterministic assignment (OK - chunks still encrypted) |

### When It Happens

**Before federation.** Most bots will use persistence discovery BEFORE they federate with anyone. Federation is optional and gradual; persistence is immediate and required.

### Discovery Mechanism

**Minimal Freenet Registry + Deterministic Assignment** (Q7 COMPLETE, Q11 PENDING):

### Registry Contract Address Derivation

**Deterministic derivation from well-known seed** — no coordination needed:

```rust
/// Registry contract addresses are deterministically derived
/// Any bot can compute the same address without coordination
const STROMA_REGISTRY_SEED: &[u8] = b"stroma-persistence-registry-v1";

fn registry_contract_address() -> ContractHash {
    // Derive deterministically from seed
    ContractHash::from_bytes(&sha256(STROMA_REGISTRY_SEED))
}

// For sharded registry (256 shards)
fn shard_contract_address(shard_id: u8) -> ContractHash {
    let seed = format!("stroma-persistence-registry-v1-shard-{:02x}", shard_id);
    ContractHash::from_bytes(&sha256(seed.as_bytes()))
}
```

**Why this works**:
- No coordination needed — any bot computes the same address
- Deterministic — reproducible across implementations
- Versioned — can migrate to v2 if schema changes
- Sharding-ready — shard addresses derived from same pattern

**Q7 Anti-Sybil Registration**:
- PoW-based registration (difficulty 18) prevents spam
- Registration requires proof-of-work before adding to registry
- Integration point for Q8 (Fake Bot Defense) mechanisms

### Registry Data Model (Q7 Validated)

**Q7 Performance Characteristics**:
- Registration latency: <10ms per bot
- Discovery latency: <1ms (single contract read)
- Network size query: O(1) (count of registry entries)
- Concurrent registration: Safe (10 bots in <10ms total, no duplicates)

```rust
/// Minimal registry - O(N) storage only
pub struct PersistenceRegistry {
    bots: BTreeSet<RegistryEntry>,    // List of registered bots
    tombstones: BTreeSet<ContractHash>, // Remove-wins semantics
    epoch: u64,                        // Set by shard creator, incremented on significant changes
}

pub struct RegistryEntry {
    contract_hash: ContractHash,      // Bot's trust contract address
    size_bucket: SizeBucket,          // Small/Medium/Large (optional, for fairness)
    num_chunks: u32,                  // How many chunks this bot has
    registered_at: Timestamp,
}

/// Registry delta (commutative, set-based - Q1 validated)
pub struct RegistryDelta {
    bots_added: Vec<RegistryEntry>,
    bots_removed: Vec<ContractHash>,  // Adds to tombstones
}

/// Chunk holders are COMPUTED via rendezvous hashing per-chunk, not stored
fn compute_chunk_holders(
    owner_contract: &ContractHash,
    chunk_index: u32,
    bots: &[ContractHash],
    epoch: u64,
) -> [ContractHash; 2] {  // 2 remote replicas per chunk
    // See persistence-model.bead for full algorithm
}
```

**Key insight**: No per-chunk relationships stored. Scales O(N), not O(N × chunks × replicas).

**Epoch management**: First bot to create a shard sets initial epoch. Subsequent bots read existing epoch. Epoch increments when bot count changes >10%.

**Scalability** (Q7 validation):
- Single registry: <10K bots unsharded
- Sharded registry: 100K+ bots (256 shards by contract hash prefix)
- Discovery latency: <1ms (Q7 measured)
- Registration overhead: ~100 bytes per bot (Q7 measured)
- Each shard is ~4K bots at 1M scale
- Holder computation queries all shards (parallelizable)
- See `persistence-model.bead` for sharding details

**Bot availability**: No heartbeat mechanism. Bots are available/unavailable (binary state). Unavailability detected during chunk operations. Registry cleaning triggered by failed operations — no distinction between crash and clean unregistration.

### Selection Criteria (Deterministic Assignment)

| Criterion | Rationale |
|-----------|-----------|
| **Deterministic** | Rendezvous hashing per-chunk (not owner-chosen, verifiable by anyone) |
| **Size-agnostic** | Fairness tracked separately (2x storage ratio) |
| **Registered** | In discovery registry (bot list) |
| **Not self** | Can't hold your own chunks |

### What's Shared

| Shared | NOT Shared |
|--------|------------|
| Bot exists in network | Trust map contents |
| Size bucket (range) | Exact member count |
| Public key | Private key |
| Contract hash | Vouch relationships |

---

## Protocol #2: Federation Discovery (Shadow Beacon)

### Purpose

Find other Stroma groups to federate with for organic trust network growth.

### Trust Model: ESTABLISHED TRUST

**Federation only with groups that share trusted validators.**

| Requirement | Rationale |
|-------------|-----------|
| Shared validators | Social proof of trustworthiness |
| PSI-CA verification | Calculate overlap without revealing graph |
| Human vote (Signal Poll) | Members decide, not bots |
| BidirectionalMin threshold | Both groups must approve |

### When It Happens

**After trust is established.** Federation is a later-phase feature (Phase 4+). Groups must:
1. Have shared validators (social overlap)
2. Meet intersection density threshold
3. Pass human vote in both groups

### Discovery Mechanism

**Shadow Beacon + PSI-CA**:

```rust
// Fixed rendezvous buckets (Fibonacci sequence for natural scaling)
// Groups publish at ALL buckets they can fill
// Sequence extends to Signal's 1000-member group limit
// Fibonacci: better coverage at small sizes (where most groups are)
const RENDEZVOUS_BUCKETS: &[usize] = &[
    3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987
];

// Social Anchor Hashing (FIXED BUCKETS for cross-size discovery)
fn compute_social_anchors(validators: &[Hash]) -> Vec<(Hash, usize)> {
    // Validators must be sorted deterministically (by hash value)
    let mut sorted_validators = validators.to_vec();
    sorted_validators.sort();
    
    // Generate anchors for each bucket we have enough validators to fill
    RENDEZVOUS_BUCKETS.iter()
        .filter(|&&bucket_size| sorted_validators.len() >= bucket_size)
        .map(|&bucket_size| {
            // Take exactly bucket_size validators (deterministic, sorted)
            let top_validators: Vec<_> = sorted_validators.iter().take(bucket_size).collect();
            (hash(&serialize(&top_validators)), bucket_size)
        })
        .collect()
}

// Blind Rendezvous at fixed bucket URIs
fn discovery_uris(anchors: &[(Hash, usize)]) -> Vec<Uri> {
    anchors.iter()
        .map(|(anchor, _)| freenet_uri_from_hash(anchor))
        .collect()
}

// Private Set Intersection Cardinality
fn calculate_overlap(our_validators: &[Hash], their_bloom: &BloomFilter) -> usize {
    // Count how many of our validators appear in their bloom filter
    our_validators.iter().filter(|v| their_bloom.contains(v)).count()
}
```

**Why fixed buckets work:**
- Groups of ANY size publish at the SAME bucket sizes (Fibonacci sequence)
- If two groups share the same top-3 validators, they hash to the SAME URI-3
- Larger groups publish at more buckets → more discovery chances
- Smaller groups still discoverable at lower buckets

### Federation Threshold Model

**Two thresholds must be satisfied:**

| Threshold | Purpose | Example |
|-----------|---------|---------|
| **Minimum distinct validators** | Absolute floor — ensures meaningful social overlap | ≥ 3 shared validators |
| **Intersection density** | Relative measure — prevents tiny overlap in large groups | ≥ 10% of smaller group |

```rust
pub struct FederationThreshold {
    /// Minimum absolute count of shared validators (e.g., 3)
    pub min_shared_validators: usize,
    
    /// Minimum intersection density as fraction (e.g., 0.10 for 10%)
    pub min_intersection_density: f32,
}

fn meets_federation_threshold(
    overlap_count: usize,
    our_validator_count: usize,
    their_validator_count: usize,
    threshold: &FederationThreshold,
) -> bool {
    // BOTH conditions must be met
    let min_validators_met = overlap_count >= threshold.min_shared_validators;
    
    // Intersection density = overlap / smaller group's validators
    let smaller_count = our_validator_count.min(their_validator_count);
    let density = overlap_count as f32 / smaller_count as f32;
    let density_met = density >= threshold.min_intersection_density;
    
    min_validators_met && density_met
}
```

**Rationale:**
- **min_shared_validators** prevents federation based on 1-2 coincidental overlaps
- **min_intersection_density** scales with group size (10% of 50 = 5, 10% of 200 = 20)
- **BidirectionalMin**: Each group evaluates against its OWN threshold

### Fixed Bucket Rendezvous (Blind Discovery)

Groups publish at **Fibonacci-sequence buckets** so different-sized groups can discover each other:

```
Fibonacci Buckets (up to Signal's 1000-member limit):
[3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987]

Group-A (40 validators, sorted by hash):
  - URI-3:  hash(top 3 validators)   ← Broad discovery
  - URI-5:  hash(top 5 validators)
  - URI-8:  hash(top 8 validators)
  - URI-13: hash(top 13 validators)
  - URI-21: hash(top 21 validators)
  - URI-34: hash(top 34 validators)
  - (skips URI-55+ — only 40 validators)

Group-B (12 validators, sorted by hash):
  - URI-3:  hash(top 3 validators)   ← SAME BUCKET as Group-A!
  - URI-5:  hash(top 5 validators)   ← SAME BUCKET as Group-A!
  - URI-8:  hash(top 8 validators)   ← SAME BUCKET as Group-A!
  - (skips URI-13+ — only 12 validators)

Group-C (1000 members, ~800 validators, sorted by hash):
  - URI-3:  hash(top 3 validators)    ← Can discover A and B
  - URI-5:  hash(top 5 validators)    ← Can discover A and B
  - ...all buckets through URI-610...
  - URI-610: hash(top 610 validators) ← High-trust discovery
  - (skips URI-987 — only 800 validators)

If Group-A and Group-B share the SAME top-3 validators (sorted),
they hash to the SAME URI-3 → DISCOVERY!

Note: Signal groups max at 1000 members, so 987 is the theoretical maximum
bucket (though most groups will have fewer validators than total members).
```

**Why Fibonacci buckets:**
- **Natural scaling** - Growth pattern (3→5→8→13...) reflects organic group expansion
- **Better granularity at small sizes** - More buckets in 3-89 range where most groups live
- **Efficient spacing** - ~1.6x growth (golden ratio) balances discovery surface vs. overhead
- **Deterministic and algorithmic** - Sequence extends to Signal's 1000-member limit
- **Fixed counts** (not percentiles) → groups of different sizes produce MATCHING hashes
- **Discovery requires overlap** - Must share actual validators, not just similar percentages

**Bucket selection by group size:**
- Tiny (3-5 validators) → publish at [3, 5]
- Small (12 validators) → publish at [3, 5, 8]
- Medium (40 validators) → publish at [3, 5, 8, 13, 21, 34]
- Large (150 validators) → publish at [3, 5, 8, 13, 21, 34, 55, 89, 144]
- Massive (800 validators) → publish at all 13 buckets up to [610]

**Discovery characteristics:**
- Every group publishes at URI-3 (universal discovery point)
- Larger groups have more buckets → more discovery opportunities
- Higher buckets require deeper overlap → stronger federation signal
- Small groups still discoverable by massive groups at low buckets
- **Background process** - Discovery runs periodically, not real-time

---

### DEFERRED DECISION: Top-N vs Any-N Discovery

**Current design:** Content-addressed URIs using **top-N** validators (sorted by hash)
- Discovers groups with matching top-3, top-5, etc.
- O(1) lookup per bucket
- Scales to millions of groups

**Alternative:** Bloom Filter at fixed bucket URIs using **any-N** validators
- Discovers groups sharing ANY 3 validators (not just top-3)
- O(N) scan (background process, acceptable)
- More discovery opportunities, but adds complexity
- False positives filtered by PSI-CA confirmation

**The tension:**
- Top-N may miss federation-worthy connections where overlap is in "peripheral" validators
- Any-N finds more candidates but requires scanning all groups at each bucket
- Both use PSI-CA for final confirmation (privacy preserved)

**Decision deferred to future spike (Q10):**
- Simulate realistic social graphs
- Compare discovery rates: top-N vs any-N
- Measure: does any-N find significantly more valid federation candidates?
- If <10% more: stay with top-N (simpler)
- If >50% more: implement Bloom funnel
- Middle ground: optional background scan

**For Phase 4 (MVP Federation):** Implement top-N (proven scalable), revisit if needed.

---

### Federation Decision Flow

```
1. Bot sorts validators by hash (deterministic ordering)
2. Bot broadcasts encrypted summary at FIXED BUCKET URIs (3, 5, 10, 20, 50)
3. Other bots scan bucket URIs they can fill
4. If URI hashes match at any bucket → potential federation candidate found
5. PSI-CA handshake calculates EXACT overlap count (no graph exposure)
6. Threshold evaluation (BOTH must pass):
   a. overlap_count >= min_shared_validators (e.g., 3)
   b. overlap_count / min(our_validators, their_validators) >= density (e.g., 10%)
7. BidirectionalMin: Each group evaluates against its OWN configured threshold
8. If BOTH thresholds satisfied:
   a. Bot proposes federation to its group (Signal Poll)
   b. Other bot proposes federation to its group
9. Both groups must vote YES (consensus threshold, e.g., 70%)
10. Federation established (mutual recognition)
```

**Important: Bucket match ≠ Federation approval**
- Matching at URI-3 means you MIGHT share 3 validators
- PSI-CA confirms the ACTUAL overlap count
- Threshold evaluation determines if overlap is sufficient

### What's Shared

| Shared | NOT Shared |
|--------|------------|
| Overlap count (PSI-CA) | Individual validator identities |
| Group size (range) | Exact member count |
| Federation proposal | Trust map structure |
| Vote result | Individual votes |

---

## Comparison Table

| Aspect | Persistence Discovery | Federation Discovery |
|--------|----------------------|---------------------|
| **Purpose** | Chunk replication | Trust network growth |
| **Trust Model** | Zero trust (adversarial) | Established trust (shared validators) |
| **Timing** | Immediate (required) | Later (optional, Phase 4+) |
| **Mechanism** | Minimal registry + rendezvous hash | Shadow Beacon + PSI-CA |
| **Selection** | Deterministic (verifiable, not owner-chosen) | Social overlap (trust) |
| **Human Involvement** | None (automatic) | Required (Signal Poll) |
| **Privacy** | Fragments encrypted (holder IDs computable) | PSI-CA (no graph exposure) |

### Key Distinction Diagram

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                                                                              │
│   PERSISTENCE PEERS                    FEDERATED PEERS                       │
│   ─────────────────                    ────────────────                       │
│                                                                              │
│   • Adversarial by default             • Trusted (shared validators)         │
│   • Deterministic selection (hashing)  • Overlap-threshold matched           │
│   • Hold encrypted chunks only         • Can verify via ZK-proofs            │
│   • Cannot read each other's state     • Can request membership proofs       │
│   • REQUIRED for writes                • OPTIONAL (enhances trust network)   │
│   • Holder IDs computable by anyone    • Deliberate relationships            │
│   • Discovery: Minimal registry + hash • Discovery: Shadow Beacon + PSI-CA   │
│                                                                              │
│   Federations are TRANSITORY - they come and go as shared validators leave. │
│   Persistence Peers are the STABLE FOUNDATION for state durability.         │
│                                                                              │
│   Federation ALSO provides persistence (mutual subscription),                │
│   but this is BONUS persistence, NOT the primary mechanism.                  │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## Anti-Patterns (BLOCK)

### ❌ NEVER Conflate the Protocols

```rust
// ❌ WRONG: Using federation partners for persistence
fn select_chunk_holders() -> Vec<Bot> {
    // Don't prefer federated bots!
    self.federated_partners.clone()  // WRONG
}

// ✅ CORRECT: Deterministic assignment via rendezvous hashing per-chunk
fn compute_chunk_holders(&self, chunk_index: u32) -> [ContractHash; 2] {
    let bots: Vec<_> = self.persistence_registry
        .bot_list()
        .iter()
        .filter(|b| *b != &self.contract_hash)
        .cloned()
        .collect();
    
    rendezvous_hash(&self.contract_hash, &bots, self.registry.epoch)
}
```

### ❌ NEVER Trust Persistence Peers (Even Though IDs Are Computable)

```rust
// ❌ WRONG: Trusting persistence peers
fn verify_chunk(holder: &Bot, chunk: &Chunk) -> bool {
    // Don't skip verification because "we know them"!
    if self.knows_holder(holder) {
        return true;  // WRONG - they could have deleted it
    }
    challenge_response_verify(holder, chunk)
}

// ✅ CORRECT: Always verify
fn verify_chunk(holder: &Bot, chunk: &Chunk) -> bool {
    challenge_response_verify(holder, chunk)  // Always verify
}
```

### ❌ NEVER Use Persistence for Federation Discovery

```rust
// ❌ WRONG: Discovering federation candidates from persistence registry
fn find_federation_candidates() -> Vec<Group> {
    self.persistence_registry.all_bots()  // WRONG - no trust relationship
}

// ❌ WRONG: Only checking intersection density (ignores minimum validators)
fn find_federation_candidates() -> Vec<Group> {
    shadow_beacon.discover()
        .filter(|g| g.density >= MIN_INTERSECTION_DENSITY)  // WRONG - need both checks
        .collect()
}

// ✅ CORRECT: Use Shadow Beacon + BOTH threshold checks
fn find_federation_candidates() -> Vec<Group> {
    shadow_beacon.discover()
        .filter(|g| {
            // BOTH conditions required
            g.overlap_count >= self.config.min_shared_validators
                && g.intersection_density() >= self.config.min_intersection_density
        })
        .collect()
}
```

---

## Constraints Checklist

### Persistence Discovery

| Constraint | Verification |
|------------|--------------|
| Adversarial model | All peers treated as potential attackers |
| Deterministic selection | Rendezvous hashing (not chosen by owner, verifiable) |
| Minimal registry | O(N) bot list only, no per-chunk relationships |
| No trust assumptions | Verify everything (even though holder IDs computable) |

### Federation Discovery

| Constraint | Verification |
|------------|--------------|
| Minimum shared validators | overlap_count >= min_shared_validators (e.g., 3) |
| Intersection density | overlap / min(our_validators, their_validators) >= threshold (e.g., 10%) |
| BOTH thresholds required | Must satisfy minimum count AND density |
| Fixed bucket URIs | Publish at buckets [3, 5, 10, 20, 50] validators |
| Deterministic ordering | Validators sorted by hash before bucket selection |
| Human vote required | Signal Poll, not automatic |
| BidirectionalMin | Each group evaluates against its OWN threshold |
| Privacy preserving | PSI-CA, no graph exposure |

---

## Implementation Notes

### Persistence Registry (Q7 COMPLETE, Q11 PENDING)

**Q7 Findings**:
- Registry-based discovery: ✅ VIABLE
- Discovery latency: <1ms (requirement: <5s) ✅
- Registration overhead: ~100 bytes (requirement: <1KB) ✅
- Concurrent safety: No duplicates or lost entries ✅
- Scales to 10K bots unsharded, 100K+ with sharding ✅
- PoW-based registration (difficulty 18) for anti-Sybil ✅

```rust
// Q7 validated - registry approach RECOMMENDED for Phase 0
pub trait PersistenceDiscovery {
    /// Register this bot in the persistence network
    async fn register(&self) -> Result<()>;
    
    /// Get current bot list and epoch
    async fn get_registry(&self) -> (Vec<RegistryEntry>, u64);
    
    /// Compute chunk holders (deterministic, not stored)
    fn compute_chunk_holders(&self, chunk_index: u32, registry: &Registry) -> [ContractHash; 2];
    
    /// Unregister from persistence network (clean shutdown)
    async fn unregister(&self) -> Result<()>;
    
    /// Get network size for replication requirements
    async fn network_size(&self) -> usize;
}
```

**Note**: No heartbeat method. Replication Health measured at write time via distribution acknowledgments.

**Q7 Stale Bot Handling**:
- Bots unregister on clean shutdown
- Crashed/stale bots detected during chunk distribution
- Failed distribution marks bot as potentially stale
- Lazy exclusion from holder computation (no active cleanup needed)

### Federation Discovery (Shadow Beacon)

```rust
// Fibonacci rendezvous buckets (up to Signal's 1000-member limit)
// Deterministic, algorithmic sequence - no magic numbers
const RENDEZVOUS_BUCKETS: &[usize] = &[
    3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987
];

// Phase 4+ feature
pub trait FederationDiscovery {
    /// Compute social anchors at Fibonacci bucket sizes
    /// Validators must be sorted by hash for deterministic anchors
    /// Only generates anchors for buckets the group can fill
    fn social_anchors(&self) -> Vec<(Hash, usize)>;
    
    /// Broadcast discovery summary at all bucket URIs this group can fill
    async fn broadcast_summaries(&self) -> Result<()>;
    
    /// Discover groups by scanning all bucket URIs we can fill
    async fn discover_candidates(&self) -> Vec<FederationCandidate>;
    
    /// Calculate EXACT overlap using PSI-CA (bucket match is just discovery hint)
    fn calculate_overlap(&self, candidate: &FederationCandidate) -> usize;
    
    /// Check if candidate meets federation threshold (BOTH conditions)
    fn meets_threshold(&self, candidate: &FederationCandidate) -> bool;
}

pub struct FederationCandidate {
    pub group_id: Hash,
    pub validator_count: usize,
    pub overlap_count: usize,           // Actual overlap from PSI-CA
    pub discovered_at_bucket: usize,    // Which Fibonacci bucket matched (3, 5, 8...987)
}

impl FederationCandidate {
    pub fn intersection_density(&self, our_validator_count: usize) -> f32 {
        let smaller = our_validator_count.min(self.validator_count);
        self.overlap_count as f32 / smaller as f32
    }
}
```

---

## Federation vs Persistence Interaction Timeline

### Step-by-Step

```
1. Bot-A joins network:
   - Registers with Persistence Registry (adds to bot list, num_chunks, increments epoch)
   - For each chunk: computes holders via rendezvous_hash(A, chunk_idx, bot_list, epoch)
   - IF holders reachable: Distributes chunks, enters ACTIVE
   - IF no peers available: Enters PROVISIONAL (writes allowed)
   - Bot-A can WRITE to Freenet ✓

2. Bot-A establishes chunk holders (security):
   - Deterministic assignment per-chunk: different holders for each chunk
   - Anyone CAN compute who holds A's chunks (public algorithm)
   - BUT: Chunks are ENCRYPTED (holders can't read content)
   - Need ALL chunks + ACI key to reconstruct
   - Transitions PROVISIONAL → ACTIVE

3. Bot-A fulfills fairness obligations (separate concern):
   - Computes: "Which bots' chunks must I hold?" (reverse rendezvous query)
   - Bot-A holds chunks FOR Bot-B, Bot-C (determined by algorithm, ~2x state size)
   - This is DIFFERENT from who holds Bot-A's chunks
   - Fairness ratio tracked (total_stored / my_state_size ≈ 2x)

4. Later, Bot-A federates with Bot-B (OPTIONAL):
   - Shadow Beacon discovers shared validators
   - PSI-CA confirms overlap threshold
   - Groups vote to federate
   - Mutual recognition recorded in each contract
   - Bot-A subscribes to Bot-B for ZK queries (ADDITIONAL subscription)

5. Result:
   - Bot-A has chunk holders distributed across multiple bots (deterministic, verifiable, adversarial)
   - Bot-A has fairness obligations computed from algorithm (~2x storage ratio)
   - Bot-A MAY have federation peer (trusted, optional bonus persistence)
   - These THREE relationships are SEPARATE and don't leak correlation
   
Note on holder identity:
   - Anyone CAN compute who holds whose chunks (rendezvous hashing per-chunk)
   - This is acceptable because chunks are ENCRYPTED
   - Attack requires compromising ALL chunk holders + ACI key
   - Larger states → more chunks → more distribution → harder to seize
   - Deterministic assignment removes registry as attack target
```

### Key Insight

**Federations are TRANSITORY** - they can dissolve if shared validators leave.

**Persistence peers are the STABLE FOUNDATION** that doesn't depend on trust relationships.

**Holder identities are COMPUTABLE but chunks are ENCRYPTED** - security comes from encryption, not obscurity.

**Bot is never penalized for network scarcity** - only blocked when it COULD fix its replica set but hasn't.

---

## Related Constraints

- **persistence-model.bead**: Overall persistence architecture
- **federation-roadmap.bead**: Federation phases and requirements
- **security-constraints.bead**: Trust model enforcement
- **governance-model.bead**: Human vote requirements

---

## Summary

**Two protocols, two purposes, two trust models.**

| Protocol | Remember |
|----------|----------|
| Persistence Discovery | Adversaries holding encrypted chunks |
| Federation Discovery | Trusted groups growing organically |

**Never conflate them.** The security model depends on keeping them separate.

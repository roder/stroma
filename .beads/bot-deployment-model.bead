# Bead: Bot Deployment Model

**Status**: Immutable Architectural Constraint  
**Created**: 2026-01-28  
**Context**: Architecture Decision 2.1

---

## Constraint: 1:1 Bot-to-Group Relationship

**Principle**: One bot process per Stroma group.

### Architecture Rule

```
1 Bot Instance = 1 Signal Group = 1 Freenet Contract = 1 Trust Mesh
```

**NEVER**:
- ❌ Design bot to manage multiple Signal groups (1:N)
- ❌ Multiplex Signal messages across groups
- ❌ Share Freenet contracts across groups
- ❌ Use single phone number for multiple groups

**ALWAYS**:
- ✅ Deploy one bot instance per group
- ✅ Use separate phone numbers per group
- ✅ Isolate state across bot instances
- ✅ Use systemd service templates for multi-group deployment

### Deployment Model

```rust
// Actual struct from src/signal/bot.rs (generic over trait abstractions for testability)
pub struct StromaBot<C: SignalClient, F: FreenetClient> {
    client: C,                              // Signal client (MockSignalClient or LibsignalClient)
    freenet: F,                             // Freenet client (MockFreenetClient or EmbeddedKernel)
    config: BotConfig,                      // Per-instance config (group_id, pepper, thresholds)
    group_manager: GroupManager<C>,         // Signal group operations
    poll_manager: PollManager<C>,           // Proposal polls
    bootstrap_manager: BootstrapManager<C>, // One-time seed group setup
    vetting_sessions: VettingSessionManager,// Ephemeral admission state
    member_resolver: MemberResolver,        // Transient MemberHash <-> ServiceId mapping
    persistence_manager: WriteBlockingManager, // Chunk distribution health
}
```

**One bot = one Signal connection + one Freenet node + one group.**

**⚠️ Store Requirement**: Each bot uses `StromaStore` (wrapper around encrypted SqliteStore, no-ops message persistence).
- ❌ NEVER use bare `SqliteStore` (stores message history - security violation)
- ✅ ALWAYS use `StromaStore` wrapper (delegates protocol state/groups, no-ops messages/stickers)
- ✅ See `.beads/security-constraints.bead` and `.beads/technology-stack.bead`

### Multi-Group Deployment

**Systemd Services:**
```
stroma-bot@mission-control.service
stroma-bot@activists-nyc.service
stroma-bot@mutual-aid-sf.service
```

**Configuration:**
```
/etc/stroma/groups/mission-control/config.toml
/etc/stroma/groups/activists-nyc/config.toml
/etc/stroma/groups/mutual-aid-sf/config.toml
```

**State Storage:**
```
/var/lib/stroma/mission-control/state.db
/var/lib/stroma/activists-nyc/state.db
/var/lib/stroma/mutual-aid-sf/state.db
```

### Rationale

**Why 1:1?**
- **Simplicity**: Each bot owns one contract, one state, one group
- **Isolation**: One group's issues don't cascade to others
- **Clear Identity**: Bot phone number = Group identity
- **Debugging**: Logs, state, errors are per-group
- **Federation**: Each bot represents one mesh (natural alignment)
- **Scale**: <100 groups = <100 processes (acceptable resource usage)

**Why NOT 1:N?**
- Complex state multiplexing
- Group leakage risk (bug in one affects all)
- Federation confusion (which group is federating?)
- Debugging nightmare (multiplexed logs)
- Violates single responsibility principle

### Resource Requirements

**Per Bot Instance:**
- RAM: ~100MB
- Storage: ~50MB (database)
- Network: Minimal (Signal + Freenet)

**For 10 Groups:**
- RAM: ~1GB
- Storage: ~500MB
- Network: Minimal

**Acceptable for <100 groups.**

### Code Constraints

**Block These Patterns:**
```rust
// ❌ NEVER do this
pub struct StromaBot {
    groups: HashMap<GroupId, GroupState>,  // NO multi-tenancy
}

// ❌ NEVER do this  
match group_id {
    "group1" => handle_group1(),
    "group2" => handle_group2(),
    // NO multiplexing
}
```

**Enforce These Patterns:**
```rust
// ✅ ALWAYS do this
pub struct StromaBot {
    group_id: GroupId,         // Single group only
    group_name: String,        // Single name only
    // ... single group fields
}

// ✅ ALWAYS validate
assert_eq!(bot.managed_groups().len(), 1);
```

### Gastown Agent Instructions

**When implementing bot:**
1. Design assumes single group per instance
2. No code for managing multiple groups
3. Configuration is per-instance, not per-group
4. Deployment guide should show systemd templates for multi-group

**If agent suggests 1:N:**
- **REJECT** - violates architectural constraint
- **REDIRECT** - show multi-instance deployment model
- **BLOCK** - do not merge 1:N code

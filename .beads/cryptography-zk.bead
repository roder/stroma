# Bead: Cryptography & Zero-Knowledge Standards

**Status**: Immutable Architectural Constraint  
**Created**: 2026-02-01  
**Context**: Cryptographic Implementation Standards

---

## Zero-Knowledge Proof Requirements

### Trust Verification Logic

The Freenet contract must verify:
```
ASSERT: zk_Proof(PROVE(Signer_A) AND PROVE(Signer_B))
WHERE: Signer_A IS_MEMBER_OF Global_Merkle_Tree
AND: Signer_B IS_MEMBER_OF Global_Merkle_Tree
AND: Signer_A IS_NOT Signer_B
AND: New_Member_Hash IS_NOT_MEMBER_OF Global_Merkle_Tree
```

### Recursive Proofs
- Implement recursive proofs for scalability
- Batch updates to ensure constant-time verification regardless of network size
- Use `winterfell` for STARK circuit implementation (no trusted setup, post-quantum secure)
- **See**: `.beads/architecture-decisions.bead` for rationale on STARKs over SNARKs

---

## Private Set Intersection (PSI)

### PSI-CA Pattern
```rust
// Conceptual pattern for Private Set Intersection Cardinality
// Both bots apply commutative encryption (double-blinding)
// Compare results to find overlap count without revealing specific IDs
pub fn find_intersection_size(
    my_hashes: Vec<[u8; 32]>, 
    peer_hashes: Vec<[u8; 32]>
) -> usize {
    // Commutative encryption applied
    // Returns count only, never individual matches
}
```

### Federation Threshold (BidirectionalMin with Independent Thresholds)
- **Old approach**: `|A ∩ B| / |A ∪ B| > 0.10` (union-based, problematic with asymmetric groups)
- **New approach**: BidirectionalMin with independent per-group thresholds

**BidirectionalMin Logic:**
```rust
// Each group evaluates with its own threshold
let density_in_a = intersection_count / group_a_size;
let density_in_b = intersection_count / group_b_size;

// Both must be satisfied
if (density_in_a >= threshold_a) && (density_in_b >= threshold_b) {
    propose_federation_to_both_groups();
}
```

**Key Properties:**
- Each group has independent threshold in their GroupConfig
- Small groups can require higher thresholds (e.g., 30%) to avoid absorption
- Large groups can accept lower thresholds (e.g., 10%) for growth
- Use PSI-CA to calculate overlap without revealing member identities
- **Commutative Encryption**: Double-blinding for anonymous overlap calculation
- **Trust Horizon**: Anonymous trust verification without lineage tracing
- **Group Autonomy**: Thresholds stored in Freenet contract, changeable only via group vote

---

## Merkle Tree Implementation

### State Storage Pattern
- **Never store member lists directly** - use hashed identifiers only
- **Generate Merkle Trees on-demand** from member sets for ZK-proof verification
- **Do NOT store Merkle Trees** in contract state (they're not mergeable)
- Store membership in BTreeSet (naturally mergeable), generate Merkle Tree when needed
- Bot verifies STARK proofs, submits verified outcomes to contract (Phase 0 architecture)

### On-Demand Merkle Tree Generation (Q5 Spike Validated)

**Q5 Finding**: On-demand Merkle generation is extremely fast — no caching needed.

| Members | Root Calculation |
|---------|------------------|
| 100 | 0.01ms |
| 1000 | **0.09ms** |
| 5000 | 0.45ms |

**Decision**: Generate on demand. 0.09ms at 1000 members is 1000x faster than threshold.

**See**: `docs/spike/q5/RESULTS.md` for full benchmarks.

**Implementation Pattern**:
```rust
// Root calculation: on-demand for all membership verification
let root = calculate_root(&members)?;

// Full tree: only when proof generation needed
let tree = MerkleTree::from_btreeset(&members)?;
let proof = tree.generate_proof(&member_hash)?;
```

### Tree Updates
- Membership changes update BTreeSet (automatically merged via ComposableState)
- Merkle Tree regenerated on-demand for next verification (no cache invalidation needed)
- **Note**: Key rotation handled via Signal protocol store if needed.

---

## ZK-Proof Verification Location (Q4 Spike Validated)

### Bot-Side Verification (Phase 0)

**Q4 Finding**: winterfell Wasm is experimental. **Bot-side verification** recommended for Phase 0.

**Architecture**:
```
Member → Signal command → Bot → Generate & Verify STARK → Submit outcome → Freenet
```

**Key Points**:
- Bot generates proofs (members NEVER generate proofs)
- Bot verifies proofs using native winterfell (fast, reliable)
- Bot submits verified outcomes to Freenet contract
- Contract trusts bot's verification (acceptable for Phase 0 trust model)

**See**: `docs/spike/q4/RESULTS.md` for full analysis.

### Why Not Contract-Side (Q4)
- winterfell Wasm support is experimental
- SIMD dependencies, compilation challenges
- Bot can forge valid proofs anyway (has all inputs)
- Defense against compromised bot comes from cross-cluster requirement and operator accountability, not contract STARK verification

### Proof Storage (Q6 Decision)
Since bot verifies (not contract): **Store outcomes only** (not proofs).
- Proofs are ephemeral (10-100KB each)
- Contract stores "Alice vouched for Bob", not the proof
- Simplifies contract state and merging

**See**: `docs/spike/q6/RESULTS.md` for rationale.

---

## Key Management

### Social Anchor Hashing (Fixed Fibonacci Buckets)
- Generate **multiple** Freenet URIs using **Fixed Fibonacci Bucket sizes** (not percentiles)
- **Fibonacci Buckets**: [3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987]
- **Why Fixed Counts**: Groups of ANY size hash to the SAME bucket sizes, enabling cross-size discovery

**Discovery URI Generation:**
```rust
// Fixed Fibonacci buckets (up to Signal's 1000-member limit)
const RENDEZVOUS_BUCKETS: &[usize] = &[
    3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987
];

fn generate_discovery_uris(validators: &[ValidatorId]) -> Vec<(FreenetUri, usize)> {
    // Sort validators deterministically by hash
    let mut sorted_validators: Vec<_> = validators.iter().cloned().collect();
    sorted_validators.sort_by_key(|v| v.hash);
    
    // Generate URIs for each bucket we can fill
    RENDEZVOUS_BUCKETS.iter()
        .filter(|&&bucket_size| sorted_validators.len() >= bucket_size)
        .map(|&bucket_size| {
            let top_n: Vec<_> = sorted_validators.iter().take(bucket_size).collect();
            let uri = hash_social_anchor(&top_n);
            (uri, bucket_size)
        })
        .collect()
}
```

**Discovery Process:**
1. Each bot publishes Bloom Filters at ALL Fibonacci bucket URIs it can fill
2. Bots scan bucket URIs to find matches
3. Matching hash at bucket N means groups share the SAME top-N validators (sorted by hash)
4. Proceed with PSI-CA to calculate EXACT overlap count
5. Evaluate BidirectionalMin thresholds (each group against its own config)

**Benefits:**
- **Fixed counts (not percentiles)** → groups of different sizes produce MATCHING hashes
- Small group (12 validators) and large group (100 validators) can discover each other at URI-3, URI-5, URI-8
- Discovery requires actual shared validators, not just similar percentages
- Fibonacci sequence provides natural scaling with better granularity at small sizes

**See**: `.beads/discovery-protocols.bead` for complete specification

### Key Derivation
- **Never use pre-shared keys (PSK)**
- **HMAC-SHA256 with Signal ACI-derived key**: Replaces deprecated group pepper. Single cryptographic identity source.
- **ACI Key Derivation**: Uses HKDF from bot's Signal ACI identity private key
- All crypto keys derived from Signal ACI identity (simpler backup — Signal store only)
- **Ephemeral state**: Relationship data deleted after vetting threshold met
- **See**: `.beads/security-constraints.bead` for implementation pattern

---

## Memory Security

### Zeroization Requirements
- Use `zeroize` crate for all sensitive buffers
- Purge immediately after cryptographic operations
- Never leave keys or identifiers in memory longer than necessary

description = """
Enhanced Boot triage cycle - monitors Deacon AND Refinery/MQ health.

This version extends the original boot-triage to also:
1. Check merge queue for pending work
2. Monitor Refinery responsiveness (not just existence)
3. Auto-spawn Refinery when MRs arrive
4. Detect idle agents with pending work

Boot lifecycle:
1. Observe (Deacon + Refinery + MQ state)
2. Decide (start/wake/nudge/interrupt for both agents)
3. Act on both Deacon and Refinery
4. Clean inbox
5. Exit

Boot is always fresh - no persistent state between invocations.
"""
formula = "mol-boot-triage-enhanced"
version = 1

[[steps]]
id = "observe"
title = "Observe system state (Deacon + Refinery + MQ)"
description = """
Observe the current system state for ALL critical agents.

**Step 1: Check Deacon state**
```bash
# Is Deacon session alive?
if tmux has-session -t hq-deacon 2>/dev/null; then
    echo "Deacon: alive"
    # Check last 20 lines of pane for activity
    tmux capture-pane -t hq-deacon -p -S -20 | tail -5
else
    echo "Deacon: dead"
fi
```

**Step 2: Check Refinery state for each rig**
```bash
# For each rig with a merge queue
for rig in stromarig; do
    echo "Checking refinery for $rig..."

    # Does refinery session exist?
    tmux has-session -t "gt-${rig}-refinery" 2>/dev/null && echo "Session exists" || echo "Session dead"

    # If exists, check if it's responsive (not just existing)
    if tmux has-session -t "gt-${rig}-refinery" 2>/dev/null; then
        # Check pane output for activity indicators
        last_output=$(tmux capture-pane -t "gt-${rig}-refinery" -p -S -20)

        # Check for idle indicators:
        # - Prompt waiting: "❯"
        # - Error loop: repeated errors
        # - Silence: no recent output

        if echo "$last_output" | tail -1 | grep -q "❯"; then
            echo "Refinery is IDLE (at prompt)"
        elif echo "$last_output" | grep -q "Running\\|thinking\\|Bash"; then
            echo "Refinery is ACTIVE"
        else
            echo "Refinery state UNKNOWN"
        fi
    fi
done
```

**Step 3: Check merge queue for pending work**
```bash
# For each rig
for rig in stromarig; do
    # Check if merge queue has ready work
    mq_status=$(gt mq list "$rig" 2>/dev/null)
    ready_count=$(echo "$mq_status" | grep -c "ready" || echo "0")

    echo "MQ $rig: $ready_count ready MRs"
done
```

**Step 4: Check Deacon/Refinery mail** (optional, can skip if slow)
```bash
# Quick mail check with timeout
timeout 2s gt mail inbox deacon 2>/dev/null | wc -l || echo "0"
timeout 2s gt mail inbox gt-stromarig-refinery 2>/dev/null | wc -l || echo "0"
```

**Step 5: Check recent activity** (optional, not critical for triage decision)
```bash
# Quick check of recent feed - use JSONL directly instead of gt feed
if [ -f "$GT_ROOT/.feed.jsonl" ]; then
    tail -20 "$GT_ROOT/.feed.jsonl" 2>/dev/null || echo "No recent feed"
else
    echo "Feed file not found, skipping"
fi
```

Record observations:
- deacon_alive: true/false
- deacon_activity: active/idle/stuck
- refinery_alive: true/false (per rig)
- refinery_activity: active/idle/stuck (per rig)
- mq_ready_count: number of pending MRs (per rig)
- pending_mail: count for each agent
"""

[[steps]]
id = "decide"
title = "Decide on actions for Deacon and Refinery"
needs = ["observe"]
description = """
Analyze observations and decide actions for BOTH agents.

**Deacon Decision Matrix** (same as original)
| Deacon State | Pane Activity | Action |
|--------------|---------------|--------|
| Dead session | N/A | START |
| Alive, active | N/A | NOTHING |
| Alive, idle < 5 min | N/A | NOTHING |
| Alive, idle 5-15 min | No mail | NOTHING |
| Alive, idle 5-15 min | Has mail | NUDGE |
| Alive, idle > 15 min | Any | WAKE |
| Alive, stuck | Any | INTERRUPT |

**Refinery Decision Matrix** (NEW)
| Refinery State | MQ Status | Last Activity | Action |
|----------------|-----------|---------------|--------|
| Dead session | MRs pending | N/A | START |
| Dead session | MQ empty | N/A | NOTHING |
| Alive, active | Any | N/A | NOTHING |
| Alive, idle at prompt | MRs pending | < 2 min | NOTHING (just finished) |
| Alive, idle at prompt | MRs pending | > 2 min | WAKE (has work!) |
| Alive, idle at prompt | MQ empty | Any | NOTHING |
| Alive, stuck/error | Any | Any | INTERRUPT |
| Unknown state | MRs pending | > 5 min | RESTART |

**Key Insight**: If Refinery session exists but is idle with pending MRs,
that's a bug - it should be processing. Wake it or restart it.

**Output**: Record decisions as:
- deacon_action: NOTHING/NUDGE/WAKE/INTERRUPT/START
- refinery_action: NOTHING/NUDGE/WAKE/INTERRUPT/START (per rig)
"""

[[steps]]
id = "act"
title = "Execute actions for both agents"
needs = ["decide"]
description = """
Execute the actions decided for Deacon and Refinery.

**For Deacon** (same as original):
- NOTHING: Log and continue
- NUDGE: `gt nudge deacon "Boot check-in: you have pending work"`
- WAKE: Send escape + wake message
- INTERRUPT: Send mail about stuck state
- START: Daemon will restart (log detection)

**For Refinery** (NEW):

**NOTHING**
```bash
echo "Refinery: No action needed"
```

**START** (when dead with pending MRs)
```bash
echo "Starting refinery for $rig (MRs pending)..."
gt refinery start "$rig"
```

**WAKE** (when idle at prompt with pending MRs)
```bash
echo "Waking idle refinery for $rig (has pending work)..."

# Send escape to break prompt
tmux send-keys -t "gt-${rig}-refinery" Escape
sleep 1

# Send wake message
gt nudge "gt-${rig}-refinery" "Boot wake: You have pending MRs in queue. Please check: gt mq list $rig"
```

**INTERRUPT** (when stuck/error loop)
```bash
echo "Interrupting stuck refinery for $rig..."

gt mail send "gt-${rig}-refinery" -s "INTERRUPT: Boot detected stuck state" \
  -m "Boot observed stuck/error state. Consider handoff or restart.

Observations: <summary>

Check your context and merge queue status."
```

**RESTART** (when unknown state with pending work)
```bash
echo "Restarting refinery for $rig (unknown state with pending work)..."

# Kill session
tmux kill-session -t "gt-${rig}-refinery" 2>/dev/null || true

# Start fresh
gt refinery start "$rig"
```

Record all actions taken.
"""

[[steps]]
id = "cleanup"
title = "Clean stale handoffs"
needs = ["act"]
description = """
Clean up stale handoff messages from agent inboxes.

**For Deacon** (same as original):
- Archive handoffs older than 1 hour

**For Refinery**:
- Archive MERGE_READY notifications already processed
- Archive handoffs older than 1 hour
- Archive old MERGED notifications

```bash
# For each refinery inbox (with timeout to avoid hanging)
for rig in stromarig; do
    timeout 5s gt mail inbox "gt-${rig}-refinery" --json 2>/dev/null | \
        jq -r '.[] | select(.age_hours > 1) | .id' | \
        xargs -I {} timeout 2s gt mail archive {} 2>/dev/null || true
done
```

**For Boot's own inbox**:
Archive everything - Boot is ephemeral.
```bash
timeout 5s gt mail inbox gt-boot --json 2>/dev/null | \
    jq -r '.[].id' | \
    xargs -I {} timeout 2s gt mail archive {} 2>/dev/null || true
```
"""

[[steps]]
id = "exit"
title = "Exit with status"
needs = ["cleanup"]
description = """
Complete this Boot cycle with status update.

**Write status file**:
```bash
# Summary of what was done
cat > "$GT_ROOT/deacon/dogs/boot/.boot-status.json" <<EOF
{
  "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "deacon_action": "$deacon_action",
  "refinery_actions": {
    "stromarig": "$stromarig_refinery_action"
  },
  "mq_status": {
    "stromarig": $stromarig_mq_ready_count
  }
}
EOF
```

**In degraded mode**:
Exit directly:
```bash
echo "Boot triage complete (deacon: $deacon_action, refinery: $stromarig_refinery_action)"
exit 0
```

**In normal mode**:
Send handoff to next Boot instance:
```bash
gt mail send boot -s "Boot handoff" -m "Completed enhanced triage cycle.

Deacon: $deacon_action
Refinery(stromarig): $stromarig_refinery_action
MQ ready count: $stromarig_mq_ready_count

Time: $(date)"
```

Then exit. Next daemon tick will spawn fresh Boot.
"""

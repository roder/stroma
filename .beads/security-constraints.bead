# Security Constraints (IMMUTABLE)

**Status**: Pinned - Cannot be modified without explicit unpinning ceremony
**Last Updated**: 2026-02-01
**Applies To**: All agents, all code, all phases

## Critical Principle

These constraints are **NON-NEGOTIABLE**. Any code that violates these constraints MUST be rejected, regardless of functionality or convenience.

## 1. Anonymity-First Design

### Never Store Signal IDs in Cleartext
- ❌ **NEVER** store Signal IDs in any persistent storage
- ❌ **NEVER** log Signal IDs to disk, console, or any output
- ❌ **NEVER** transmit Signal IDs over network in cleartext
- ❌ **NEVER** include Signal IDs in error messages
- ❌ **NEVER** cache Signal IDs in memory longer than necessary

### HMAC-Based Identity Masking (REQUIRED)

**Use Signal ACI-derived key for identity masking** — no separate group pepper needed.

```rust
// ✅ REQUIRED PATTERN
use ring::hmac;
use hkdf::Hkdf;
use sha2::Sha256;
use zeroize::Zeroize;
use libsignal_protocol::IdentityKeyPair;

/// Derive HMAC key from Signal ACI identity
/// This replaces the "group pepper" — single cryptographic identity for everything
fn derive_identity_masking_key(aci_identity: &IdentityKeyPair) -> [u8; 32] {
    let hk = Hkdf::<Sha256>::new(
        Some(b"stroma-identity-masking-v1"),
        aci_identity.private_key().serialize().as_slice()
    );
    let mut key = [0u8; 32];
    hk.expand(b"hmac-sha256-key", &mut key).unwrap();
    key
}

pub fn mask_identity(signal_id: &str, aci_identity: &IdentityKeyPair) -> Hash {
    // Derive HMAC key from Signal ACI identity
    let hmac_key_bytes = derive_identity_masking_key(aci_identity);
    let key = hmac::Key::new(hmac::HMAC_SHA256, &hmac_key_bytes);
    let tag = hmac::sign(&key, signal_id.as_bytes());
    
    // Zeroize derived key immediately
    // (hmac_key_bytes is on stack, will be overwritten)
    
    Hash::from_bytes(tag.as_ref())
}
```

**Key Requirements:**
- Use HMAC-SHA256 (ring crate)
- Derive HMAC key from Signal ACI identity via HKDF (replaces group pepper)
- NOT deterministic hashing (same ID = different hash with different bot)
- Single cryptographic identity: Signal ACI used for encryption, signing, AND identity masking

**Why Signal ACI (not separate group pepper):**
- Simpler backup: Signal store backup covers everything
- No extra secrets: No separate pepper file to manage
- Already secure: Signal keys stored in secure protocol store
- Consistent identity: One key derivation source for all crypto operations

### Immediate Zeroization (MANDATORY)
- ✅ **ALWAYS** use `zeroize` crate for sensitive buffers
- ✅ **ALWAYS** zeroize immediately after hashing
- ✅ **ALWAYS** zeroize on drop (use `ZeroizeOnDrop` derive)
- ✅ **ALWAYS** zeroize on error paths (don't leak on panic)

```rust
// ✅ REQUIRED PATTERN
use zeroize::{Zeroize, ZeroizeOnDrop};

#[derive(ZeroizeOnDrop)]
struct SensitiveData {
    signal_id: String,
    aci_identity: IdentityKeyPair,  // Signal ACI identity (replaces pepper)
}

impl SensitiveData {
    fn process(&mut self, aci_identity: &IdentityKeyPair) -> Hash {
        // Process data using ACI-derived key
        let hash = mask_identity(&self.signal_id, aci_identity);
        
        // Explicit zeroization of cleartext
        self.signal_id.zeroize();
        // Note: aci_identity is not zeroized here - managed by Signal store
        
        hash
    }
}
```

### Memory Hygiene Verification
- Memory dump MUST contain ONLY hashed identifiers
- No cleartext Signal IDs in core dumps, crash logs, or debug output
- Test with intentional panic to verify zeroization

### Vote Privacy (Persistence Constraint)

**⚠️ CRITICAL**: Individual votes MUST NEVER be persisted.

**What MAY be persisted (Freenet contract):**
- ✅ Aggregate vote counts (approve: N, reject: M)
- ✅ Proposal outcome (passed/failed)
- ✅ Quorum/threshold status

**What MUST NEVER be persisted:**
- ❌ Who voted for what
- ❌ Individual vote records
- ❌ Voter identities (hashed or cleartext)
- ❌ Vote timestamps per voter

**Rationale:**
- Signal shows votes to group members during poll (ephemeral, E2E encrypted)
- Stroma stores only outcomes in Freenet (permanent, potentially seizable)
- Protects members from retroactive identification of dissent
- Even with state seizure, voting history cannot be reconstructed

**See**: `.beads/voting-mechanism.bead` for full voting design

## 2. Trust Model Enforcement

### No Grace Periods (ABSOLUTE)
- ❌ **NEVER** add grace periods for ejection
- ❌ **NEVER** add warnings before ejection
- ❌ **NEVER** add re-verification windows
- ❌ **NEVER** delay ejection for any reason

### Vouch Invalidation (CRITICAL LOGIC)
- **Rule**: If a voucher flags a member, that vouch is invalidated
- **Rationale**: Logical inconsistency - you can't both trust and distrust someone
- **Calculation**: Effective vouches = Total vouches - Voucher-flaggers
- **Impact**: Prevents "vouch bombing" and aligns with fluid identity philosophy

**CRITICAL PRINCIPLE - NO UNILATERAL 2-POINT SWINGS**:
- ❌ **NEVER** allow any single member to cause a 2-point swing in another member's standing
- ❌ **NEVER** count a flag from a voucher as both invalidating vouch AND adding a flag
- ✅ Voucher-flaggers are excluded from BOTH vouch count AND flag count
- ✅ A single member's flag (even from a voucher) invalidates only the vouch, not both
- **Why**: No single actor should unilaterally eject another member through their own action

**Two Independent Ejection Triggers:**
1. **Standing < 0**: `Standing = Effective_Vouches - Regular_Flags < 0`
2. **Effective_Vouches < min_vouch_threshold**: Default 2, configurable

**Definitions** (Mathematically Precise):
```
All_Vouchers = {members who vouched for target}
All_Flaggers = {members who flagged target}
Voucher_Flaggers = All_Vouchers ∩ All_Flaggers (contradictory members)

Effective_Vouches = |All_Vouchers| - |Voucher_Flaggers|
Regular_Flags = |All_Flaggers| - |Voucher_Flaggers|
Standing = Effective_Vouches - Regular_Flags

KEY: Members in Voucher_Flaggers contribute NEITHER to vouches NOR flags
```

**Example (NO 2-point swing)**:
- Bob has 2 vouches (Alice, Carol), 0 flags
- Alice flags Bob
- Voucher_Flaggers = {Alice}
- Effective_Vouches = 2 - 1 = **1** ← Alice's vouch removed
- Regular_Flags = 1 - 1 = **0** ← Alice's flag NOT counted
- Standing = 1 - 0 = **1** (drop of 1, not 2)
- Result: Ejected via Trigger 2 (Effective_Vouches < 2)

**Both triggers result in IMMEDIATE ejection** (no delay, no notification beforehand)

### Freenet as Source of Truth (ABSOLUTE)
- ❌ **NEVER** make Signal group the source of truth
- ❌ **NEVER** cache trust decisions locally without Freenet verification
- ❌ **NEVER** allow operator to override Freenet state
- ✅ **ALWAYS** verify with Freenet before Signal actions

```rust
// ✅ REQUIRED PATTERN
async fn add_member_to_signal(
    member_hash: Hash,
    freenet: &FreenetClient,
    signal: &SignalClient,
) -> Result<(), Error> {
    // MUST verify with Freenet first
    let verified = freenet.verify_member_vetted(member_hash).await?;
    
    if !verified {
        return Err(Error::NotVetted);
    }
    
    // Only AFTER Freenet confirms, modify Signal state
    signal.add_member(member_hash).await?;
    
    Ok(())
}
```

### Zero-Knowledge Proof Verification (MANDATORY)
- ❌ **NEVER** bypass ZK-proof verification
- ❌ **NEVER** accept trust without cryptographic proof
- ✅ **ALWAYS** verify STARK proofs before admission
- ✅ **ALWAYS** verify Merkle tree membership

```rust
// ✅ REQUIRED PATTERN
async fn verify_vouch(
    member_hash: Hash,
    voucher_a: Hash,
    voucher_b: Hash,
    proof: StarkProof,
    freenet: &FreenetClient,
) -> Result<bool, Error> {
    // Verify proof cryptographically
    let proof_valid = winterfell::verify_proof(&proof)?;
    
    if !proof_valid {
        return Ok(false);
    }
    
    // Verify vouchers are in Merkle tree
    let voucher_a_valid = freenet.verify_in_tree(voucher_a).await?;
    let voucher_b_valid = freenet.verify_in_tree(voucher_b).await?;
    
    // Verify vouchers are different
    if voucher_a == voucher_b {
        return Ok(false);
    }
    
    // Verify member is NOT in tree (new member)
    let member_not_in_tree = !freenet.verify_in_tree(member_hash).await?;
    
    Ok(proof_valid && voucher_a_valid && voucher_b_valid && member_not_in_tree)
}
```

## 3. State Management

### Real-Time State Stream (REQUIRED)
- ❌ **NEVER** use polling for Freenet state
- ✅ **ALWAYS** use real-time state stream monitoring
- ✅ **ALWAYS** react to state changes immediately

```rust
// ✅ REQUIRED PATTERN (Real-time stream)
async fn monitor_state_changes(freenet: &FreenetClient) {
    let mut stream = freenet.subscribe_to_state_changes().await.unwrap();
    
    while let Some(change) = stream.next().await {
        match change {
            StateChange::MemberVetted(hash) => handle_admission(hash).await,
            StateChange::MemberRevoked(hash) => handle_ejection(hash).await,
            StateChange::FederationApproved(group) => handle_federation(group).await,
        }
    }
}

// ❌ FORBIDDEN PATTERN (Polling)
async fn poll_state_changes(freenet: &FreenetClient) {
    loop {
        let state = freenet.get_state().await.unwrap();
        // Process state...
        tokio::time::sleep(Duration::from_secs(1)).await; // ❌ Wasteful polling
    }
}
```

### Ephemeral Session Data (MANDATORY)
- Vetting session data MUST be deleted after admission threshold met
- No persistent storage of relationship content
- No logs of why people trust each other

```rust
// ✅ REQUIRED PATTERN
async fn complete_admission(member_hash: Hash, session: VettingSession) {
    // Add member to Freenet
    freenet.add_member(member_hash).await?;
    
    // Add member to Signal
    signal.add_member(member_hash).await?;
    
    // DELETE ephemeral vetting session data
    session.delete().await?;
    
    // Logs must NOT contain relationship details
    log::info!("Member {} admitted", member_hash); // Hash only, no context
}
```

## 4. Vouch Permissions

### ANY Member Can Vouch (CRITICAL)
- ❌ **NEVER** restrict vouching to only Validators
- ✅ **ALWAYS** allow ANY Member (Bridges and Validators) to vouch
- ✅ Bot MAY suggest Validators for optimization (Blind Matchmaker)
- ✅ Bot CANNOT enforce Validator-only vouching

```rust
// ✅ REQUIRED PATTERN
fn can_vouch(member: &Member) -> bool {
    // ANY Member in the group can vouch
    member.is_in_group()
}

// ❌ FORBIDDEN PATTERN
fn can_vouch_forbidden(member: &Member) -> bool {
    member.is_validator() // ❌ WRONG: Only Validators
}
```

### First Vouch = Invitation (REQUIRED)
- ❌ **NEVER** implement token exchange system
- ✅ Invitation itself counts as first vouch
- ✅ Bot immediately starts vetting process

```rust
// ✅ REQUIRED PATTERN
async fn process_invite(
    inviter_hash: Hash,
    invitee: SignalId,
    aci_identity: &IdentityKeyPair,
) -> Result<(), Error> {
    // Hash invitee identity immediately (using ACI-derived key)
    let invitee_hash = mask_identity(&invitee, aci_identity);
    invitee.zeroize(); // Zeroize immediately
    
    // Record invitation as FIRST VOUCH
    freenet.record_vouch(invitee_hash, inviter_hash).await?;
    
    // Start vetting process immediately (no token exchange)
    start_vetting_process(invitee_hash).await?;
    
    Ok(())
}
```

## 5. Operator Least Privilege

### Operator is Service Runner ONLY
- ❌ **NEVER** allow operator to manually execute membership changes
- ❌ **NEVER** allow operator to override group decisions
- ❌ **NEVER** allow operator to change consensus thresholds unilaterally
- ❌ **NEVER** allow operator to bypass ejection protocol
- ❌ **NEVER** allow operator access to cleartext Signal IDs
- ❌ **NEVER** allow operator to unilaterally federate groups
- ❌ **NEVER** allow operator to modify GroupConfig without group consensus

### Operator CAN (Service Runner Duties)
- ✅ Start/stop bot service (systemd daemon)
- ✅ Monitor logs for errors
- ✅ Restart bot on crashes
- ✅ Ensure bot stays online

### Bot Automatic Execution (REQUIRED)
```rust
// ✅ REQUIRED PATTERN: Bot executes automatically
async fn bot_event_loop(freenet: &FreenetClient, signal: &SignalClient) {
    let mut stream = freenet.subscribe_to_state_changes().await.unwrap();
    
    loop {
        tokio::select! {
            Some(event) = stream.next() => {
                // Bot AUTOMATICALLY executes contract-approved actions
                match event {
                    StateChange::MemberVetted(hash) => {
                        signal.add_member(hash).await.unwrap(); // Automatic
                    },
                    StateChange::MemberRevoked(hash) => {
                        signal.remove_member(hash).await.unwrap(); // Automatic
                    },
                }
            }
        }
    }
}
```

### Configuration Management (REQUIRED)
- All configuration stored in Freenet contract
- Configuration changes require group vote (Signal Poll)
- Vote must exceed `config_change_threshold` (e.g., 70%)
- Bot automatically applies approved changes

## 6. Privacy & Metadata Protection

### Threat Model: Trust Map Seizure

**Primary Threat**: State-level adversary or compromised operator attempts to seize trust map to identify group members and their relationships.

**Attack Vectors**:
1. Server compromise (gain access to bot server)
2. Memory dump (capture running process memory)
3. Operator compromise (coerced or malicious operator)
4. Freenet node seizure (seize distributed state)
5. Signal metadata analysis (analyze group patterns)

**Three-Layer Defense** (ALL layers REQUIRED):

**Layer 1: No Centralized Storage**
- ✅ Trust map stored in decentralized Freenet network
- ✅ Distributed across peers (no single seizure point)
- ✅ State reconstructable only with peer cooperation
- ❌ **NEVER** store trust map in centralized database

**Layer 2: Cryptographic Privacy**
- ✅ All identities HMAC-hashed (ACI-derived key)
- ✅ Memory contains only hashes (immediate zeroization)
- ✅ ZK-proofs verify trust without revealing vouchers
- ❌ **NEVER** store cleartext identifiers anywhere
- **Result**: Memory dumps reveal only hashes, not identities

**Layer 3: Metadata Isolation**
- ✅ All vetting in 1-on-1 PMs (no Signal group metadata)
- ✅ Operator least-privilege (service runner only)
- ✅ No logs of relationship content or reasons
- ❌ **NEVER** expose vetting operations in group chat
- ❌ **NEVER** announce who vouched for whom

**Adversary Scenario**: Even if adversary compromises bot or server, they only get:
- Hashes (not identities)
- Group size and topology (not relationship details)
- Vouch counts (not who vouched for whom in cleartext)

### Secondary Threats (Complete Enumeration)

Beyond trust map seizure, these threats are documented with defenses:

| # | Threat | Defense | See |
|---|--------|---------|-----|
| 1 | Sybil Attack | Cross-cluster vouching mandatory | `cross-cluster-requirement.bead` |
| 2 | Infiltration | Distributed vetting, immediate ejection | § 2 Trust Model |
| 3 | Vouch Bombing | Vouch invalidation (flag invalidates vouch) | § 2 Trust Model |
| 4 | Coordinated Infiltration | Cross-cluster + DVR optimization | `blind-matchmaker-dvr.bead` |
| 5 | Persistence Peer Attacks | Encryption + challenge-response | § 11 Persistence |
| 6 | Freenet Data Loss | Reciprocal Persistence Network | `persistence-model.bead` |
| 7 | Registry DDoS | PoW + rate limiting + sharding | `persistence-model.bead` |
| 8 | Signal Storage Exposure | Custom `StromaProtocolStore` | § 10 Bot Storage |
| 9 | Supply Chain Attack | cargo-deny, cargo-crev, reproducible builds | § 9 Supply Chain |
| 10 | Signal Protocol Dependency | Inherit Signal's security model | Accepted risk |
| 11 | Operator Account Compromise | Operator OPSEC, revocable linking | Accepted risk |
| 12 | Bot-Level DoS | Rate limiting (Phase 1+) | To be implemented |
| 13 | Social Engineering | Cross-cluster, DVR, vigilance | Accepted risk |
| 14 | Poll/Voting Manipulation | Timeouts, quorum, one-vote-per-account | `voting-mechanism.bead` |
| 15 | Traffic/Timing Analysis | Freenet onion routing | Accepted risk |

### Accepted Risks (Explicit)

These risks are **accepted** as outside Stroma's control:

| Risk | Rationale |
|------|-----------|
| Operator OPSEC failures | Operator security practices outside Stroma's control |
| Signal protocol vulnerabilities | Inherit Signal's security model (well-audited) |
| Social engineering attacks | Fundamentally a human problem, not solvable by technology |
| Sophisticated traffic analysis | Requires global network adversary; Freenet provides baseline protection |
| Supply chain attacks on operators | Operators must verify binary authenticity |

**Full threat model documentation**: `docs/THREAT-MODEL.md`

### All Operations in 1-on-1 PMs (MANDATORY)
- ❌ **NEVER** expose vetting operations in group chat
- ❌ **NEVER** announce who vouched for whom
- ✅ **ALWAYS** use 1-on-1 PMs for vetting
- ✅ **ALWAYS** use hashes (not names) in group announcements

### Trust Map Never in Seizeable Form
- ❌ **NEVER** reveal who vouched for whom to third parties
- ❌ **NEVER** expose relationship structure to external parties
- ❌ **NEVER** allow queries like "who vouched for X?" about OTHER members
- ❌ **NEVER** persist vouch/flag relationships in bot storage (resolve at display time)
- ✅ Bot knows topology for optimization (Blind Matchmaker)
- ✅ Bot does NOT store relationship content or reasons
- ✅ Bot operates on hashed identifiers only
- ✅ User MAY query their OWN vouchers/flaggers (self-query, no new info leaked)

**Self-Query Exception**: A user can see who vouched for them via `/status` because they already participated in those conversations. The threat model protects against *third-party* discovery, not self-knowledge. Display names are resolved ephemerally from Signal API, never persisted.

**See**: `.beads/architectural-decisions-open.bead` § 8 for full rationale

## 7. Node Type Definitions (CRITICAL TERMINOLOGY)

### Clear Distinction
- **Invitees** (aka Leaf Nodes): OUTSIDE Signal group (1 vouch, being vetted)
- **Bridges**: IN Signal group (2 vouches, minimum requirement)
- **Validators**: IN Signal group (3+ vouches, high-trust members, NO special privileges)

**Terminology**: "Invitee" and "Leaf Node" are synonyms — use "Invitee" in user contexts, "Leaf Node" in graph algorithms. See `terminology.bead`.

### Waiting Room = State, Not Place
- ❌ **NEVER** create separate "waiting room" chat
- ✅ "Waiting room" = state of being OUTSIDE Signal group
- ✅ Invitees receive 1-on-1 PMs from bot (not in special space)

## 8. Testing & Verification

### Security Testing (MANDATORY)
- Test with intentional panic to verify zeroization
- Test memory dumps contain only hashes
- Test bot CANNOT bypass Freenet verification
- Test operator CANNOT manually execute commands
- Test all ejection triggers work immediately

### Property-Based Testing (REQUIRED)
```rust
#[cfg(test)]
mod tests {
    use proptest::prelude::*;
    
    proptest! {
        #[test]
        fn test_different_aci_different_hash(
            signal_id in ".*",
        ) {
            // Generate two different ACI identity keypairs
            let aci1 = IdentityKeyPair::generate(&mut rand::thread_rng());
            let aci2 = IdentityKeyPair::generate(&mut rand::thread_rng());
            
            let hash1 = mask_identity(&signal_id, &aci1);
            let hash2 = mask_identity(&signal_id, &aci2);
            
            // Same ID with different ACI MUST produce different hashes
            // (each bot's namespace is isolated)
            assert_ne!(hash1, hash2);
        }
    }
}
```

## 9. Supply Chain Security

### Mandatory Tools (MUST PASS)
- `cargo-deny check` MUST pass (no vulnerabilities)
- `cargo-crev verify` MUST pass (cryptographic verification)
- Run in CI/CD pipeline (blocking)

### Dependency Policy
- Audit all new dependencies before adding
- Prefer well-audited crates (ring, zeroize, winterfell)
- Reject dependencies that could leak identifiers
- Monitor binary size (increases indicate bloat)

## 10. Code Quality for Security

### Trait Abstractions (MANDATORY for Testability)

**100% test coverage is required.** To achieve this, external dependencies MUST use trait abstractions.

```rust
// ✅ REQUIRED PATTERN: Trait abstraction enables mocking
#[async_trait]
pub trait SignalClient: Send + Sync {
    async fn send_message(&self, recipient: &ServiceId, message: &str) -> Result<()>;
    async fn add_group_member(&self, group: &GroupId, member: &ServiceId) -> Result<()>;
    async fn remove_group_member(&self, group: &GroupId, member: &ServiceId) -> Result<()>;
}

#[async_trait]
pub trait FreenetClient: Send + Sync {
    async fn get_state(&self, contract: &ContractHash) -> Result<TrustState>;
    async fn apply_delta(&self, contract: &ContractHash, delta: &Delta) -> Result<()>;
    async fn subscribe(&self, contract: &ContractHash) -> Result<StateStream>;
}

// Bot uses traits, not concrete types
pub struct StromaBot<S: SignalClient, F: FreenetClient> {
    signal: S,
    freenet: F,
}

// ❌ FORBIDDEN: Direct dependency (untestable)
pub struct StromaBot {
    manager: presage::Manager<SqliteStore>,  // Can't mock this
}
```

**Rationale**: Stroma's security constraints require 100% test coverage with no exceptions. Trait abstractions enable `MockSignalClient` and `MockFreenetClient` for unit tests without real network calls.

### Unsafe Block Documentation (MANDATORY)

All `unsafe` blocks MUST have a `// SAFETY:` comment explaining why the code is sound.

```rust
// ✅ REQUIRED PATTERN
// SAFETY: The buffer is guaranteed to be valid for the lifetime of the operation
// because we hold an exclusive lock on the containing structure, and the pointer
// was obtained from a valid slice within this function's scope.
unsafe {
    std::ptr::copy_nonoverlapping(src, dst, len);
}

// ❌ FORBIDDEN: Unsafe without explanation
unsafe {
    std::ptr::copy_nonoverlapping(src, dst, len);  // Missing SAFETY comment
}
```

**Rationale**: Unsafe blocks are potential security vulnerabilities. Documentation ensures reviewers can verify soundness.

## 11. Violations & Enforcement

### What Happens If These Constraints Are Violated
- Code MUST be rejected (no exceptions)
- Security review MUST flag violations
- Witness Agent MUST block violating code
- Pull requests MUST be blocked

### Witness Agent Responsibilities
- Monitor all agents for Signal ID leakage
- Verify zeroization in all crypto operations
- Block unsafe patterns (cleartext IDs, polling, etc.)
- Verify trait abstractions for external dependencies
- Verify SAFETY comments on all unsafe blocks
- Read this Bead before every code review

## 11. Git Commit Standards (AI Agents)

### Co-Authorship Attribution (MANDATORY)
- ✅ **ALWAYS** include Co-authored-by trailer in commits authored by Claude
- ✅ **ALWAYS** use HEREDOC for proper formatting
- ✅ Format: `Co-authored-by: Claude <noreply@anthropic.com>`
- ✅ Position: At END of commit message with blank line before

### Example
```bash
git commit -m "$(cat <<'EOF'
Add vouch invalidation logic to trust model

- Voucher-flaggers invalidate their own vouches
- Prevents logical inconsistency (can't both trust and distrust)
- Aligns with fluid identity philosophy

Co-authored-by: Claude <noreply@anthropic.com>
EOF
)"
```

**See**: `.cursor/rules/git-standards.mdc` for complete git workflow

## 10. Bot Storage Constraints (SERVER SEIZURE THREAT)

### Critical Threat: Server Seizure

**Scenario**: Bot server is physically seized or compromised by adversary

**Current Risk with Default Presage SqliteStore**:
- Stores complete message history (all vetting conversations)
- Stores contact database (links to Signal IDs)
- Stores group metadata and conversation patterns
- Even encrypted, exposes relationship context and vetting details

### Message Persistence Violations (BLOCK)

**CRITICAL**: SqliteStore CANNOT be used for message storage or anything that would help identify bot users (members). Server seizure would expose the entire membership.

- ❌ **NEVER** persist message history to disk
- ❌ **NEVER** store vetting conversation content
- ❌ **NEVER** use default Presage SqliteStore (stores ALL messages and contacts)
- ❌ **NEVER** store invitation context or relationship reasons
- ❌ **NEVER** persist Signal IDs in database (even encrypted)
- ❌ **NEVER** maintain contact database on disk
- ❌ **NEVER** use ANY storage mechanism that links Signal IDs to group membership

### Correct Architecture: Minimal Custom Store

```rust
// ❌ FORBIDDEN - Default store
let store = SqliteStore::open_with_passphrase(db_path, passphrase, OnNewIdentity::Trust).await?;
// Problem: Stores messages, contacts, groups, metadata

// ✅ REQUIRED - Custom minimal store
pub struct StromaProtocolStore {
    // In-memory only (ephemeral)
    sessions: HashMap<ServiceId, Session>,
    pre_keys_cache: HashMap<u32, PreKey>,
    
    // Minimal encrypted file for restart recovery (~100KB)
    protocol_state_file: EncryptedProtocolState,
    passphrase: SecureString,
    
    // NO message history - vetting conversations never persisted
    // NO contact database - Signal IDs never on disk
    // NO conversation content - ephemeral only
}

impl presage::Store for StromaProtocolStore {
    // Implement ONLY protocol state requirements
    // Sessions, pre-keys, identity keys
    // NO message persistence methods
}
```

### What Gets Stored (Minimally)

**On Disk (Encrypted, ~100KB file):**
- Signal protocol state (sessions for encryption continuity)
- Pre-keys (for new conversations)
- Identity keys (bot's Signal identity)

**In Memory Only (Ephemeral):**
- Current vetting conversations (deleted after admission)
- Signal IDs (hashed immediately, zeroized)
- Message content (processed, never stored)

**NEVER Stored:**
- ❌ Message history
- ❌ Vetting conversation transcripts
- ❌ Contact database
- ❌ Invitation context ("Great activist from...")
- ❌ Relationship metadata

### Server Seizure Result (With Minimal Store)

**Adversary gets:**
- Small encrypted file (~100KB) with Signal protocol state
- Encrypted with operator-provided passphrase
- Contains only sessions and keys (no content)

**Adversary does NOT get:**
- ❌ Message content or history
- ❌ Vetting conversations
- ❌ Signal IDs (only hashed in Freenet contract)
- ❌ Relationship context or reasons
- ❌ Contact names or metadata

**This preserves anonymity even under server compromise.**

### Implementation Requirement

**Agent-Signal Task** (when integrating Presage):
1. DO NOT use presage-store-sqlite crate
2. Implement custom StromaProtocolStore
3. Implement presage::Store trait with minimal persistence
4. Encrypt protocol state file with operator passphrase
5. Test: Verify no messages persisted after conversations

**See**: `.beads/technology-stack.bead`, `.beads/poll-implementation-gastown.bead`

### Testing Requirements

**Must verify:**
- [ ] No message history in database after vetting
- [ ] No Signal IDs in any persistent storage
- [ ] Protocol state file is encrypted
- [ ] File size remains minimal (~100KB, not growing)
- [ ] Bot restart recovers sessions (encryption continuity)
- [ ] Server seizure simulation reveals no sensitive data

## 11. Persistence Security (RECIPROCAL PERSISTENCE NETWORK)

### Why Persistence Exists

**Core Problem**: Freenet data falls off if no peers are subscribed.

**Solution**: Bots replicate each other's **encrypted state chunks** so any bot can recover after crash.

**See**: `.beads/persistence-model.bead` for full architecture.

### Adversarial Peer Model (CRITICAL)

**ALL persistence peers are ADVERSARIES.** Zero trust.

| Assumption | Implication |
|------------|-------------|
| Peer may be malicious | Encrypt all chunks |
| Peer may refuse to return | 3 copies per chunk (any 1 of 3 works) |
| Peers may collude | Chunks encrypted; need ALL chunks + ACI key |
| Peer may be fake (Sybil) | **✅ Q8 COMPLETE**: PoW difficulty 18 (~30s registration) prevents Sybil attacks |
| Peer may delete chunks | **✅ Q9/Q13 COMPLETE**: Challenge-response SHA-256(nonce \|\| chunk_sample) verifies possession, <1ms verification |

### Persistence Security Violations (BLOCK)

- ❌ **NEVER** allow chunk owner to choose holders (collusion risk)
- ❌ **NEVER** store chunks unencrypted
- ❌ **NEVER** use single replica (need 3 copies per chunk for resilience)
- ❌ **NEVER** store per-chunk relationships in registry (scaling, attack surface)
- ❌ **NEVER** trust federation peers more (same adversarial model)
- ❌ **NEVER** conflate persistence discovery with federation discovery

### Correct Patterns

- ✅ **ALWAYS** encrypt with key derived from Signal ACI identity
- ✅ **ALWAYS** use 64KB chunks with 3 copies each (1 local + 2 remote)
- ✅ **ALWAYS** use deterministic holder selection per-chunk (rendezvous hashing)
- ✅ **ALWAYS** keep registry minimal (O(N) bot list, not per-chunk relationships)
- ✅ **ALWAYS** verify holders actually have chunks via challenge-response (Q9/Q13: SHA-256 proof, 1% spot check rate, <10ms latency)
- ✅ **ALWAYS** treat all persistence peers as adversaries
- ✅ **ALWAYS** use Signal protocol store as single cryptographic identity

### Sybil Resistance (Q8 - COMPLETE)

**Findings**: Combined defense strategy (PoW + Reputation + Capacity Verification) provides >90% fake bot detection within 7 days while maintaining <1% false positive rate.

**Implementation Requirements**:
- ✅ PoW difficulty 18 (~30s registration, ~60s on RPi 4)
- ✅ Minimum 100MB capacity verification
- ✅ 7-day reputation building period
- ✅ 30% success rate threshold for chunk holding eligibility
- ✅ Periodic capacity re-verification every 30 days

**Security Properties**:
- Prevents instant mass registration (PoW creates computational cost)
- Requires real storage infrastructure (100 GB for 1000 fake bots)
- Time barrier transforms attack from "register once" to "maintain infrastructure over time"
- Attack cost for 1000 fake bots: 8+ hours CPU + 100 GB storage + 7+ days uptime + operational responses

**See**: `docs/spike/q8/RESULTS.md` for complete analysis.

### Chunk Possession Verification (Q9 - COMPLETE)

**Findings**: Challenge-response protocol successfully verifies chunk possession without revealing content. Latency <1ms, content privacy preserved (99.6% of chunk remains private).

**Protocol Specification**:
```rust
// Challenge: SHA-256(nonce || chunk[offset..offset+length])
struct VerificationChallenge {
    nonce: [u8; 32],        // Random, prevents replay
    offset: u32,            // Random offset in chunk
    length: u32,            // Sample size (64 bytes)
    timestamp: u64,         // Freshness check (<1 hour)
}
// Challenge: 48 bytes, Response: 80 bytes, Total: 128 bytes
```

**Security Properties**:
- ✅ Possession proof: Holder must have actual bytes to compute correct hash
- ✅ Replay resistance: Nonce changes each challenge, old responses invalid
- ✅ Deletion detection: Missing chunk cannot respond, detected immediately
- ✅ Content privacy: Hash reveals nothing about plaintext (zero knowledge leak)
- ✅ Freshness: Timestamp window prevents stale proofs

**Verification Frequency**:
- Normal operation: Daily spot checks (low overhead)
- Before recovery: Verify all holders (critical path)
- New holder: Immediate verification (ensure initial storage)
- Failed verification: Retry 3x, then replace holder

**See**: `docs/spike/q9/RESULTS.md` for complete protocol specification.

### Fairness Enforcement (Q13 - COMPLETE)

**Findings**: 1% spot check rate achieves 100% detection of free-riders with 0% false positives, <10ms latency per verification.

**Verification Metrics**:
- Latency: ~1ms total (10µs challenge generation + 500µs holder response + 200µs verification)
- Detection rate: 100% (requirement: >95%)
- False positive rate: 0% (requirement: <1%)
- Content leakage: <1% (256 of 65536 bytes sampled)
- Overhead: 0.16ms per write (1% sample of 16 chunks)

**Enforcement Strategy**:
- **Phase 0**: Spot checks (1% sample), warn on failures, log suspicious holders
- **Phase 1+**: Reputation scoring, soft deprioritization of low-reputation holders (<95% success rate), hard exclusion after 10 consecutive failures

**Attack Resistance**:
- Replay attacks: BLOCKED (unique nonce per challenge)
- Guessing proofs: INFEASIBLE (2^-256 probability)
- Partial storage: PREVENTED (random offset, must store full chunk)
- Conspiring holders: TOLERATED (chunk exists somewhere, acceptable)
- Delay attacks: DETECTABLE (latency monitoring in Phase 1+)

**See**: `docs/spike/q13/RESULTS.md` for complete findings and implementation guidance.

### Separate Concerns: Security vs Fairness

**Chunk holders and fairness partners are DIFFERENT bots (by algorithm).**

```
Bot-A's perspective (500KB state = 8 chunks):
  FAIRNESS: I hold chunks FOR Bot-B, Bot-C, ... (~2x my state size)
  SECURITY: ~8-16 bots hold MY chunks (deterministic per-chunk)
  
  Chunk holders:
  - Assigned via rendezvous hashing per-chunk (not chosen by Bot-A)
  - Anyone CAN compute who holds whose chunks (public algorithm)
  - BUT: Chunks are ENCRYPTED (holder can't read content)
  - Need ALL chunks + ACI key to reconstruct (not just 2 of 3)
```

**Why deterministic is OK**: Knowing "Bot-X holds Bot-A's chunk[3]" doesn't help read encrypted data. Attack still requires compromising ALL chunk holders + ACI key.

### Write-Blocking (MANDATORY)

- ❌ **NEVER** write state in DEGRADED mode (lost holder, peers available)
- ✅ **ALWAYS** block writes until persistence confirmed
- ✅ **ALWAYS** restore holders before continuing

**See**: `.beads/persistence-model.bead` for state machine.

### Recovery Requires Signal Store Backup

**No separate keypair file needed.** The Signal protocol store IS the cryptographic identity.

- ❌ **NEVER** create a separate keypair file (use Signal ACI key)
- ❌ **NEVER** proceed without Signal store backup in operator docs
- ✅ **ALWAYS** warn operator: Signal store is ONLY recovery path
- ✅ **ALWAYS** document Signal store backup procedure prominently
- ✅ **ALWAYS** derive encryption keys from Signal ACI via HKDF

**See**: `.beads/contract-encryption.bead` for crypto details.

## Summary: The Eight Absolutes

1. **NEVER store Signal IDs in cleartext** - HMAC hash immediately, zeroize buffers
2. **NEVER persist message history** - Vetting conversations ephemeral only
3. **NEVER bypass ZK-proof verification** - All trust operations use STARKs
4. **NEVER add grace periods** - Ejection is immediate (no warnings)
5. **NEVER make Signal source of truth** - Freenet is authoritative
6. **NEVER restrict vouching to Validators** - ANY Member can vouch
7. **NEVER commit without Co-authored-by** - All AI-authored commits must attribute Claude
8. **NEVER trust persistence peers** - ALL peers are adversaries, encrypt everything

These constraints are IMMUTABLE and apply to ALL code, ALL agents, ALL phases (including federation in Phase 4+).

---
description: Freenet contract development patterns using ComposableState and summary-delta synchronization
globs: **/*contract*.rs,**/*freenet*.rs,**/*state*.rs
alwaysApply: false
---

# Freenet Contract Design Standards

## Overview

Freenet contracts are **WebAssembly (Wasm) code that defines how to merge conflicting states** across a decentralized network. Unlike traditional databases, Freenet achieves eventual consistency through **summary-delta synchronization** rather than consensus algorithms.

**References:**
- [freenet-scaffold](https://github.com/freenet/freenet-scaffold) - Contract development utilities
- [Understanding Delta-Sync](https://freenet.org/news/summary-delta-sync/) - Deep dive on synchronization approach
- [Freenet Manual](https://docs.freenet.org/components/contracts.html) - Official documentation

## Core Concepts

### Eventual Consistency via Merging
- Values stored under contract keys must be **mergeable** (order-independent combining)
- Merging must be a **commutative monoid** (same result regardless of merge order)
- No consensus algorithms (Paxos, Raft) - instead use deterministic merging
- Updates propagate through small-world network like a virus

### Summary-Delta Synchronization
**Two-step process to minimize data transfer:**

1. **Summary**: Each node generates compact representation of current state
2. **Delta**: Nodes exchange summaries to create minimal changes needed to sync

**Benefits:**
- Reduces bandwidth usage
- Scales efficiently in small-world topology
- No heavy coordination required
- Eventually consistent across all nodes

### ComposableState Trait
All contract state must implement the `ComposableState` trait:

```rust
pub trait ComposableState {
    type ParentState;
    type Summary;
    type Delta;
    type Parameters;
    
    fn verify(&self, parent: &Self::ParentState, params: &Self::Parameters) -> Result<(), String>;
    fn summarize(&self, parent: &Self::ParentState, params: &Self::Parameters) -> Self::Summary;
    fn delta(&self, parent: &Self::ParentState, params: &Self::Parameters, old: &Self::Summary) -> Option<Self::Delta>;
    fn apply_delta(&mut self, parent: &Self::ParentState, params: &Self::Parameters, delta: &Option<Self::Delta>) -> Result<(), String>;
}
```

## Stroma Contract Requirements

### Mergeable State Structures

#### ‚ùå NOT Mergeable (Avoid)
```rust
// ‚ùå BAD: Merkle Tree is not naturally mergeable
pub struct TrustNetworkState {
    members: MerkleTree<MemberHash>,  // Two different trees = conflict
    vouches: Vec<VouchProof>,         // Order matters in Vec
}
```

#### ‚úÖ Mergeable (Use These Patterns)
```rust
use std::collections::{BTreeSet, HashMap};

// ‚úÖ GOOD: Set-based membership (mergeable via union)
pub struct Members {
    active: BTreeSet<MemberHash>,
    removed: BTreeSet<MemberHash>,  // Tombstones for removed members
}

// ‚úÖ GOOD: Map-based vouching (mergeable via map union)
pub struct VouchGraph {
    // member -> set of vouchers
    vouches: HashMap<MemberHash, BTreeSet<MemberHash>>,
}
```

### Stroma-Specific Patterns

#### Pattern 1: Set-Based Membership with Tombstones
```rust
use freenet_scaffold::ComposableState;
use std::collections::BTreeSet;

#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub struct MemberSet {
    active: BTreeSet<MemberHash>,      // Current members
    removed: BTreeSet<MemberHash>,     // Tombstones (never re-add)
}

impl ComposableState for MemberSet {
    type ParentState = TrustNetworkState;
    type Summary = (BTreeSet<MemberHash>, BTreeSet<MemberHash>);
    type Delta = MemberSetDelta;
    type Parameters = Params;
    
    fn verify(&self, _parent: &Self::ParentState, _params: &Self::Parameters) -> Result<(), String> {
        // Verify invariants
        for member in &self.active {
            if self.removed.contains(member) {
                return Err(format!("Member {} in both active and removed sets", member));
            }
        }
        Ok(())
    }
    
    fn summarize(&self, _parent: &Self::ParentState, _params: &Self::Parameters) -> Self::Summary {
        (self.active.clone(), self.removed.clone())
    }
    
    fn delta(&self, _parent: &Self::ParentState, _params: &Self::Parameters, old: &Self::Summary) -> Option<Self::Delta> {
        let added: Vec<_> = self.active.difference(&old.0).cloned().collect();
        let removed: Vec<_> = self.removed.difference(&old.1).cloned().collect();
        
        if added.is_empty() && removed.is_empty() {
            None
        } else {
            Some(MemberSetDelta { added, removed })
        }
    }
    
    fn apply_delta(&mut self, _parent: &Self::ParentState, _params: &Self::Parameters, delta: &Option<Self::Delta>) -> Result<(), String> {
        if let Some(delta) = delta {
            for member in &delta.added {
                if !self.removed.contains(member) {
                    self.active.insert(*member);
                }
            }
            for member in &delta.removed {
                self.active.remove(member);
                self.removed.insert(*member);  // Add tombstone
            }
        }
        Ok(())
    }
}

#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub struct MemberSetDelta {
    added: Vec<MemberHash>,
    removed: Vec<MemberHash>,
}
```

#### Pattern 2: Vouch Graph with CRDT Semantics
```rust
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub struct VouchGraph {
    // member -> set of vouchers (mergeable via set union)
    vouches: HashMap<MemberHash, BTreeSet<MemberHash>>,
}

impl ComposableState for VouchGraph {
    type ParentState = TrustNetworkState;
    type Summary = HashMap<MemberHash, BTreeSet<MemberHash>>;
    type Delta = Vec<(MemberHash, MemberHash)>;  // (member, voucher) pairs to add
    type Parameters = Params;
    
    fn verify(&self, parent: &Self::ParentState, params: &Self::Parameters) -> Result<(), String> {
        // Verify all vouchers are active members
        for (member, vouchers) in &self.vouches {
            for voucher in vouchers {
                if !parent.members.active.contains(voucher) {
                    return Err(format!("Voucher {} is not an active member", voucher));
                }
            }
            
            // Verify member cannot vouch for themselves
            if vouchers.contains(member) {
                return Err(format!("Member {} cannot vouch for themselves", member));
            }
        }
        Ok(())
    }
    
    fn summarize(&self, _parent: &Self::ParentState, _params: &Self::Parameters) -> Self::Summary {
        self.vouches.clone()
    }
    
    fn delta(&self, _parent: &Self::ParentState, _params: &Self::Parameters, old: &Self::Summary) -> Option<Self::Delta> {
        let mut changes = Vec::new();
        
        for (member, vouchers) in &self.vouches {
            let old_vouchers = old.get(member).cloned().unwrap_or_default();
            for voucher in vouchers.difference(&old_vouchers) {
                changes.push((*member, *voucher));
            }
        }
        
        if changes.is_empty() { None } else { Some(changes) }
    }
    
    fn apply_delta(&mut self, _parent: &Self::ParentState, _params: &Self::Parameters, delta: &Option<Self::Delta>) -> Result<(), String> {
        if let Some(vouch_pairs) = delta {
            for (member, voucher) in vouch_pairs {
                self.vouches.entry(*member).or_default().insert(*voucher);
            }
        }
        Ok(())
    }
}

impl VouchGraph {
    // Helper: Count vouches for a member
    pub fn count_for(&self, member: &MemberHash) -> usize {
        self.vouches.get(member).map(|s| s.len()).unwrap_or(0)
    }
}
```

#### Pattern 3: Last-Write-Wins Config with Version
```rust
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub struct GroupConfigV1 {
    config_change_threshold: f32,
    min_intersection_density: f32,
    min_vouch_threshold: usize,
    version: u64,           // Incremented on each change
    last_updated: Timestamp,
}

impl ComposableState for GroupConfigV1 {
    type Summary = (u64, Timestamp);
    type Delta = Option<GroupConfigV1>;
    type Parameters = Params;
    
    fn verify(&self, _parent: &Self::ParentState, _params: &Self::Parameters) -> Result<(), String> {
        // Validate config values are in acceptable ranges
        if self.config_change_threshold < 0.5 || self.config_change_threshold > 1.0 {
            return Err("config_change_threshold must be between 0.5 and 1.0".into());
        }
        if self.min_vouch_threshold < 2 {
            return Err("min_vouch_threshold must be >= 2".into());
        }
        Ok(())
    }
    
    fn summarize(&self, _parent: &Self::ParentState, _params: &Self::Parameters) -> Self::Summary {
        (self.version, self.last_updated)
    }
    
    fn delta(&self, _parent: &Self::ParentState, _params: &Self::Parameters, old: &Self::Summary) -> Option<Self::Delta> {
        if self.version > old.0 {
            Some(self.clone())
        } else {
            None
        }
    }
    
    fn apply_delta(&mut self, _parent: &Self::ParentState, _params: &Self::Parameters, delta: &Option<Self::Delta>) -> Result<(), String> {
        if let Some(new_config) = delta {
            // Last-Write-Wins: Keep config with higher version
            if new_config.version > self.version {
                *self = new_config.clone();
            }
        }
        Ok(())
    }
}
```

#### Pattern 4: Main State with #[composable] Macro
```rust
use freenet_scaffold_macro::composable;

#[composable]
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub struct TrustNetworkState {
    // All fields must implement ComposableState
    members: MemberSet,
    vouches: VouchGraph,
    flags: FlagGraph,      // Similar to VouchGraph
    config: GroupConfigV1,
    
    // Federation hooks (Phase 4+, disabled in MVP)
    #[cfg(feature = "federation")]
    federation_contracts: FederationSet,
}

// The #[composable] macro auto-generates:
// - TrustNetworkStateSummary
// - TrustNetworkStateDelta
// - ComposableState implementation for TrustNetworkState
```

## Merkle Tree Generation (On-Demand)

### Key Insight
**Don't store Merkle Trees** - generate them on demand for ZK-proof verification.

```rust
impl TrustNetworkState {
    /// Generate Merkle Tree from current member set for ZK-proof verification
    pub fn generate_merkle_tree(&self) -> MerkleTree<MemberHash> {
        // Sort members for deterministic tree
        let sorted: Vec<_> = self.members.active.iter().cloned().collect();
        MerkleTree::from_leaves(sorted)
    }
    
    /// Get Merkle root for ZK-proof verification
    pub fn merkle_root(&self) -> Hash {
        self.generate_merkle_tree().root()
    }
    
    /// Verify member is in tree (for ZK-proof verification)
    pub fn verify_membership(&self, member: &MemberHash) -> bool {
        self.members.active.contains(member)
    }
}
```

## ZK-Proof Integration Strategy

### Understanding the Flow

**Initial Assumption (WRONG)**: Store ZK-proofs in contract state

**Reality (CORRECT)**: ZK-proofs validate state transitions, then are discarded

**Revised Flow:**
```
1. Bot generates STARK proof client-side:
   - Prove: Voucher_A ‚àà members AND Voucher_B ‚àà members AND A ‚â† B
   - Generate Merkle Tree from current member set
   - Create Merkle proofs for voucher_A and voucher_B
   - Generate STARK proof of these properties

2. Bot submits state update to Freenet:
   - New state: Add member X, add vouches (X, A) and (X, B)
   - Attach STARK proof (optional, depends on contract design)

3. Contract verify() validates:
   - Voucher_A is in members.active
   - Voucher_B is in members.active
   - A ‚â† B
   - X is NOT in members.active (new member)
   - [Optional] STARK proof is valid (if attached)

4. If valid, contract merges update:
   - Add X to members.active
   - Add vouches to vouches graph

5. Proof is discarded (not stored permanently)
```

### Two Possible Approaches

#### **Approach 1: Client-Side Verification Only**
```rust
impl ComposableState for TrustNetworkState {
    fn verify(&self, _parent: &Self::ParentState, params: &Self::Parameters) -> Result<(), String> {
        // Verify basic invariants (fast)
        // Do NOT verify ZK-proofs (too expensive in contract)
        
        for member in &self.members.active {
            let vouch_count = self.vouches.count_for(member);
            if vouch_count < params.min_vouch_threshold {
                return Err(format!("Member has only {} vouches (need {})", vouch_count, params.min_vouch_threshold));
            }
        }
        
        Ok(())
    }
}

// Bot verifies ZK-proofs client-side before submitting updates
// Contract only validates basic invariants
```

**Pros**: Fast, simple
**Cons**: Relies on bot validation (less trustless)

#### **Approach 2: Contract-Side Verification** (More Trustless)
```rust
impl ComposableState for TrustNetworkState {
    fn verify(&self, _parent: &Self::ParentState, params: &Self::Parameters) -> Result<(), String> {
        // Verify basic invariants + ZK-proofs
        
        // For each new member, verify attached STARK proof
        for member in &self.members.active {
            if let Some(proof) = self.pending_proofs.get(member) {
                // Generate Merkle Tree from current state
                let merkle_root = self.merkle_root();
                
                // Verify STARK proof
                let valid = winterfell::verify_proof(proof, &merkle_root)?;
                if !valid {
                    return Err(format!("Invalid STARK proof for member {}", member));
                }
            }
        }
        
        Ok(())
    }
}

// Store proofs temporarily in pending_proofs field
// Remove after verification (ephemeral)
```

**Pros**: More trustless, contract enforces ZK-proofs
**Cons**: Performance concern (STARK verification in Wasm)

### **Recommendation for Stroma**
Start with **Approach 1** (client-side verification) for MVP. Reason:
- Simpler contract design
- Faster verification
- Bot is trusted in single-group scenario
- Can add contract-side verification in Phase 4 if needed for federation

## Contract State Design for Stroma

### Complete Mergeable Schema

```rust
use freenet_scaffold_macro::composable;
use std::collections::{BTreeSet, HashMap};

// === Individual Composable Types ===

#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub struct MemberSet {
    active: BTreeSet<MemberHash>,
    removed: BTreeSet<MemberHash>,  // Tombstones
}

#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub struct VouchGraph {
    // member -> set of vouchers
    vouches: HashMap<MemberHash, BTreeSet<MemberHash>>,
}

#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub struct FlagGraph {
    // member -> set of flaggers
    flags: HashMap<MemberHash, BTreeSet<MemberHash>>,
}

#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub struct GroupConfigV1 {
    config_change_threshold: f32,
    min_intersection_density: f32,
    min_vouch_threshold: usize,
    validator_percentile: u32,
    version: u64,           // For Last-Write-Wins
    last_updated: Timestamp,
}

// === Main State (Auto-composed) ===

#[composable]
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub struct TrustNetworkState {
    members: MemberSet,
    vouches: VouchGraph,
    flags: FlagGraph,
    config: GroupConfigV1,
    
    // Federation hooks (Phase 4+, disabled in MVP)
    #[cfg(feature = "federation")]
    federation_contracts: FederationSet,
    
    #[cfg(feature = "federation")]
    validator_anchors: BloomFilter,
}

// #[composable] macro auto-generates:
// - TrustNetworkStateSummary struct
// - TrustNetworkStateDelta struct
// - ComposableState implementation for TrustNetworkState
```

### Helper Methods (Not Part of Contract State)

```rust
impl TrustNetworkState {
    /// Generate Merkle Tree on demand for ZK-proof verification
    pub fn generate_merkle_tree(&self) -> MerkleTree<MemberHash> {
        let sorted: Vec<_> = self.members.active.iter().cloned().collect();
        MerkleTree::from_leaves(sorted)
    }
    
    /// Get Merkle root for ZK-proof verification
    pub fn merkle_root(&self) -> Hash {
        self.generate_merkle_tree().root()
    }
    
    /// Calculate effective state considering voucher-flaggers
    /// 
    /// Critical: If a voucher flags a member, that vouch is invalidated.
    /// You can't simultaneously trust and distrust someone (logical inconsistency).
    pub fn calculate_effective_state(&self, member: &MemberHash) -> (usize, i32) {
        let vouchers = self.vouches.get(member).cloned().unwrap_or_default();
        let flaggers = self.flags.get(member).cloned().unwrap_or_default();
        
        // Find vouchers who also flagged (contradictory - invalidates their vouch)
        let voucher_flaggers: HashSet<_> = vouchers
            .intersection(&flaggers)
            .collect();
        
        // Effective vouches = total vouches - voucher_flaggers
        let effective_vouches = vouchers.len() - voucher_flaggers.len();
        
        // Regular flags = flags from non-vouchers
        let regular_flags = flaggers.len() - voucher_flaggers.len();
        
        // Standing = effective_vouches - regular_flags
        let standing = effective_vouches as i32 - regular_flags as i32;
        
        (effective_vouches, standing)
    }
    
    /// Calculate trust standing for a member (using effective vouches)
    pub fn calculate_standing(&self, member: &MemberHash) -> i32 {
        let (_, standing) = self.calculate_effective_state(member);
        standing
    }
    
    /// Check if member should be ejected (two independent triggers)
    pub fn should_eject(&self, member: &MemberHash) -> bool {
        let (effective_vouches, standing) = self.calculate_effective_state(member);
        
        // Trigger 1: Standing < 0 (too many regular flags)
        if standing < 0 {
            return true;
        }
        
        // Trigger 2: Effective vouches < min_vouch_threshold (includes voucher-flagger invalidation)
        if effective_vouches < self.config.min_vouch_threshold {
            return true;
        }
        
        false
    }
    
    /// Check if member is fully vetted (ready for admission)
    pub fn is_vetted(&self, member: &MemberHash) -> bool {
        let (effective_vouches, standing) = self.calculate_effective_state(member);
        
        effective_vouches >= self.config.min_vouch_threshold && standing >= 0
    }
    
    /// Calculate mesh density (raw percentage)
    /// 
    /// Returns percentage of actual vouches vs maximum possible (full mesh).
    pub fn calculate_mesh_density(&self) -> f32 {
        let n = self.members.active.len();
        if n < 2 {
            return 0.0;
        }
        
        // Count total vouches in the network
        let total_vouches: usize = self.vouches.vouches.values()
            .map(|v| v.len())
            .sum();
        
        // Max possible vouches = n * (n - 1) for directed graph
        let max_possible = n * (n - 1);
        
        (total_vouches as f32 / max_possible as f32) * 100.0
    }
    
    /// Calculate mesh health score (0-100, peaks at optimal 30-60% density)
    /// 
    /// Key UX Principle: Makes 30-60% density feel like "100%" achievement,
    /// rather than showing raw percentage that pulls toward 100% mesh.
    /// 
    /// A 100% mesh (everyone vouching everyone) isn't healthier - it creates
    /// excessive interdependence. The optimal range balances resilience and efficiency.
    pub fn calculate_mesh_health_score(&self) -> u8 {
        let density = self.calculate_mesh_density() / 100.0; // Convert to 0.0-1.0
        
        match density {
            d if d < 0.10 => (d * 300.0) as u8,                    // 0-30: Building
            d if d >= 0.10 && d < 0.30 => (d * 266.0 + 20.0) as u8, // 30-100: Developing
            d if d >= 0.30 && d <= 0.60 => 100,                    // 100: OPTIMAL RANGE
            d if d > 0.60 && d <= 0.90 => (130.0 - d * 50.0) as u8, // 100-40: Over-connected
            d if d > 0.90 => 30,                                   // 30: Saturated
            _ => 50,
        }
    }
    
    /// Get mesh health status band
    pub fn mesh_health_status(&self) -> MeshHealthStatus {
        let density = self.calculate_mesh_density();
        
        match density {
            d if d < 10.0 => MeshHealthStatus::Fragile,
            d if d >= 10.0 && d < 30.0 => MeshHealthStatus::Building,
            d if d >= 30.0 && d <= 60.0 => MeshHealthStatus::Optimal,
            d if d > 60.0 && d <= 90.0 => MeshHealthStatus::Dense,
            _ => MeshHealthStatus::Saturated,
        }
    }
}

/// Mesh health status bands for UX display
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum MeshHealthStatus {
    Fragile,    // üî¥ 0-10%: Minimal connections, high risk
    Building,   // üü° 10-30%: Developing toward optimal
    Optimal,    // üü¢ 30-60%: Balanced resilience - THE GOAL
    Dense,      // üü° 60-90%: Over-connected, may limit growth
    Saturated,  // üî¥ 90-100%: Excessive interdependence
}

impl MeshHealthStatus {
    pub fn emoji(&self) -> &'static str {
        match self {
            Self::Fragile => "üî¥",
            Self::Building => "üü°",
            Self::Optimal => "üü¢",
            Self::Dense => "üü°",
            Self::Saturated => "üî¥",
        }
    }
    
    pub fn label(&self) -> &'static str {
        match self {
            Self::Fragile => "FRAGILE",
            Self::Building => "BUILDING",
            Self::Optimal => "OPTIMAL",
            Self::Dense => "DENSE",
            Self::Saturated => "SATURATED",
        }
    }
    
    pub fn description(&self) -> &'static str {
        match self {
            Self::Fragile => "Minimal connections, high risk",
            Self::Building => "Developing toward optimal",
            Self::Optimal => "Balanced resilience - THE GOAL",
            Self::Dense => "Over-connected, may limit growth",
            Self::Saturated => "Everyone trusts everyone (excessive interdependence)",
        }
    }
}
```

## Contract Deployment

### Using freenet-scaffold

```toml
# Cargo.toml
[dependencies]
freenet-scaffold = "0.2"
freenet-scaffold-macro = "0.2"
serde = { version = "1.0", features = ["derive"] }

[lib]
crate-type = ["cdylib"]  # For Wasm compilation
```

### Build Wasm Contract
```bash
# Build contract to Wasm
cargo build --target wasm32-unknown-unknown --release

# Deploy to freenet-core
freenet put-contract \
  --code target/wasm32-unknown-unknown/release/stroma_contract.wasm \
  --state initial_state.json
```

## State Stream Monitoring (Bot-Side)

### Subscribe to State Changes
```rust
async fn monitor_state_stream(freenet: &FreenetClient) -> Result<(), Error> {
    // Subscribe to contract state changes (real-time, not polling)
    let mut stream = freenet.subscribe_to_contract(contract_key).await?;
    
    while let Some(state_change) = stream.next().await {
        match state_change {
            StateUpdate::MembersChanged { added, removed } => {
                // Sync Signal group with Freenet state
                for member in added {
                    signal.add_member(member).await?;
                }
                for member in removed {
                    signal.remove_member(member).await?;
                }
            }
            StateUpdate::ConfigChanged { new_config } => {
                // Update local config cache
                update_local_config(new_config).await?;
            }
        }
    }
    
    Ok(())
}
```

## Outstanding Questions (CRITICAL - Must Address in Spike Week)

### Question 1: ZK-Proof Verification Performance
**Question**: Can we verify STARK proofs in contract `verify()` method without performance issues?

**Impact**: Determines if we use Approach 1 (client-side) or Approach 2 (contract-side)

**Test in Spike Week**:
- Compile winterfell to Wasm (if possible)
- Measure verification time in Wasm context
- Target: < 100ms per proof
- If too slow, use Approach 1

### Question 2: Proof Storage Strategy
**Question**: Should we store proofs in contract state or just outcomes?

**Options**:
- **A**: Store proofs temporarily (verified once, then removed)
- **B**: Store proofs permanently (audit trail)
- **C**: Don't store proofs at all (trust bot verification)

**Impact**: Storage costs, audit trail, trustlessness

**Recommendation**: Start with **Option C** for MVP, evaluate Options A/B for federation

### Question 3: On-Demand Merkle Tree Performance
**Question**: How expensive is generating Merkle Tree from BTreeSet on every ZK-proof verification?

**Impact**: May need to cache Merkle root or pre-compute tree

**Test in Spike Week**:
- Benchmark Merkle Tree generation from set
- Test with 100, 500, 1000 members
- If too slow, cache Merkle root and invalidate on member changes

### Question 4: Conflict Resolution Semantics
**Question**: How does Freenet handle conflicts when two nodes submit incompatible updates?

**Example**:
- Node A: Add member X with vouches (A, B)
- Node B: Remove member A (X's voucher)
- These conflict - how does Freenet resolve?

**Impact**: May need causal ordering or vector clocks

**Test in Spike Week**:
- Create two divergent states
- Attempt to merge them
- Observe Freenet's conflict resolution
- Document behavior

### Question 5: Custom Validation Beyond ComposableState
**Question**: Can we add custom validation logic beyond ComposableState trait?

**Use Case**: Complex invariants like "every member must have >= 2 vouches from different validators"

**Test in Spike Week**:
- Review freenet-core contract API
- Check if there's a separate validation hook
- Determine if `verify()` is sufficient

## Best Practices

### Field Order Matters
From freenet-scaffold docs:
> "Ensure that fields are ordered such that any field depending on another appears after it."

**For Stroma**:
```rust
#[composable]
pub struct TrustNetworkState {
    config: GroupConfigV1,    // First (no dependencies)
    members: MemberSet,        // Second (depends on config)
    vouches: VouchGraph,       // Third (depends on members)
    flags: FlagGraph,          // Fourth (depends on members)
}
```

### Tombstones for Deletions
Always use tombstones (grow-only sets) rather than actual deletions:

```rust
// ‚úÖ GOOD: Tombstone prevents re-addition
pub struct MemberSet {
    active: BTreeSet<MemberHash>,
    removed: BTreeSet<MemberHash>,  // Once removed, never re-add
}

// ‚ùå BAD: Actual deletion allows re-addition
pub struct MemberSet {
    active: BTreeSet<MemberHash>,  // Just remove from set
}
```

### Testing Merge Semantics
Always test that merging is commutative:

```rust
#[test]
fn test_merge_commutativity() {
    let state_a = create_state_with_member_x();
    let state_b = create_state_with_member_y();
    
    // Merge A into B
    let mut merged_ab = state_a.clone();
    merged_ab.merge(&state_b);
    
    // Merge B into A (reversed order)
    let mut merged_ba = state_b.clone();
    merged_ba.merge(&state_a);
    
    // Must be identical regardless of merge order
    assert_eq!(merged_ab, merged_ba);
}
```

## Integration with Bot Logic

### Bot Responsibilities
1. **Generate ZK-Proofs**: Client-side before submitting updates
2. **Validate State**: Check Freenet state before Signal actions
3. **Submit Updates**: Send well-formed state updates to Freenet
4. **Monitor Stream**: React to Freenet state changes in real-time
5. **Sync Signal**: Keep Signal group in sync with Freenet state

### Contract Responsibilities
1. **Merge States**: Combine divergent states deterministically
2. **Validate Invariants**: Enforce vouch count, standing thresholds
3. **Propagate Updates**: Spread through small-world network
4. **Provide Stream**: Emit state changes for bot monitoring

## Summary: Key Takeaways

1. **Freenet contracts define merge logic**, not just store data
2. **ComposableState trait** is mandatory for all state fields
3. **Set-based structures** (BTreeSet, HashMap) are naturally mergeable
4. **Merkle Trees** generated on demand, not stored as primary state
5. **ZK-Proofs** validate transitions, not stored permanently (in MVP)
6. **Summary-delta sync** minimizes bandwidth and enables efficient eventual consistency
7. **Commutative merging** is critical - test thoroughly
8. **Outstanding questions** MUST be answered in Spike Week (Day 1-2)

## References

- [freenet-scaffold GitHub](https://github.com/freenet/freenet-scaffold)
- [freenet-core GitHub](https://github.com/freenet/freenet-core)
- [Understanding Delta-Sync](https://freenet.org/news/summary-delta-sync/)
- [Freenet Manual - Contracts](https://docs.freenet.org/components/contracts.html)
- [CRDT Resources](https://crdt.tech/) - Similar merge semantics

---
description: Freenet contract development patterns using ComposableState and summary-delta synchronization
globs: **/*contract*.rs,**/*freenet*.rs,**/*state*.rs
alwaysApply: false
---

# Freenet Contract Design Standards

## Overview

Freenet contracts are **WebAssembly (Wasm) code that defines how to merge conflicting states** across a decentralized network. Unlike traditional databases, Freenet achieves eventual consistency through **summary-delta synchronization** rather than consensus algorithms.

**References:**
- [freenet-stdlib](https://docs.rs/freenet-stdlib) - ContractInterface trait for Wasm contracts
- [freenet crate](https://docs.rs/freenet) - Node embedding (SimNetwork for testing, NodeConfig for production)
- [Understanding Delta-Sync](https://freenet.org/news/summary-delta-sync/) - Deep dive on synchronization approach
- [Freenet Manual](https://docs.freenet.org/components/contracts.html) - Official documentation

**Note**: `freenet-scaffold` is outdated. Use `freenet-stdlib` for contracts and `freenet` for node embedding.

## Core Concepts

### Eventual Consistency via Merging
- Values stored under contract keys must be **mergeable** (order-independent combining)
- Merging must be a **commutative monoid** (same result regardless of merge order)
- No consensus algorithms (Paxos, Raft) - instead use deterministic merging
- Updates propagate through small-world network like a virus

### Summary-Delta Synchronization
**Two-step process to minimize data transfer:**

1. **Summary**: Each node generates compact representation of current state
2. **Delta**: Nodes exchange summaries to create minimal changes needed to sync

**Benefits:**
- Reduces bandwidth usage
- Scales efficiently in small-world topology
- No heavy coordination required
- Eventually consistent across all nodes

### ContractInterface Trait (freenet-stdlib)
All Freenet contracts must implement the `ContractInterface` trait:

```rust
pub trait ContractInterface {
    fn validate_state(
        parameters: Parameters<'static>,
        state: State<'static>,
        related: RelatedContracts<'static>,
    ) -> Result<ValidateResult, ContractError>;
    
    fn update_state(
        parameters: Parameters<'static>,
        state: State<'static>,
        data: Vec<UpdateData<'static>>,
    ) -> Result<UpdateModification<'static>, ContractError>;
    
    fn summarize_state(
        parameters: Parameters<'static>,
        state: State<'static>,
    ) -> Result<StateSummary<'static>, ContractError>;
    
    fn get_state_delta(
        parameters: Parameters<'static>,
        state: State<'static>,
        summary: StateSummary<'static>,
    ) -> Result<StateDelta<'static>, ContractError>;
}
```

**Critical Requirement** (from Freenet docs):
> "Implementations must ensure that state delta updates are commutative.
>  When applying multiple delta updates to a state, the order in which these
>  updates are applied should not affect the final state."

**Q1 Validated**: Use set-based state (BTreeSet) with tombstones for commutativity.

## Stroma Contract Requirements

### Mergeable State Structures

#### ‚ùå NOT Mergeable (Avoid)
```rust
// ‚ùå BAD: Merkle Tree is not naturally mergeable
pub struct TrustNetworkState {
    members: MerkleTree<MemberHash>,  // Two different trees = conflict
    vouches: Vec<VouchProof>,         // Order matters in Vec
}
```

#### ‚úÖ Mergeable (Use These Patterns)
```rust
use std::collections::{BTreeSet, HashMap};

// ‚úÖ GOOD: Set-based membership (mergeable via union)
pub struct Members {
    active: BTreeSet<MemberHash>,
    removed: BTreeSet<MemberHash>,  // Tombstones for removed members
}

// ‚úÖ GOOD: Map-based vouching (mergeable via map union)
pub struct VouchGraph {
    // member -> set of vouchers
    vouches: HashMap<MemberHash, BTreeSet<MemberHash>>,
}
```

### Stroma-Specific Patterns

#### Pattern 1: Set-Based Membership with Tombstones
```rust
use freenet_stdlib::prelude::*;
use std::collections::BTreeSet;
use serde::{Serialize, Deserialize};

#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub struct MemberSet {
    active: BTreeSet<MemberHash>,      // Current members
    ejected: BTreeSet<MemberHash>,     // Ejected (can return with new vouches)
}

impl MemberSet {
    fn verify(&self) -> Result<(), String> {
        // Verify invariants
        for member in &self.active {
            if self.ejected.contains(member) {
                return Err(format!("Member {} in both active and ejected sets", member));
            }
        }
        Ok(())
    }
    
    fn summarize(&self, _parent: &Self::ParentState, _params: &Self::Parameters) -> Self::Summary {
        (self.active.clone(), self.removed.clone())
    }
    
    fn delta(&self, _parent: &Self::ParentState, _params: &Self::Parameters, old: &Self::Summary) -> Option<Self::Delta> {
        let added: Vec<_> = self.active.difference(&old.0).cloned().collect();
        let removed: Vec<_> = self.removed.difference(&old.1).cloned().collect();
        
        if added.is_empty() && removed.is_empty() {
            None
        } else {
            Some(MemberSetDelta { added, removed })
        }
    }
    
    fn apply_delta(&mut self, _parent: &Self::ParentState, _params: &Self::Parameters, delta: &Option<Self::Delta>) -> Result<(), String> {
        if let Some(delta) = delta {
            for member in &delta.added {
                if !self.removed.contains(member) {
                    self.active.insert(*member);
                }
            }
            for member in &delta.removed {
                self.active.remove(member);
                self.removed.insert(*member);  // Add tombstone
            }
        }
        Ok(())
    }
}

#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub struct MemberSetDelta {
    added: Vec<MemberHash>,
    removed: Vec<MemberHash>,
}
```

#### Pattern 2: Vouch Graph with CRDT Semantics
```rust
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub struct VouchGraph {
    // member -> set of vouchers (mergeable via set union)
    vouches: HashMap<MemberHash, BTreeSet<MemberHash>>,
}

impl ComposableState for VouchGraph {
    type ParentState = TrustNetworkState;
    type Summary = HashMap<MemberHash, BTreeSet<MemberHash>>;
    type Delta = Vec<(MemberHash, MemberHash)>;  // (member, voucher) pairs to add
    type Parameters = Params;
    
    fn verify(&self, parent: &Self::ParentState, params: &Self::Parameters) -> Result<(), String> {
        // Verify all vouchers are active members
        for (member, vouchers) in &self.vouches {
            for voucher in vouchers {
                if !parent.members.active.contains(voucher) {
                    return Err(format!("Voucher {} is not an active member", voucher));
                }
            }
            
            // Verify member cannot vouch for themselves
            if vouchers.contains(member) {
                return Err(format!("Member {} cannot vouch for themselves", member));
            }
        }
        Ok(())
    }
    
    fn summarize(&self, _parent: &Self::ParentState, _params: &Self::Parameters) -> Self::Summary {
        self.vouches.clone()
    }
    
    fn delta(&self, _parent: &Self::ParentState, _params: &Self::Parameters, old: &Self::Summary) -> Option<Self::Delta> {
        let mut changes = Vec::new();
        
        for (member, vouchers) in &self.vouches {
            let old_vouchers = old.get(member).cloned().unwrap_or_default();
            for voucher in vouchers.difference(&old_vouchers) {
                changes.push((*member, *voucher));
            }
        }
        
        if changes.is_empty() { None } else { Some(changes) }
    }
    
    fn apply_delta(&mut self, _parent: &Self::ParentState, _params: &Self::Parameters, delta: &Option<Self::Delta>) -> Result<(), String> {
        if let Some(vouch_pairs) = delta {
            for (member, voucher) in vouch_pairs {
                self.vouches.entry(*member).or_default().insert(*voucher);
            }
        }
        Ok(())
    }
}

impl VouchGraph {
    // Helper: Count vouches for a member
    pub fn count_for(&self, member: &MemberHash) -> usize {
        self.vouches.get(member).map(|s| s.len()).unwrap_or(0)
    }
}
```

#### Pattern 3: Last-Write-Wins Config with Version
```rust
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub struct GroupConfigV1 {
    config_change_threshold: f32,
    min_intersection_density: f32,
    min_vouch_threshold: usize,
    version: u64,           // Incremented on each change
    last_updated: Timestamp,
}

impl ComposableState for GroupConfigV1 {
    type Summary = (u64, Timestamp);
    type Delta = Option<GroupConfigV1>;
    type Parameters = Params;
    
    fn verify(&self, _parent: &Self::ParentState, _params: &Self::Parameters) -> Result<(), String> {
        // Validate config values are in acceptable ranges
        if self.config_change_threshold < 0.5 || self.config_change_threshold > 1.0 {
            return Err("config_change_threshold must be between 0.5 and 1.0".into());
        }
        if self.min_vouch_threshold < 2 {
            return Err("min_vouch_threshold must be >= 2".into());
        }
        Ok(())
    }
    
    fn summarize(&self, _parent: &Self::ParentState, _params: &Self::Parameters) -> Self::Summary {
        (self.version, self.last_updated)
    }
    
    fn delta(&self, _parent: &Self::ParentState, _params: &Self::Parameters, old: &Self::Summary) -> Option<Self::Delta> {
        if self.version > old.0 {
            Some(self.clone())
        } else {
            None
        }
    }
    
    fn apply_delta(&mut self, _parent: &Self::ParentState, _params: &Self::Parameters, delta: &Option<Self::Delta>) -> Result<(), String> {
        if let Some(new_config) = delta {
            // Last-Write-Wins: Keep config with higher version
            if new_config.version > self.version {
                *self = new_config.clone();
            }
        }
        Ok(())
    }
}
```

#### Pattern 4: Main State Structure
```rust
use freenet_stdlib::prelude::*;
use serde::{Serialize, Deserialize};

#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub struct TrustNetworkState {
    // Core trust data
    members: BTreeSet<MemberHash>,
    ejected: BTreeSet<MemberHash>,
    vouches: HashMap<MemberHash, HashSet<MemberHash>>,
    flags: HashMap<MemberHash, HashSet<MemberHash>>,
    config: GroupConfigV1,
    
    // Schema version for migration
    schema_version: u64,
    
    // Federation hooks (Phase 4+, disabled in MVP)
    #[serde(default)]
    federation_contracts: Vec<ContractHash>,
}

// Implement ContractInterface trait from freenet-stdlib
impl ContractInterface for StromaContract {
    fn validate_state(state: &[u8]) -> Result<ValidateResult, ContractError> {
        let trust_state = TrustNetworkState::from_bytes(state)?;
        trust_state.verify()?;
        Ok(ValidateResult::Valid)
    }
    
    fn update_state(state: &mut [u8], delta: &[u8]) -> Result<UpdateResult, ContractError> {
        // ... apply delta commutatively
    }
}
```

## Merkle Tree Generation (On-Demand)

### Key Insight
**Don't store Merkle Trees** - generate them on demand for ZK-proof verification.

```rust
impl TrustNetworkState {
    /// Generate Merkle Tree from current member set for ZK-proof verification
    pub fn generate_merkle_tree(&self) -> MerkleTree<MemberHash> {
        // Sort members for deterministic tree
        let sorted: Vec<_> = self.members.active.iter().cloned().collect();
        MerkleTree::from_leaves(sorted)
    }
    
    /// Get Merkle root for ZK-proof verification
    pub fn merkle_root(&self) -> Hash {
        self.generate_merkle_tree().root()
    }
    
    /// Verify member is in tree (for ZK-proof verification)
    pub fn verify_membership(&self, member: &MemberHash) -> bool {
        self.members.active.contains(member)
    }
}
```

## ZK-Proof Integration Strategy

### Understanding the Flow

**Initial Assumption (WRONG)**: Store ZK-proofs in contract state

**Reality (CORRECT)**: ZK-proofs validate state transitions, then are discarded

**Revised Flow:**
```
1. Bot generates STARK proof client-side:
   - Prove: Voucher_A ‚àà members AND Voucher_B ‚àà members AND A ‚â† B
   - Generate Merkle Tree from current member set
   - Create Merkle proofs for voucher_A and voucher_B
   - Generate STARK proof of these properties

2. Bot submits state update to Freenet:
   - New state: Add member X, add vouches (X, A) and (X, B)
   - Attach STARK proof (optional, depends on contract design)

3. Contract verify() validates:
   - Voucher_A is in members.active
   - Voucher_B is in members.active
   - A ‚â† B
   - X is NOT in members.active (new member)
   - [Optional] STARK proof is valid (if attached)

4. If valid, contract merges update:
   - Add X to members.active
   - Add vouches to vouches graph

5. Proof is discarded (not stored permanently)
```

### Two Possible Approaches

#### **Approach 1: Client-Side Verification Only**
```rust
impl ComposableState for TrustNetworkState {
    fn verify(&self, _parent: &Self::ParentState, params: &Self::Parameters) -> Result<(), String> {
        // Verify basic invariants (fast)
        // Do NOT verify ZK-proofs (too expensive in contract)
        
        for member in &self.members.active {
            let vouch_count = self.vouches.count_for(member);
            if vouch_count < params.min_vouch_threshold {
                return Err(format!("Member has only {} vouches (need {})", vouch_count, params.min_vouch_threshold));
            }
        }
        
        Ok(())
    }
}

// Bot verifies ZK-proofs client-side before submitting updates
// Contract only validates basic invariants
```

**Pros**: Fast, simple
**Cons**: Relies on bot validation (less trustless)

#### **Approach 2: Contract-Side Verification** (More Trustless)
```rust
impl ComposableState for TrustNetworkState {
    fn verify(&self, _parent: &Self::ParentState, params: &Self::Parameters) -> Result<(), String> {
        // Verify basic invariants + ZK-proofs
        
        // For each new member, verify attached STARK proof
        for member in &self.members.active {
            if let Some(proof) = self.pending_proofs.get(member) {
                // Generate Merkle Tree from current state
                let merkle_root = self.merkle_root();
                
                // Verify STARK proof
                let valid = winterfell::verify_proof(proof, &merkle_root)?;
                if !valid {
                    return Err(format!("Invalid STARK proof for member {}", member));
                }
            }
        }
        
        Ok(())
    }
}

// Store proofs temporarily in pending_proofs field
// Remove after verification (ephemeral)
```

**Pros**: More trustless, contract enforces ZK-proofs
**Cons**: Performance concern (STARK verification in Wasm)

### **Recommendation for Stroma**
Start with **Approach 1** (client-side verification) for MVP. Reason:
- Simpler contract design
- Faster verification
- Bot is trusted in single-group scenario
- Can add contract-side verification in Phase 4 if needed for federation

## Contract State Design for Stroma

### Complete Mergeable Schema

```rust
use freenet_stdlib::prelude::*;
use serde::{Serialize, Deserialize};
use std::collections::{BTreeSet, HashMap, HashSet};

// === Core State Types ===
// Note: freenet-scaffold is outdated. Use plain structs with serde.

#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub struct TrustNetworkState {
    // Membership (set-based, commutative)
    pub members: BTreeSet<MemberHash>,
    pub ejected: BTreeSet<MemberHash>,  // Can return (not permanent tombstone)
    
    // Trust graph (set-based, commutative)
    pub vouches: HashMap<MemberHash, HashSet<MemberHash>>,  // vouchee -> vouchers
    pub flags: HashMap<MemberHash, HashSet<MemberHash>>,    // flagged -> flaggers
    
    // Config (last-write-wins with timestamp)
    pub config: GroupConfigV1,
    pub config_timestamp: u64,
    
    // Version tracking
    pub schema_version: u64,
    
    // Federation (Phase 4+)
    #[serde(default)]
    pub federation_contracts: Vec<ContractHash>,
}

#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub struct GroupConfigV1 {
    config_change_threshold: f32,
    min_intersection_density: f32,
    min_vouch_threshold: usize,
    validator_percentile: u32,
    version: u64,           // For Last-Write-Wins
    last_updated: Timestamp,
}

// === Main State (Auto-composed) ===

#[composable]
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub struct TrustNetworkState {
    members: MemberSet,
    vouches: VouchGraph,
    flags: FlagGraph,
    config: GroupConfigV1,
    
    // Federation hooks (Phase 4+, disabled in MVP)
    #[cfg(feature = "federation")]
    federation_contracts: FederationSet,
    
    #[cfg(feature = "federation")]
    validator_anchors: BloomFilter,
}

// #[composable] macro auto-generates:
// - TrustNetworkStateSummary struct
// - TrustNetworkStateDelta struct
// - ComposableState implementation for TrustNetworkState
```

### Helper Methods (Not Part of Contract State)

```rust
impl TrustNetworkState {
    /// Generate Merkle Tree on demand for ZK-proof verification
    pub fn generate_merkle_tree(&self) -> MerkleTree<MemberHash> {
        let sorted: Vec<_> = self.members.active.iter().cloned().collect();
        MerkleTree::from_leaves(sorted)
    }
    
    /// Get Merkle root for ZK-proof verification
    pub fn merkle_root(&self) -> Hash {
        self.generate_merkle_tree().root()
    }
    
    /// Calculate effective state considering voucher-flaggers
    /// 
    /// Critical: If a voucher flags a member, that vouch is invalidated.
    /// You can't simultaneously trust and distrust someone (logical inconsistency).
    pub fn calculate_effective_state(&self, member: &MemberHash) -> (usize, i32) {
        let vouchers = self.vouches.get(member).cloned().unwrap_or_default();
        let flaggers = self.flags.get(member).cloned().unwrap_or_default();
        
        // Find vouchers who also flagged (contradictory - invalidates their vouch)
        let voucher_flaggers: HashSet<_> = vouchers
            .intersection(&flaggers)
            .collect();
        
        // Effective vouches = total vouches - voucher_flaggers
        let effective_vouches = vouchers.len() - voucher_flaggers.len();
        
        // Regular flags = flags from non-vouchers
        let regular_flags = flaggers.len() - voucher_flaggers.len();
        
        // Standing = effective_vouches - regular_flags
        let standing = effective_vouches as i32 - regular_flags as i32;
        
        (effective_vouches, standing)
    }
    
    /// Calculate trust standing for a member (using effective vouches)
    pub fn calculate_standing(&self, member: &MemberHash) -> i32 {
        let (_, standing) = self.calculate_effective_state(member);
        standing
    }
    
    /// Check if member should be ejected (two independent triggers)
    pub fn should_eject(&self, member: &MemberHash) -> bool {
        let (effective_vouches, standing) = self.calculate_effective_state(member);
        
        // Trigger 1: Standing < 0 (too many regular flags)
        if standing < 0 {
            return true;
        }
        
        // Trigger 2: Effective vouches < min_vouch_threshold (includes voucher-flagger invalidation)
        if effective_vouches < self.config.min_vouch_threshold {
            return true;
        }
        
        false
    }
    
    /// Check if member is fully vetted (ready for admission)
    pub fn is_vetted(&self, member: &MemberHash) -> bool {
        let (effective_vouches, standing) = self.calculate_effective_state(member);
        
        effective_vouches >= self.config.min_vouch_threshold && standing >= 0
    }
    
    /// Calculate mesh density (raw percentage)
    /// 
    /// Returns percentage of actual vouches vs maximum possible (full mesh).
    pub fn calculate_mesh_density(&self) -> f32 {
        let n = self.members.active.len();
        if n < 2 {
            return 0.0;
        }
        
        // Count total vouches in the network
        let total_vouches: usize = self.vouches.vouches.values()
            .map(|v| v.len())
            .sum();
        
        // Max possible vouches = n * (n - 1) for directed graph
        let max_possible = n * (n - 1);
        
        (total_vouches as f32 / max_possible as f32) * 100.0
    }
    
    /// Calculate Distinct Validator Ratio (DVR) - the primary mesh health metric
    /// 
    /// Formula: DVR = Distinct_Validators / (N / 4)
    /// 
    /// "Distinct" means Validators with non-overlapping voucher sets.
    /// Maximum possible distinct Validators ‚âà N/4 (each needs 3 unique vouchers + self).
    /// 
    /// This metric is grounded in graph theory and directly measures network resilience
    /// against coordinated attacks. See `.beads/mesh-health-metric.bead` for rationale.
    pub fn calculate_distinct_validator_ratio(&self) -> f32 {
        let n = self.members.len();
        if n < 4 {
            return 1.0; // Bootstrap: too small to measure meaningfully
        }
        
        let max_possible = n / 4;
        if max_possible == 0 {
            return 1.0;
        }
        
        let distinct_count = self.count_distinct_validators();
        (distinct_count as f32 / max_possible as f32).min(1.0)
    }
    
    /// Count Validators with non-overlapping voucher sets
    fn count_distinct_validators(&self) -> usize {
        let mut validators: Vec<_> = self.members.iter()
            .filter(|(_, m)| m.effective_vouches() >= 3)
            .collect();
        
        // Sort by vouch count descending (prefer more connected first)
        validators.sort_by_key(|(_, v)| std::cmp::Reverse(v.effective_vouches()));
        
        // Greedy selection: pick Validators whose voucher sets don't overlap
        let mut distinct = Vec::new();
        let mut used_vouchers: HashSet<Hash> = HashSet::new();
        
        for (hash, validator) in validators {
            let vouchers: HashSet<_> = validator.vouchers.iter().cloned().collect();
            
            // Check if any voucher already used by another distinct Validator
            if vouchers.is_disjoint(&used_vouchers) {
                distinct.push(hash);
                used_vouchers.extend(vouchers);
            }
        }
        
        distinct.len()
    }
    
    /// Get mesh health status (three-tier system based on DVR)
    pub fn mesh_health_status(&self) -> MeshHealthStatus {
        let dvr = self.calculate_distinct_validator_ratio();
        
        match dvr {
            d if d < 0.33 => MeshHealthStatus::Unhealthy,  // üî¥ Red: 0-33%
            d if d < 0.66 => MeshHealthStatus::Developing, // üü° Yellow: 33-66%
            _ => MeshHealthStatus::Healthy,                // üü¢ Green: 66-100%
        }
    }
    
    /// Get max possible distinct Validators for this network size
    pub fn max_distinct_validators(&self) -> usize {
        self.members.len() / 4
    }
}

/// Mesh health status bands (three-tier system based on thirds)
/// 
/// See `.beads/mesh-health-metric.bead` for full rationale.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum MeshHealthStatus {
    Unhealthy,  // üî¥ Red: 0-33% DVR - actively suggest improvements
    Developing, // üü° Yellow: 33-66% DVR - suggest opportunistically
    Healthy,    // üü¢ Green: 66-100% DVR - maintenance mode
}

impl MeshHealthStatus {
    pub fn emoji(&self) -> &'static str {
        match self {
            Self::Unhealthy => "üî¥",
            Self::Developing => "üü°",
            Self::Healthy => "üü¢",
        }
    }
    
    pub fn label(&self) -> &'static str {
        match self {
            Self::Unhealthy => "Unhealthy",
            Self::Developing => "Developing",
            Self::Healthy => "Healthy",
        }
    }
    
    pub fn description(&self) -> &'static str {
        match self {
            Self::Unhealthy => "Trust concentrated - build cross-cluster connections",
            Self::Developing => "Growing toward optimal distribution",
            Self::Healthy => "Strong distributed trust across the network",
        }
    }
}
```

## Contract Deployment

### Using freenet-stdlib

**Note**: `freenet-scaffold` is outdated and not used. Use `freenet-stdlib` for contract development.

```toml
# Cargo.toml for Wasm contract
[package]
name = "stroma-contract"
version = "0.1.0"
edition = "2021"

[dependencies]
freenet-stdlib = { version = "0.1", features = ["contract"] }
serde = { version = "1.0", features = ["derive"] }
ciborium = "0.2"  # CBOR serialization

[lib]
crate-type = ["cdylib"]  # For Wasm compilation
```

### Build Wasm Contract
```bash
# Build contract to Wasm
cargo build --target wasm32-unknown-unknown --release

# Deploy to freenet-core
freenet put-contract \
  --code target/wasm32-unknown-unknown/release/stroma_contract.wasm \
  --state initial_state.json
```

## State Stream Monitoring (Bot-Side)

### Subscribe to State Changes
```rust
async fn monitor_state_stream(freenet: &FreenetClient) -> Result<(), Error> {
    // Subscribe to contract state changes (real-time, not polling)
    let mut stream = freenet.subscribe_to_contract(contract_key).await?;
    
    while let Some(state_change) = stream.next().await {
        match state_change {
            StateUpdate::MembersChanged { added, removed } => {
                // Sync Signal group with Freenet state
                for member in added {
                    signal.add_member(member).await?;
                }
                for member in removed {
                    signal.remove_member(member).await?;
                }
            }
            StateUpdate::ConfigChanged { new_config } => {
                // Update local config cache
                update_local_config(new_config).await?;
            }
        }
    }
    
    Ok(())
}
```

## Spike Week Questions ‚Äî Status

### Q1: Conflict Resolution Semantics ‚Äî ‚úÖ ANSWERED (GO)

**Question**: How does Freenet handle conflicts when two nodes submit incompatible updates?

**Answer (from docs/spike/q1/RESULTS.md)**:
- Freenet applies all deltas via commutative set union
- **Contract's responsibility** to ensure delta commutativity
- Use set-based state (BTreeSet) with tombstones for remove-wins semantics
- Trust semantics (vouch invalidation) handled by Stroma, not Freenet

**Validated Pattern**:
```rust
fn apply_delta(&mut self, delta: &Delta) {
    // 1. Apply removals first (tombstone)
    for hash in &delta.removed {
        self.active.remove(hash);
        self.removed.insert(hash.clone());
    }
    // 2. Apply additions (only if not tombstoned)
    for hash in &delta.added {
        if !self.removed.contains(hash) {
            self.active.insert(hash.clone());
        }
    }
}
```

**Decision**: GO ‚Äî commutative merges achievable with proper contract design.

---

### Q2: Contract Validation ‚Äî ‚úÖ ANSWERED (GO)

**Question**: Can contracts reject invalid state transitions?

**Answer (from spike/q2/RESULTS.md)**:
- YES ‚Äî Freenet contracts CAN enforce trust invariants
- Two validation hooks: `update_state()` and `validate_state()`
- `update_state()` returns `Err(ContractError::InvalidUpdate)` to reject delta BEFORE application
- `validate_state()` returns `ValidateResult::Invalid` to reject merged state
- **Trustless model viable**: Contract enforces invariants
- Bot pre-validation optional (for better UX/error messages)

**Validated Pattern**:
```rust
fn update_state(...) -> Result<UpdateModification<'static>, ContractError> {
    // Layer 1: Pre-check delta validity
    for addition in &delta.additions {
        if vouch_count < 2 {
            return Err(ContractError::InvalidUpdate(...));  // Reject!
        }
    }
    // Apply delta, then post-validate
    state.apply_delta(&delta);
    Ok(UpdateModification::valid(state))
}

fn validate_state(...) -> Result<ValidateResult, ContractError> {
    // Layer 2: Post-merge state validation
    for member in &state.active {
        if vouch_count(member) < 2 {
            return Ok(ValidateResult::Invalid);  // Reject!
        }
    }
    Ok(ValidateResult::Valid)
}
```

**Decision**: GO ‚Äî contract validation works for Stroma (trustless model achievable)

---

### Q3: Cluster Detection ‚Äî ‚úÖ ANSWERED (GO)

**Question**: Does Union-Find distinguish tight clusters connected by bridges?

**Answer (from docs/spike/q3/RESULTS.md)**:
- Standard Union-Find FAILS (sees 1 cluster when connected by bridges)
- **Bridge Removal (Tarjan's algorithm)** successfully distinguishes tight clusters
- Identifies articulation edges (bridges) and removes them to find tight components
- Bridge members can vouch but don't form tight cluster with either side

**Decision**: GO ‚Äî Use Bridge Removal algorithm for cross-cluster enforcement.

---

### Q4: STARK Verification in Wasm ‚Äî ‚úÖ ANSWERED (PARTIAL)

**Question**: Can we verify STARK proofs in contract `verify()` method?

**Answer (from docs/spike/q4/RESULTS.md)**:
- winterfell Wasm support is experimental (SIMD dependencies, compilation challenges)
- **Bot-side verification** recommended for Phase 0 (native winterfell is fast and reliable)
- Bot generates proofs, verifies proofs, submits outcomes to Freenet
- Contract trusts bot's verification (acceptable for Phase 0 trust model)
- Can migrate to contract-side when Wasm improves

**Key UX Principle**: Members interact ONLY through Signal commands. All cryptographic operations happen inside the bot.

**Decision**: PARTIAL ‚Äî Bot-side verification for Phase 0.

---

### Q5: Merkle Tree Performance ‚Äî ‚úÖ ANSWERED (GO)

**Question**: How expensive is on-demand Merkle Tree generation?

**Answer (from docs/spike/q5/RESULTS.md)**:
- 1000 members: **0.09ms** (1000x faster than 100ms threshold)
- 5000 members: 0.45ms (still sub-millisecond)
- **Generate on demand** ‚Äî no caching needed
- Stateless design simplifies bot architecture

**Decision**: GO ‚Äî On-demand generation is viable.

---

### Q6: Proof Storage Strategy ‚Äî ‚úÖ ANSWERED

**Question**: Should we store proofs in contract state or just outcomes?

**Answer (from docs/spike/q6/RESULTS.md)**:
- Since Q4 chose bot-side verification: **Store outcomes only**
- Proofs are ephemeral (10-100KB each) ‚Äî discarded after verification
- Contract stores "Alice vouched for Bob", not the proof itself
- Simplifies contract state and merging

**Decision**: Store outcomes only (not proofs).

## Best Practices

### Use Set-Based State for Commutativity
From Q1 Spike: Delta operations MUST be commutative. Use set-based state:

```rust
// ‚úÖ GOOD: Set-based state (commutative)
pub struct TrustNetworkState {
    members: BTreeSet<MemberHash>,
    ejected: BTreeSet<MemberHash>,
    vouches: HashMap<MemberHash, HashSet<MemberHash>>,
    flags: HashMap<MemberHash, HashSet<MemberHash>>,
}

// ‚ùå BAD: Order-dependent state
pub struct TrustNetworkState {
    members: Vec<MemberHash>,  // Order matters, not commutative
}
```

### Ejected State (Not Tombstones)
Per architectural decision: Use "ejected" state, not permanent tombstones.
Members can return with new vouches. Flags persist across ejection.

```rust
// ‚úÖ GOOD: Ejected allows re-entry
pub struct TrustNetworkState {
    members: BTreeSet<MemberHash>,
    ejected: BTreeSet<MemberHash>,  // Can return with new vouches
}

// See: .beads/architectural-decisions-open.bead Decision #10
```

### Testing Merge Semantics (Q1 Validated Pattern)
Always test that delta application is commutative:

```rust
#[test]
fn test_delta_commutativity() {
    let initial = create_initial_state();
    
    let delta_add = Delta { added: vec!["X".into()], removed: vec![] };
    let delta_remove = Delta { added: vec![], removed: vec!["A".into()] };
    
    // Order 1: Add then Remove
    let mut state1 = initial.clone();
    state1.apply_delta(&delta_add);
    state1.apply_delta(&delta_remove);
    
    // Order 2: Remove then Add
    let mut state2 = initial.clone();
    state2.apply_delta(&delta_remove);
    state2.apply_delta(&delta_add);
    
    // Must be identical regardless of delta order
    assert_eq!(state1, state2, "Deltas must be commutative");
}
```

**See**: `docs/spike/q1/contract.rs` for validated implementation with full test suite.

## Integration with Bot Logic

### Bot Responsibilities
1. **Generate ZK-Proofs**: Client-side before submitting updates
2. **Validate State**: Check Freenet state before Signal actions
3. **Submit Updates**: Send well-formed state updates to Freenet
4. **Monitor Stream**: React to Freenet state changes in real-time
5. **Sync Signal**: Keep Signal group in sync with Freenet state

### Contract Responsibilities
1. **Merge States**: Combine divergent states deterministically
2. **Validate Invariants**: Enforce vouch count, standing thresholds
3. **Propagate Updates**: Spread through small-world network
4. **Provide Stream**: Emit state changes for bot monitoring

## Summary: Key Takeaways

1. **Freenet contracts define merge logic**, not just store data
2. **ContractInterface trait** (freenet-stdlib) is the contract API
3. **Set-based structures** (BTreeSet, HashMap) are naturally mergeable
4. **Delta commutativity** is CONTRACT's responsibility (Q1 validated)
5. **Contract validation works** ‚Äî both `update_state()` and `validate_state()` can reject (Q2 validated)
6. **Trustless model achievable** ‚Äî contract enforces invariants, bot pre-validates for UX (Q2 validated)
7. **Merkle Trees** generated on demand, not stored as primary state (Q5 validated: 0.09ms at 1000 members)
8. **ZK-Proofs** validate transitions, not stored permanently (Q6: outcomes only)
9. **Summary-delta sync** minimizes bandwidth and enables efficient eventual consistency
10. **Test commutativity** ‚Äî same result regardless of delta order
11. **Q1 ANSWERED**: Use set-based state with tombstones (remove-wins)
12. **Q2 ANSWERED**: Contract CAN enforce invariants (trustless model viable)
13. **Q3 ANSWERED**: Bridge Removal algorithm for cluster detection (Union-Find fails)
14. **Q4 ANSWERED**: Bot-side STARK verification for Phase 0 (Wasm experimental)
15. **Q5 ANSWERED**: On-demand Merkle generation is viable (sub-millisecond)
16. **Q6 ANSWERED**: Store outcomes only (proofs ephemeral)

## References

- [freenet-stdlib docs.rs](https://docs.rs/freenet-stdlib) - ContractInterface trait for Wasm contracts
- [freenet crate docs.rs](https://docs.rs/freenet) - Node embedding (SimNetwork, NodeConfig)
- [freenet-core GitHub](https://github.com/freenet/freenet-core)
- [Understanding Delta-Sync](https://freenet.org/news/summary-delta-sync/)
- [Freenet Manual - Contracts](https://docs.freenet.org/components/contracts.html)
- [CRDT Resources](https://crdt.tech/) - Similar merge semantics

**Note**: `freenet-scaffold` is outdated and not used in Stroma. Use `freenet-stdlib` for contracts.

---
description: Signal protocol integration patterns and bot behavior
globs: **/*signal*.rs,**/*bot*.rs
alwaysApply: false
---

# Signal Integration Standards

## Bot Behavior Principles

### Bot Roles
- **Protocol Gatekeeper**: Strictly enforces 2-vouch requirement for admission to Signal group
- **Blind Matchmaker (Internal)**: Strategic introduction matching within single group for MST optimization (suggests Validators, but ANY Member can vouch)
- **Diplomat (External)**: Federation proposals with other Stroma groups via Blind Rendezvous
- **Health Monitor**: Continuous monitoring of trust standing and vouch counts

### Gatekeeper Pattern (Admission Protocol)
- Presence in Signal group is **binary** and strictly tied to Freenet state
- **Core Invariant**: Every member in Signal group has ‚â•2 vouches from members in DIFFERENT CLUSTERS
- **Invitees (Leaf Nodes)**: OUTSIDE Signal group (1 vouch, being vetted)
- **Bridges**: IN Signal group (2 vouches, minimum requirement)
- **Validators**: IN Signal group (3+ vouches, used for optimization)
- **Waiting Room**: State of being outside Signal group (not a separate chat)
- **Vouches Source**: ONLY from members already IN the Stroma Signal group
- **Who Can Vouch**: ANY Member (Bridges and Validators)
- Only add users to Signal after Freenet contract confirms ‚â•2 vouches
- Monitor Freenet state stream continuously (real-time, not polling)

**Admission Flow:**
1. Member sends `/invite @Invitee [context]` ‚Üí Invitation counts as first vouch
2. Bot selects second Member via Blind Matchmaker (prefers Validators for optimization)
3. Bot facilitates introduction between invitee and selected Member
4. Second Member vouches ‚Üí Bot verifies 2 vouches in Freenet
5. Bot adds invitee to Signal group (now a Bridge)
6. Bot announces admission and deletes vetting session data

### Immediate Ejection Protocol
```rust
// Logic pattern for auto-ejection (TWO triggers with vouch invalidation)
FUNCTION: Check_Group_Standing(Member_Hash)
LET: All_Vouchers = Get_Vouchers(Member_Hash)
LET: All_Flaggers = Get_Flaggers(Member_Hash)
LET: Voucher_Flaggers = All_Vouchers INTERSECT All_Flaggers

# Calculate effective state (voucher-flaggers invalidate their vouch)
LET: Effective_Vouches = |All_Vouchers| - |Voucher_Flaggers|
LET: Regular_Flags = |All_Flaggers| - |Voucher_Flaggers|
LET: Standing = Effective_Vouches - Regular_Flags

# Trigger 1: Standing negative
IF: Standing < 0
THEN: TRIGGER(Immediate_Ejection_Protocol)

# Trigger 2: Effective vouch count below minimum
# (includes voucher left group OR voucher flagged member)
IF: Effective_Vouches < MIN_VOUCH_THRESHOLD
THEN: TRIGGER(Immediate_Ejection_Protocol)

ACTION: Bot_Execute(Signal_Group_Remove(Member_Hash))
AND: Send_Private_Notification(Member_Hash, 
     "You have been removed. To rejoin, secure 2 new vouches via /invite.")
```

**Ejection Triggers:**
1. **Standing < 0**: Too many regular flags relative to effective vouches
2. **Effective_Vouches < MIN_VOUCH_THRESHOLD**: Voucher(s) left group OR voucher-flaggers invalidated vouches

**Vouch Invalidation**: If a voucher flags a member, that vouch is invalidated (logical consistency - can't both trust and distrust)

**No Grace Periods:**
- No 48-hour warnings
- No re-verification windows
- Immediate removal when either trigger condition met
- **Member Responsibility**: Cultivate multiple vouches for resilience

**Heartbeat Monitor:**
- Runs every 60 minutes
- Checks vouch count for all members
- Immediate ejection if < MIN_VOUCH_THRESHOLD
- No manual intervention required

**Re-Entry Path:**
- Secure 2 new vouches from Members IN the group (ANY Member can vouch, not just Validators)
- Go through admission protocol again
- **No Public Shaming**: Uses hashes, not names in notifications

## Privacy-First UX (Non-Technical Users)

### Command Interface
- All vetting/vouching occurs in **1-on-1 PMs** with bot
- Never expose member operations in group chat (prevents metadata leakage)

**Member Commands:**
- `/invite @username [context]` - Invite someone (counts as first vouch)
- `/vouch @username` - Vouch for invitee or existing member
- `/flag @username [reason]` - Flag member for trust violation (required reason)
- `/propose <subcommand> [args]` - Propose group decision (config, federation, etc.)
- `/status` - View personal trust standing and vouch count
- `/status @username` - View another member's standing (if visible)
- `/mesh` - View network health and topology
- `/mesh strength` - View mesh density histogram
- `/mesh config` - View group configuration
- `/propose <subcommand> [args]` - Propose group decision (unified command)
- `/audit operator` - View operator action history

**Who Can Use:**
- `/invite`, `/vouch`: Any Member (Bridges and Validators)
- `/flag`: Only Members (not invitees being vetted)
- All query commands: Any Member

**Bot Characteristics:**
- **Natural Language**: Bot responds conversationally, not with technical jargon
- **Proactive Suggestions**: Bot may suggest strategic introductions to strengthen mesh
- **Metadata Isolation**: All vetting in 1-on-1 PMs (Layer 3 of trust map protection)
- **Privacy**: All operations use hashed identifiers, no cleartext stored

### Voting Interface: Native Signal Polls (Anonymous)

**Implementation**: Protocol v8 polls via forked libsignal-service-rs

**Why Polls (Not Reactions):**
- ‚úÖ **Anonymous voting** - Signal doesn't expose who voted what
- ‚úÖ **Privacy** - Only aggregated results visible to bot and members
- ‚úÖ **Multiple choices** - Enables nuanced decisions
- ‚úÖ **Native UX** - Familiar Signal mobile/desktop interface
- ‚ùå **Reactions expose voters** - Everyone sees who reacted (violates privacy)

**Poll Structure:**
- **Options**: Binary (‚úÖ Approve / ‚ùå Reject) or multiple choice (future)
- **Anonymity**: Bot sees only totals (15 approve, 3 reject), never individuals
- **Timeout**: Configurable per proposal (e.g., 48h, 72h, 96h)
- **Threshold**: From GroupConfig.config_change_threshold (e.g., 70%)

**Implementation:**
```rust
// Create poll for proposal
let poll_message = DataMessage {
    poll_create: Some(PollCreate {
        question: Some(format_proposal(proposal)),
        allow_multiple: Some(false),
        options: vec!["üëç Approve".to_string(), "üëé Reject".to_string()],
    }),
    ..Default::default()
};

manager.send_message_to_group(master_key, poll_message, timestamp).await?;
```

**Vote Counting (After Timeout):**
```rust
// Bot reads aggregated results only
let results = get_poll_results(poll_timestamp).await?;
// results.approve_count: 15
// results.reject_count: 3
// results.approval_ratio: 0.83 (83%)
// NO individual votes exposed
```

**Use Cases**: All group decisions (config changes, federation, settings)

### User Experience (Abstraction Layer)
- **Invisible Backend**: Freenet complexity completely hidden from users
- **Thin Client**: Bot acts as gateway to Freenet contract
- Bot acts as "Diplomat" for federation proposals

### Signal Poll Usage
Bot sends Signal Polls to validators for all group decisions:

**Federation Proposal:**
```
Member: /propose federate abc123def --timeout 72h

Bot: "üìã Proposal #5
     Federate 'Activists-NYC' with 'Mutual Aid SF'
     
     Overlap: 12 shared members (15% intersection)
     Their size: ~80 members
     Intersection density: 15% (above our 10% threshold)
     
     Timeout: 72h (custom)
     Threshold: 70% approval required
     Closes: Sun Feb 2, 6:00 PM"

[Signal Poll created - members vote anonymously]

Bot (after timeout):
     "‚úÖ Proposal #5 APPROVED
      Results: 18 Approve, 3 Reject (86% approval)
      
      Executing: Federation with 'Mutual Aid SF'"

[Bot establishes federation on Freenet]

Bot: "‚úÖ Federation established with 'Mutual Aid SF'
      Cross-mesh vouching now enabled."
```

**Configuration Change:**
```
Member: /propose stroma min_intersection_density 0.15

Bot: "üìã Proposal #8
     Change Stroma config: min_intersection_density ‚Üí 0.15
     Current: 0.10
     
     Timeout: 48h (default)
     Threshold: 70% approval required
     Closes: Thu Jan 30, 2:00 PM"

[Signal Poll created - members vote anonymously]

Bot (after timeout):
     "‚úÖ Proposal #8 APPROVED
      Results: 15 Approve, 3 Reject (83% approval)
      
      Executing: min_intersection_density ‚Üí 0.15"

[Bot updates Freenet contract]

Bot: "‚úÖ Configuration updated: min_intersection_density = 0.15"
```

**Key: Votes are anonymous** - Only aggregated counts visible, never individual votes.

- **Status Dashboard**: `/mesh` shows network health, personal standing, role
- **Progress Indicators**: "You are 1-link away from being fully vetted"
- **Role Visibility**: "You are now a Validator (can help verify others!)"
- **Growing Horizon**: Network expansion feels organic, not forced

## Signal Protocol Integration

### Library Usage
- Use `libsignal-service-rs` for protocol-level group management
- Implement listener for group events and PMs
- Handle group member additions/removals atomically
- **Signal Poll Support**: Use Signal's poll message type for structured voting
  - Send polls to validators
  - Monitor poll responses automatically
  - Calculate approval rates from poll results

### Group Management
- Bot must have admin privileges to manage membership
- All membership changes must be verified against Freenet state first
- Never make membership decisions based solely on Signal group state
- **Automatic Execution**: Bot automatically adds/removes members based on Freenet state changes
- **Event-Driven**: Bot monitors Freenet state stream and reacts immediately to state changes

## Federation Proposals

### Discovery Notification
When bot detects high-density overlap:
```
"üîç Federation Opportunity Detected

I've discovered a compatible trust network (Group-B) with significant overlap:
- Overlap: 12 shared members
- Intersection Density: 15% (above our 10% threshold)
- Their Size: ~80 members

Federation would enable cross-mesh vouching and shared trust context.
Should we federate?

[Signal Poll created]"
```

### Bridge Proposals (Mesh Building)
Bot proactively suggests strategic connections:
```
"üí° Mesh Optimization: I can introduce you to a member from a different 
part of the network. This would strengthen your position and improve 
overall network resilience.

You currently have 2 vouches (Bridge status). Adding connections with 
members outside your immediate cluster helps create a more robust mesh.

React with ‚úÖ to accept introduction."
```

## Data Handling

### Never Store Signal IDs
- **Critical**: Bot must never store Signal IDs in cleartext
- **HMAC-based hashing**: Use keyed hashing with group-secret pepper (not deterministic hashing)
- **Ephemeral Memory**: Raw Signal IDs wiped immediately after hashing
- **Blinded Identifiers**: Public ID for bot, private ID for ZK-math
- Hash all identifiers immediately using HMAC
- Use hashed identifiers for all internal operations
- **Ephemeral State**: Vetting session data deleted after admission threshold met
- **Memory Hygiene**: Use `zeroize` crate to purge sensitive buffers

## Vouch Permissions

### Who Can Vouch
- **ANY Member** in the Stroma Signal group can vouch
- Includes both Bridges (2 vouches) and Validators (3+ vouches)
- Invitees (people being vetted) CANNOT vouch

### Blind Matchmaker Role
- Bot SUGGESTS optimal Members for strategic introductions
- Bot prefers Validators for intersectional diversity optimization
- But Members can vouch without bot suggestion
- Strategic matching is for optimization, not enforcement

### Vouch Contexts
1. **Vetting**: Vouch for invitee during admission process
2. **Mesh Building**: Vouch for existing Member to strengthen mesh
3. **Cross-Mesh**: Member from federated Group-B can vouch for Group-A invitee

### Vouch Validity
- Vouches must be from members in DIFFERENT CLUSTERS (cross-cluster mandatory)
- Bot verifies via Freenet that voucher is current Member
- ZK-proof confirms voucher is in Merkle Tree
- First vouch = invitation itself (no separate token)

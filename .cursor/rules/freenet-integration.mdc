---
description: Freenet embedded kernel and contract development with ComposableState
globs: **/*freenet*.rs,**/*contract*.rs,**/*wasm*.rs,**/*state*.rs,**/*kernel*.rs
alwaysApply: false
---

# Freenet Integration Standards

## Critical Updates

### Update 1 (2026-01-27): Embedded Freenet Kernel
**Architectural Decision**: Embed Freenet kernel directly into Stroma binary (not external service)

**References:**
- [Freenet Manual - Tutorial](https://freenet.org/resources/manual/tutorial/) - Embedding patterns
- `.beads/architecture-decisions.bead` - Decision #9

**Implementation:**
- Use `freenet-stdlib` crate with "full" features (not `freenet-core` CLI)
- Freenet kernel runs in-process within Stroma event loop
- No separate freenet-core service to manage
- Single binary includes both bot logic and embedded kernel

**Benefits:**
- Simpler deployment (single service)
- Reduced attack surface (no IPC)
- Better error handling (in-process)
- Easier for operators

### Update 2 (2026-01-26): ComposableState Requirement
**Major Architectural Discovery**: Freenet contracts require `ComposableState` trait for summary-delta synchronization.

**References:**
- [freenet-scaffold](https://github.com/freenet/freenet-scaffold) - Contract development utilities
- [Understanding Delta-Sync](https://freenet.org/news/summary-delta-sync/) - Synchronization approach
- `.cursor/rules/freenet-contract-design.mdc` - Complete ComposableState patterns

**Key Changes**:
- ❌ **OLD**: External freenet-core service
- ✅ **NEW**: Embedded Freenet kernel (in-process)
- ❌ **OLD**: Store Merkle Trees in contract state
- ✅ **NEW**: Use set-based structures (BTreeSet), generate Merkle Trees on-demand
- ❌ **OLD**: Store Vec<VouchProof> (not easily mergeable)
- ✅ **NEW**: Use HashMap<MemberHash, BTreeSet<MemberHash>> (naturally mergeable)

## Embedded Kernel Pattern

### Initialize Embedded Freenet Kernel

```rust
use freenet_stdlib::prelude::*;

#[tokio::main]
async fn main() -> Result<(), Error> {
    // Initialize embedded Freenet kernel (in-process, not external service)
    let kernel = FreenetKernel::builder()
        .mode(NetworkMode::Dark)  // Anonymous routing
        .data_dir(config.freenet.data_dir)
        .build()
        .await?;
    
    // Initialize Signal bot
    let signal = SignalBot::authenticate(config.signal).await?;
    
    // Load or deploy contract
    let contract = if config.contract_key.is_empty() {
        // Bootstrap: Deploy new contract
        deploy_trust_network_contract(&kernel, &seed_members).await?
    } else {
        // Normal: Load existing contract
        kernel.load_contract(config.contract_key).await?
    };
    
    // Single event loop for both Freenet and Signal
    run_bot_event_loop(kernel, signal, contract).await
}
```

### Event Loop with Embedded Kernel

```rust
async fn run_bot_event_loop(
    kernel: FreenetKernel,
    signal: SignalBot,
    contract_key: ContractKey,
) -> Result<(), Error> {
    // Subscribe to contract state stream (real-time, not polling)
    let mut state_stream = kernel.subscribe_to_contract(contract_key).await?;
    
    loop {
        tokio::select! {
            // Freenet state changes (from embedded kernel)
            Some(state_change) = state_stream.next() => {
                handle_freenet_change(state_change, &signal).await?;
            }
            
            // Signal messages
            Some(message) = signal.recv_message() => {
                handle_signal_command(message, &kernel, contract_key).await?;
            }
            
            // Periodic health check (heartbeat)
            _ = health_check_interval.tick() => {
                check_all_trust_standings(&kernel, &signal, contract_key).await?;
            }
        }
    }
}
```

**Key Points:**
- Single process handles both Freenet and Signal
- No IPC (inter-process communication) overhead
- Kernel is embedded, not external service
- State stream is in-process (faster, more reliable)

### Deploy Contract to Embedded Kernel

```rust
async fn deploy_trust_network_contract(
    kernel: &FreenetKernel,
    seed_members: &[SignalId],
) -> Result<ContractKey, Error> {
    // Build initial state
    let initial_state = TrustNetworkState {
        members: create_seed_member_set(seed_members),
        vouches: create_initial_triangle_vouches(seed_members),
        flags: FlagGraph::default(),
        config: GroupConfigV1::default(),
    };
    
    // Deploy contract to embedded kernel
    let contract_key = kernel.deploy_contract(
        CONTRACT_WASM_BYTES,  // Compiled Wasm contract
        initial_state,
        ContractParameters::default(),
    ).await?;
    
    Ok(contract_key)
}
```

## Contract Architecture (Eventual Consistency)

### Wasm Contract Pattern with ComposableState
- Write Freenet contracts in Rust/Wasm using `freenet-scaffold` v0.2+
- **Embedded Kernel**: Runs in-process within Stroma (not external service)
- **Decentralized State**: Contract exists across network, no single server
- **Eventual Consistency**: States merge via summary-delta synchronization (no consensus)
- **Mergeable Structures**: Use CRDT-like patterns (BTreeSet, HashMap, Last-Write-Wins)
- **ComposableState Trait**: All state fields must implement verify, summarize, delta, apply_delta
- **Merkle Trees**: Generated on-demand for ZK-proof verification (not stored in contract)
- **Ephemeral Relationship Data**: Deleted after vetting threshold met
- **State Survives**: Trust state persists even if bot crashes (kernel syncs from network)

### Group Configuration (Last-Write-Wins)
```rust
use freenet_scaffold::ComposableState;

#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub struct GroupConfigV1 {
    // Consensus thresholds
    config_change_threshold: f32,      // e.g., 0.70 (70%) - used for ALL decisions
    ejection_appeal_threshold: f32,    // e.g., 0.60 (60%)
    
    // Federation parameters
    min_intersection_density: f32,     // e.g., 0.10-0.30 (per-group)
    validator_percentile: u32,         // e.g., 20 (top 20%)
    
    // Trust parameters
    min_vouch_threshold: usize,        // Default: 2 (minimum vouches to stay in group)
    
    // Metadata (for Last-Write-Wins conflict resolution)
    version: u64,                      // Incremented on each change
    last_updated: Timestamp,
}

impl ComposableState for GroupConfigV1 {
    type Summary = (u64, Timestamp);
    type Delta = Option<GroupConfigV1>;
    
    fn apply_delta(&mut self, .., delta: &Option<Self::Delta>) -> Result<(), String> {
        if let Some(new_config) = delta {
            // Last-Write-Wins: Keep config with higher version
            if new_config.version > self.version {
                *self = new_config.clone();
            }
        }
        Ok(())
    }
}
```

**Configuration Management:**
- All config stored in Freenet contract, NOT controlled by operator
- Changes require Signal Poll vote exceeding `config_change_threshold`
- Any member can query: `/mesh config`
- Any member can propose: `/propose-config key=value [reason]`
- Last-Write-Wins conflict resolution via version field

### State Verification (Contract verify() Method)
```rust
impl ComposableState for TrustNetworkState {
    fn verify(&self, _parent: &Self::ParentState, params: &Self::Parameters) -> Result<(), String> {
        // Verify all members have >= min_vouch_threshold EFFECTIVE vouches
        // (considering vouch invalidation when voucher flags)
        for member in &self.members.active {
            let (effective_vouches, standing) = self.calculate_effective_state(member);
            
            // Check effective vouch count (not total vouches)
            if effective_vouches < self.config.min_vouch_threshold {
                return Err(format!(
                    "Member {} has only {} effective vouches (need {})",
                    member, effective_vouches, self.config.min_vouch_threshold
                ));
            }
            
            // Verify standing >= 0
            if standing < 0 {
                return Err(format!("Member {} has negative standing ({})", member, standing));
            }
        }
        
        // [Optional] Verify ZK-proofs (TBD based on Spike Week Q1)
        
        Ok(())
    }
}
```

**Key Change**: Verification uses **effective vouches** (total minus voucher-flaggers), not total vouches.
```

## Emergent Discovery (Shadow Beacons)

### Social Anchor Hashing
- Generate Freenet URI from: `Hash(Sorted(Top-N-Validators))`
- **Dynamic threshold**: Number of validators (N) must be calculated based on group size, not hardcoded
- **Configurable**: Threshold should be configurable to balance Sybil attack resilience vs. discovery probability
- Use most trusted validators (highest number of vouches) up to the threshold
- Sort Signal IDs alphabetically before hashing
- URI changes as group composition changes (organic discovery)
- **Design consideration**: Threshold should scale with group size to maintain security properties

### Bloom Filter Strategy (External Federation Only)
- **Scope**: EXTERNAL - discovery between separate Stroma groups
- Publish "Bloom Filter" at multiple URIs (percentile-based)
- Scan multiple URIs on Freenet for overlapping filters
- Use Private Set Intersection (PSI-CA) to prove overlap without revealing IDs
- Calculate BidirectionalMin: Both groups check if overlap meets their threshold
- Alert validators via Signal Poll if both thresholds satisfied: "I have found a sister mesh. Should we begin federation?"

### Zero-Knowledge Discovery (External Only)
- **Scope**: EXTERNAL - discovery between separate Stroma groups
- Bots find each other through "social frequency," not pre-shared keys
- Discovery is **emergent** - no admin coordination required
- If groups share core trusted validators, they independently calculate overlapping URIs
- **Complete Anonymity**: No graph structure exposed to other group

## State Management

### Merkle Tree Storage
- **Never store member lists directly**
- Store Merkle Tree of Proofs representing trust state
- All state transitions must be verifiable through tree structure

### State Stream Monitoring
- Bot must continuously monitor Freenet state stream (real-time, not polling)
- **Long-Polling/WebSocket**: Efficient real-time updates
- React immediately to state changes (e.g., trust threshold violations)
- State changes trigger immediate Signal group actions
- **Trust Standing**: Monitor `Standing = Vouches - Flags` in real-time
- **Instant Enforcement**: No grace periods, ejection immediate when `Standing < 0`

## Federation Logic

### Mesh Overlap Calculation (BidirectionalMin)
```
FUNCTION: Calculate_Mesh_Overlap(Bot_A_Set, Bot_B_Set)
USE: Commutative_Encryption(Key_A, Key_B)  # Double-blinding
RESULT: Intersection_Size = COUNT(Encrypted_Set_A == Encrypted_Set_B)

# Each group evaluates with its own threshold
LET: Density_In_A = Intersection_Size / SIZE(Bot_A_Set)
LET: Density_In_B = Intersection_Size / SIZE(Bot_B_Set)

# Retrieve each group's threshold from their Freenet contract
LET: Threshold_A = Get_Group_Config(Bot_A).min_intersection_density_self
LET: Threshold_B = Get_Group_Config(Bot_B).min_intersection_density_self

# Both thresholds must be satisfied (BidirectionalMin)
IF: (Density_In_A >= Threshold_A) AND (Density_In_B >= Threshold_B)
THEN: PROPOSE(Federation_Event)
```

**Key Principles:**
- **Independent Thresholds**: Each group configures its own minimum overlap percentage
- **BidirectionalMin**: Both groups must satisfy their own threshold for federation proposal
- **Asymmetric Groups**: Handles different group sizes fairly (small groups can require higher thresholds)
- **Group Autonomy**: Thresholds stored in each group's Freenet contract, changeable only via group vote

### Federation Contract
- Bots "sign" federation contract on Freenet after human consensus (70% approval)
- **Shared Freenet State**: Unified contract for confederated meshes
- Contract enables cross-mesh vouching (Shadow-Vouch)
- **Bridge Maintenance**: Bot proactively suggests connections when bridge density drops
- **Reciprocal Buffer**: Groups act as mutual buffers for each other
- **Trust Identity**: Member's trust identity precedes them across meshes

## Privacy Guarantees

### Anonymous Operations
- All Freenet operations must preserve anonymity
- Never expose member identities in contract state
- Use hashed identifiers throughout

### Rendezvous Hashing
- Use rendezvous hashing strategy for bot discovery
- Monthly rotation: `URI = Hash(Secret + "2026-01")` (example format)
- Secret derived from group state, not pre-shared

---
description: Freenet embedded kernel and contract development with ComposableState
globs: **/*freenet*.rs,**/*contract*.rs,**/*wasm*.rs,**/*state*.rs,**/*kernel*.rs
alwaysApply: false
---

# Freenet Integration Standards

## Critical Updates

### Update 1 (2026-01-30): Freenet Node Embedding — Q1 VALIDATED
**Architectural Decision**: Embed Freenet node directly into Stroma binary (not external service)

**References:**
- [docs.rs/freenet](https://docs.rs/freenet/latest/freenet/) — Node embedding API
- `docs/spike/q1/RESULTS.md` — Q1 Spike validation results
- `.beads/architecture-decisions.bead` — Decision #9

**Q1 Spike Finding: Crate Clarification**
- **`freenet` crate** — For running the node (NodeConfig, SimNetwork, Executor)
- **`freenet-stdlib` crate** — For writing Wasm contracts (ContractInterface trait)

**Entry Points (Q1 Validated):**
| Use Case | Entry Point |
|----------|-------------|
| Spike/integration testing | `freenet::dev_tool::SimNetwork` |
| Unit testing | `freenet::local_node::Executor::new_mock_in_memory()` |
| Production | `freenet::local_node::NodeConfig::build()` |

**Benefits:**
- Simpler deployment (single service)
- Reduced attack surface (no IPC)
- Better error handling (in-process)
- Easier for operators
- **Trust Map Protection**: Distributed state (no single seizure point)

### Update 2 (2026-01-26): ComposableState Requirement
**Major Architectural Discovery**: Freenet contracts require `ComposableState` trait for summary-delta synchronization.

**References:**
- [freenet-stdlib](https://docs.rs/freenet-stdlib) - ContractInterface trait for Wasm contracts
- [Understanding Delta-Sync](https://freenet.org/news/summary-delta-sync/) - Synchronization approach
- `.cursor/rules/freenet-contract-design.mdc` - Complete ComposableState patterns

**Key Changes**:
- ❌ **OLD**: External freenet-core service
- ✅ **NEW**: Embedded Freenet kernel (in-process)
- ❌ **OLD**: Store Merkle Trees in contract state
- ✅ **NEW**: Use set-based structures (BTreeSet), generate Merkle Trees on-demand
- ❌ **OLD**: Store Vec<VouchProof> (not easily mergeable)
- ✅ **NEW**: Use HashMap<MemberHash, BTreeSet<MemberHash>> (naturally mergeable)

## Freenet Node Embedding Pattern

### Production: NodeConfig::build()

```rust
use freenet::local_node::{NodeConfig, OperationMode};
use freenet::dev_tool::ClientEventsProxy;

#[tokio::main]
async fn main() -> Result<(), Error> {
    // Build configuration for embedded node
    let mut config = NodeConfig {
        should_connect: true,
        is_gateway: false,
        key_pair: TransportKeypair::new(),
        network_listener_ip: "0.0.0.0".parse()?,
        network_listener_port: 0,  // OS assigns port
        ..Default::default()
    };
    
    // Add gateway to join network
    config.add_gateway(InitPeerNode::new(...));
    
    // Build the node (takes ClientEventsProxy for programmatic interaction)
    let node: Node = config.build([client_proxy]).await?;
    
    // Initialize Signal bot
    let signal = SignalBot::authenticate(config.signal).await?;
    
    // Run event loop
    run_bot_event_loop(node, signal).await
}
```

### Testing: SimNetwork (Deterministic)

```rust
use freenet::dev_tool::SimNetwork;
use std::time::Duration;

async fn test_conflict_resolution() -> Result<(), Error> {
    // Create simulated network: 1 gateway, 3 nodes, deterministic seed
    let mut sim = SimNetwork::new("test", 1, 3, 10, 3, 10, 5, 0x1234).await;
    
    // Check connectivity
    sim.check_connectivity(Duration::from_secs(10)).await?;
    
    // Submit operations and check convergence
    let result = sim.check_convergence().await;
    println!("Converged: {}, Diverged: {}", 
             result.converged.len(), result.diverged.len());
    
    Ok(())
}
```

### Event Loop with Embedded Node

```rust
async fn run_bot_event_loop(
    node: Node,
    signal: SignalBot,
) -> Result<(), Error> {
    // Get shutdown handle for graceful termination
    let shutdown = node.shutdown_handle();
    
    // Contract state stream (real-time, not polling)
    // Note: Actual API depends on ClientEventsProxy implementation
    let mut state_stream = /* subscribe via client proxy */;
    
    loop {
        tokio::select! {
            // Freenet state changes (from embedded node)
            Some(state_change) = state_stream.next() => {
                handle_freenet_change(state_change, &signal).await?;
            }
            
            // Signal messages
            Some(message) = signal.recv_message() => {
                handle_signal_command(message, &node).await?;
            }
            
            // Graceful shutdown
            _ = shutdown_signal() => {
                shutdown.shutdown();
                break;
            }
        }
    }
    Ok(())
}
```

**Key Points:**
- Single process handles both Freenet and Signal
- No IPC (inter-process communication) overhead
- Node is embedded, not external service
- Use `ShutdownHandle` for graceful termination

### Writing Contracts (freenet-stdlib)

```rust
use freenet_stdlib::prelude::*;

// Contract implementation using ContractInterface trait
#[contract]
impl ContractInterface for TrustNetworkContract {
    fn validate_state(
        parameters: Parameters<'static>,
        state: State<'static>,
        related: RelatedContracts<'static>,
    ) -> Result<ValidateResult, ContractError> {
        // Deserialize from CBOR (NOT JSON — see .beads/serialization-format.bead)
        let trust_state = TrustNetworkState::from_bytes(&state)
            .map_err(|_| ContractError::InvalidState)?;
        trust_state.verify()?;
        Ok(ValidateResult::Valid)
    }
    
    fn update_state(
        parameters: Parameters<'static>,
        state: State<'static>,
        data: Vec<UpdateData<'static>>,
    ) -> Result<UpdateModification<'static>, ContractError> {
        // Deserialize from CBOR
        let mut trust_state = TrustNetworkState::from_bytes(&state)?;
        
        for update in data {
            // Apply delta (must be commutative!)
            trust_state.apply_delta(&update)?;
        }
        
        // Serialize back to CBOR
        let new_state = trust_state.to_bytes()?;
        Ok(UpdateModification::valid(State::from(new_state)))
    }
    
    fn summarize_state(...) -> Result<StateSummary<'static>, ContractError> { ... }
    fn get_state_delta(...) -> Result<StateDelta<'static>, ContractError> { ... }
}
```

**Key Q1 Finding**: Delta operations MUST be commutative. Use set-based state with tombstones.
See `docs/spike/q1/RESULTS.md` for validated patterns.

**Key Q2 Finding**: Contracts CAN enforce invariants via `update_state()` and `validate_state()`.
See `docs/spike/q2/RESULTS.md` for trustless validation patterns.

## Contract Architecture (Eventual Consistency)

### Wasm Contract Pattern with ContractInterface
- Write Freenet contracts in Rust/Wasm using `freenet-stdlib`
- **Embedded Node**: Runs in-process within Stroma (not external service)
- **Decentralized State**: Contract exists across network, no single server
- **Eventual Consistency**: States merge via summary-delta synchronization (no consensus)
- **Mergeable Structures**: Use CRDT-like patterns (BTreeSet, HashMap, Last-Write-Wins)
- **ContractInterface Trait**: Contracts implement validate_state, update_state, summarize_state, get_state_delta
- **Commutative Deltas**: Q1 validated — contract's responsibility to ensure order-independence
- **Contract Validation**: Q2 validated — `update_state()` rejects invalid deltas, `validate_state()` rejects invalid state
- **Trustless Model**: Q2 validated — contract CAN enforce invariants (bot pre-validation optional for UX)
- **Merkle Trees**: Generated on-demand for ZK-proof verification (not stored in contract)
- **Ephemeral Relationship Data**: Deleted after vetting threshold met
- **State Survives**: Trust state persists even if bot crashes (node syncs from network)

**Q1 Spike Finding**: Freenet requires delta commutativity but doesn't enforce it.
Use set-based state with tombstones for remove-wins semantics. See `docs/spike/q1/RESULTS.md`.

**Q2 Spike Finding**: Freenet contracts CAN enforce invariants through two validation hooks:
- `update_state()` — Returns `Err(ContractError::InvalidUpdate)` to reject delta
- `validate_state()` — Returns `ValidateResult::Invalid` to reject merged state
Trustless model is achievable. See `docs/spike/q2/RESULTS.md`.

### Group Configuration (Last-Write-Wins)
```rust
use freenet_stdlib::prelude::*;

#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub struct GroupConfigV1 {
    // Consensus thresholds
    config_change_threshold: f32,      // e.g., 0.70 (70%) - used for ALL decisions
    // NOTE: No ejection_appeal_threshold - appeals handled via re-invite path (outside group)
    
    // Federation parameters
    min_intersection_density: f32,     // e.g., 0.10-0.30 (per-group)
    validator_percentile: u32,         // e.g., 20 (top 20%)
    
    // Trust parameters
    min_vouch_threshold: usize,        // Default: 2 (minimum vouches to stay in group)
    
    // Metadata (for Last-Write-Wins conflict resolution)
    version: u64,                      // Incremented on each change
    last_updated: Timestamp,
}

impl ComposableState for GroupConfigV1 {
    type Summary = (u64, Timestamp);
    type Delta = Option<GroupConfigV1>;
    
    fn apply_delta(&mut self, .., delta: &Option<Self::Delta>) -> Result<(), String> {
        if let Some(new_config) = delta {
            // Last-Write-Wins: Keep config with higher version
            if new_config.version > self.version {
                *self = new_config.clone();
            }
        }
        Ok(())
    }
}
```

**Configuration Management:**
- All config stored in Freenet contract, NOT controlled by operator
- Changes require Signal Poll vote exceeding `config_change_threshold`
- Any member can query: `/mesh config`
- Any member can propose via unified `/propose` command:
  - `/propose config <setting> <value>` for Signal group settings
  - `/propose stroma <setting> <value>` for Stroma trust settings
  - `/propose federate <group-id>` for federation
- Last-Write-Wins conflict resolution via version field

### State Verification (Contract verify() Method)
```rust
impl ComposableState for TrustNetworkState {
    fn verify(&self, _parent: &Self::ParentState, params: &Self::Parameters) -> Result<(), String> {
        // Verify all members have >= min_vouch_threshold EFFECTIVE vouches
        // (considering vouch invalidation when voucher flags)
        for member in &self.members.active {
            let (effective_vouches, standing) = self.calculate_effective_state(member);
            
            // Check effective vouch count (not total vouches)
            if effective_vouches < self.config.min_vouch_threshold {
                return Err(format!(
                    "Member {} has only {} effective vouches (need {})",
                    member, effective_vouches, self.config.min_vouch_threshold
                ));
            }
            
            // Verify standing >= 0
            if standing < 0 {
                return Err(format!("Member {} has negative standing ({})", member, standing));
            }
        }
        
        // [Optional] Verify ZK-proofs (TBD based on Spike Week Q1)
        
        Ok(())
    }
}
```

**Key Change**: Verification uses **effective vouches** (total minus voucher-flaggers), not total vouches.
```

## Two-Layer Architecture (Trust State + Persistence)

### Layer 1: Trust State (Freenet-Native)

The trust state (members, vouches, flags) is stored natively in Freenet using ComposableState:

| Aspect | Specification |
|--------|---------------|
| Storage | BTreeSet (members), HashMap (vouches, flags) |
| Sync | Native Freenet ComposableState |
| Updates | Small deltas (~100-500 bytes), infrequent (human timescale) |
| Security | Contract validates via `update_state()` + `validate_state()` |

### Layer 2: Persistence Fragments (Reciprocal Persistence Network)

Because Freenet data can fall off if no peers are subscribed, we add a persistence layer:

| Aspect | Specification |
|--------|---------------|
| Purpose | Durability against Freenet data loss, server seizure protection |
| Method | Encrypt full state, chunk into 64KB pieces, replicate 3x each |
| Distribution | Deterministic per-chunk (rendezvous hashing, zero trust) |
| Frequency | Same as trust state updates (infrequent) |

### Freenet Native Capabilities (Leveraged)

| Capability | How Stroma Uses It |
|------------|-------------------|
| Summary-Delta Sync | Trust state merges commutatively (Q1 validated) |
| Subscription Trees | Bots subscribe to contract state changes |
| Eventual Consistency | Trust state converges across network |
| Small-World Topology | Efficient propagation of updates |

### What Freenet Does NOT Provide (We Add)

| Gap | Stroma's Solution |
|-----|-------------------|
| Persistence (data falls off) | Reciprocal Persistence Network |
| Encryption at rest | Application-level AES-256-GCM |
| Seizure resistance | Chunks distributed across N bots (deterministic) |
| Member count privacy | Size buckets, encrypted attestations |

### Delta Update Flow (Simplified)

Since trust network changes are **infrequent** (human timescale), the model simplifies:

```
On each trust state change (vouch, flag, etc.):

1. Apply delta to Freenet contract (native delta-sync)
   - Small: ~100-500 bytes per operation
   - Freenet handles propagation efficiently

2. Encrypt current state snapshot
   - AES-256-GCM with key derived from Signal ACI
   - Include version number + previous hash

3. Chunk encrypted state (64KB chunks)
   - Split into N chunks (e.g., 500KB → 8 chunks)
   - For each chunk: compute 2 holders via rendezvous hashing
   - Distribute 2 replicas per chunk to computed holders

4. Verify holders received chunks
   - Holders sign attestations confirming receipt
   - Anyone can compute holder identities (chunks still encrypted)
   - Need ALL chunks + ACI key to reconstruct
```

### Why Full State (Not Delta Chunks)

Analysis showed delta-chunking provides no benefit:

| Question | Finding |
|----------|---------|
| Chunk deduplication? | Not useful - encryption uses nonces (different ciphertext each time) |
| Delta deduplication? | Not useful - encryption uses nonces (different ciphertext) |
| Registry deduplication? | Not useful - records change frequently, need stable addressing |

**Decision:** Full state re-chunking because:
- Updates are infrequent (human timescale) - complexity not justified
- Encryption nonces produce different ciphertext each time (no dedup benefit)
- Simplicity > optimization for rare operations

### Single-Writer Model

Each bot is the **authoritative writer** for its own trust contract:

```rust
pub struct EncryptedTrustNetworkState {
    ciphertext: Vec<u8>,           // AES-256-GCM encrypted
    signature: Signature,           // Ed25519 by bot keypair
    bot_pubkey: PublicKey,         // Identifies authoritative writer
    member_merkle_root: Hash,      // Public for ZK-proofs
    version: u64,                  // Monotonic, anti-replay
    previous_hash: Hash,           // Chain integrity
    timestamp: Timestamp,
}
```

**Peers validate via signature**, not content (they can't decrypt).

**See**: `.beads/persistence-model.bead`, `.beads/contract-encryption.bead`

## Emergent Discovery (Shadow Beacons)

### Social Anchor Hashing
- Generate Freenet URI from: `Hash(Sorted(Top-N-Validators))`
- **Dynamic threshold**: Number of validators (N) must be calculated based on group size, not hardcoded
- **Configurable**: Threshold should be configurable to balance Sybil attack resilience vs. discovery probability
- Use most trusted validators (highest number of vouches) up to the threshold
- Sort Signal IDs alphabetically before hashing
- URI changes as group composition changes (organic discovery)
- **Design consideration**: Threshold should scale with group size to maintain security properties

### Bloom Filter Strategy (External Federation Only)
- **Scope**: EXTERNAL - discovery between separate Stroma groups
- Publish "Bloom Filter" at multiple URIs (percentile-based)
- Scan multiple URIs on Freenet for overlapping filters
- Use Private Set Intersection (PSI-CA) to prove overlap without revealing IDs
- Calculate BidirectionalMin: Both groups check if overlap meets their threshold
- Alert validators via Signal Poll if both thresholds satisfied: "I have found a sister mesh. Should we begin federation?"

### Zero-Knowledge Discovery (External Only)
- **Scope**: EXTERNAL - discovery between separate Stroma groups
- Bots find each other through "social frequency," not pre-shared keys
- Discovery is **emergent** - no admin coordination required
- If groups share core trusted validators, they independently calculate overlapping URIs
- **Complete Anonymity**: No graph structure exposed to other group

## State Management

### Merkle Tree Storage
- **Never store member lists directly**
- Store Merkle Tree of Proofs representing trust state
- All state transitions must be verifiable through tree structure

### State Stream Monitoring
- Bot must continuously monitor Freenet state stream (real-time, NOT polling)
- **Real-Time Stream**: WebSocket-based state subscription (never use polling/sleep loops)
- React immediately to state changes (e.g., trust threshold violations)
- State changes trigger immediate Signal group actions
- **Trust Standing**: Monitor `Standing = Effective_Vouches - Regular_Flags` in real-time
- **Vouch Invalidation**: Voucher-flaggers excluded from both counts (no 2-point swings)
- **Instant Enforcement**: No grace periods, ejection immediate when `Standing < 0` OR `Effective_Vouches < 2`

## Federation Logic

### Mesh Overlap Calculation (BidirectionalMin)
```
FUNCTION: Calculate_Mesh_Overlap(Bot_A_Set, Bot_B_Set)
USE: Commutative_Encryption(Key_A, Key_B)  # Double-blinding
RESULT: Intersection_Size = COUNT(Encrypted_Set_A == Encrypted_Set_B)

# Each group evaluates with its own threshold
LET: Density_In_A = Intersection_Size / SIZE(Bot_A_Set)
LET: Density_In_B = Intersection_Size / SIZE(Bot_B_Set)

# Retrieve each group's threshold from their Freenet contract
LET: Threshold_A = Get_Group_Config(Bot_A).min_intersection_density_self
LET: Threshold_B = Get_Group_Config(Bot_B).min_intersection_density_self

# Both thresholds must be satisfied (BidirectionalMin)
IF: (Density_In_A >= Threshold_A) AND (Density_In_B >= Threshold_B)
THEN: PROPOSE(Federation_Event)
```

**Key Principles:**
- **Independent Thresholds**: Each group configures its own minimum overlap percentage
- **BidirectionalMin**: Both groups must satisfy their own threshold for federation proposal
- **Asymmetric Groups**: Handles different group sizes fairly (small groups can require higher thresholds)
- **Group Autonomy**: Thresholds stored in each group's Freenet contract, changeable only via group vote

### Federation Contract
- Bots "sign" federation contract on Freenet after human consensus (70% approval)
- **Shared Freenet State**: Unified contract for confederated meshes
- Contract enables cross-mesh vouching (Shadow-Vouch)
- **Bridge Maintenance**: Bot proactively suggests connections when bridge density drops
- **Reciprocal Buffer**: Groups act as mutual buffers for each other
- **Trust Identity**: Member's trust identity precedes them across meshes

## Privacy Guarantees

### Anonymous Operations
- All Freenet operations must preserve anonymity
- Never expose member identities in contract state
- Use hashed identifiers throughout

### Rendezvous Hashing
- Use rendezvous hashing strategy for bot discovery
- Monthly rotation: `URI = Hash(Secret + "2026-01")` (example format)
- Secret derived from group state, not pre-shared

---
description: Freenet contract development with ComposableState and summary-delta synchronization
globs: **/*freenet*.rs,**/*contract*.rs,**/*wasm*.rs,**/*state*.rs
alwaysApply: false
---

# Freenet Integration Standards

## Critical Update (2026-01-26)

**Major Architectural Discovery**: Freenet contracts require `ComposableState` trait for summary-delta synchronization.

**References:**
- [freenet-scaffold](https://github.com/freenet/freenet-scaffold) - Contract development utilities
- [Understanding Delta-Sync](https://freenet.org/news/summary-delta-sync/) - Synchronization approach
- `.cursor/rules/freenet-contract-design.mdc` - Complete ComposableState patterns

**Key Changes**:
- ❌ **OLD**: Store Merkle Trees in contract state
- ✅ **NEW**: Use set-based structures (BTreeSet), generate Merkle Trees on-demand
- ❌ **OLD**: Store Vec<VouchProof> (not easily mergeable)
- ✅ **NEW**: Use HashMap<MemberHash, BTreeSet<MemberHash>> (naturally mergeable)

## Contract Architecture (Eventual Consistency)

### Wasm Contract Pattern with ComposableState
- Write Freenet contracts in Rust/Wasm using `freenet-scaffold` v0.2+
- **Decentralized State**: Contract exists across network, no single server
- **Eventual Consistency**: States merge via summary-delta synchronization (no consensus)
- **Mergeable Structures**: Use CRDT-like patterns (BTreeSet, HashMap, Last-Write-Wins)
- **ComposableState Trait**: All state fields must implement verify, summarize, delta, apply_delta
- **Merkle Trees**: Generated on-demand for ZK-proof verification (not stored in contract)
- **Ephemeral Relationship Data**: Deleted after vetting threshold met
- **State Survives**: Trust state persists even if bot/server crashes

### Group Configuration (Last-Write-Wins)
```rust
use freenet_scaffold::ComposableState;

#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub struct GroupConfigV1 {
    // Consensus thresholds
    config_change_threshold: f32,      // e.g., 0.70 (70%) - used for ALL decisions
    ejection_appeal_threshold: f32,    // e.g., 0.60 (60%)
    
    // Federation parameters
    min_intersection_density: f32,     // e.g., 0.10-0.30 (per-group)
    validator_percentile: u32,         // e.g., 20 (top 20%)
    
    // Trust parameters
    min_vouch_threshold: usize,        // Default: 2 (minimum vouches to stay in group)
    
    // Metadata (for Last-Write-Wins conflict resolution)
    version: u64,                      // Incremented on each change
    last_updated: Timestamp,
}

impl ComposableState for GroupConfigV1 {
    type Summary = (u64, Timestamp);
    type Delta = Option<GroupConfigV1>;
    
    fn apply_delta(&mut self, .., delta: &Option<Self::Delta>) -> Result<(), String> {
        if let Some(new_config) = delta {
            // Last-Write-Wins: Keep config with higher version
            if new_config.version > self.version {
                *self = new_config.clone();
            }
        }
        Ok(())
    }
}
```

**Configuration Management:**
- All config stored in Freenet contract, NOT controlled by operator
- Changes require Signal Poll vote exceeding `config_change_threshold`
- Any member can query: `/mesh config`
- Any member can propose: `/propose-config key=value [reason]`
- Last-Write-Wins conflict resolution via version field

### State Verification (Contract verify() Method)
```rust
impl ComposableState for TrustNetworkState {
    fn verify(&self, _parent: &Self::ParentState, params: &Self::Parameters) -> Result<(), String> {
        // Verify all members have >= min_vouch_threshold EFFECTIVE vouches
        // (considering vouch invalidation when voucher flags)
        for member in &self.members.active {
            let (effective_vouches, standing) = self.calculate_effective_state(member);
            
            // Check effective vouch count (not total vouches)
            if effective_vouches < self.config.min_vouch_threshold {
                return Err(format!(
                    "Member {} has only {} effective vouches (need {})",
                    member, effective_vouches, self.config.min_vouch_threshold
                ));
            }
            
            // Verify standing >= 0
            if standing < 0 {
                return Err(format!("Member {} has negative standing ({})", member, standing));
            }
        }
        
        // [Optional] Verify ZK-proofs (TBD based on Spike Week Q1)
        
        Ok(())
    }
}
```

**Key Change**: Verification uses **effective vouches** (total minus voucher-flaggers), not total vouches.
```

## Emergent Discovery (Shadow Beacons)

### Social Anchor Hashing
- Generate Freenet URI from: `Hash(Sorted(Top-N-Validators))`
- **Dynamic threshold**: Number of validators (N) must be calculated based on group size, not hardcoded
- **Configurable**: Threshold should be configurable to balance Sybil attack resilience vs. discovery probability
- Use most trusted validators (highest number of vouches) up to the threshold
- Sort Signal IDs alphabetically before hashing
- URI changes as group composition changes (organic discovery)
- **Design consideration**: Threshold should scale with group size to maintain security properties

### Bloom Filter Strategy (External Federation Only)
- **Scope**: EXTERNAL - discovery between separate Stroma groups
- Publish "Bloom Filter" at multiple URIs (percentile-based)
- Scan multiple URIs on Freenet for overlapping filters
- Use Private Set Intersection (PSI-CA) to prove overlap without revealing IDs
- Calculate BidirectionalMin: Both groups check if overlap meets their threshold
- Alert validators via Signal Poll if both thresholds satisfied: "I have found a sister mesh. Should we begin federation?"

### Zero-Knowledge Discovery (External Only)
- **Scope**: EXTERNAL - discovery between separate Stroma groups
- Bots find each other through "social frequency," not pre-shared keys
- Discovery is **emergent** - no admin coordination required
- If groups share core trusted validators, they independently calculate overlapping URIs
- **Complete Anonymity**: No graph structure exposed to other group

## State Management

### Merkle Tree Storage
- **Never store member lists directly**
- Store Merkle Tree of Proofs representing trust state
- All state transitions must be verifiable through tree structure

### State Stream Monitoring
- Bot must continuously monitor Freenet state stream (real-time, not polling)
- **Long-Polling/WebSocket**: Efficient real-time updates
- React immediately to state changes (e.g., trust threshold violations)
- State changes trigger immediate Signal group actions
- **Trust Standing**: Monitor `Standing = Vouches - Flags` in real-time
- **Instant Enforcement**: No grace periods, ejection immediate when `Standing < 0`

## Federation Logic

### Mesh Overlap Calculation (BidirectionalMin)
```
FUNCTION: Calculate_Mesh_Overlap(Bot_A_Set, Bot_B_Set)
USE: Commutative_Encryption(Key_A, Key_B)  # Double-blinding
RESULT: Intersection_Size = COUNT(Encrypted_Set_A == Encrypted_Set_B)

# Each group evaluates with its own threshold
LET: Density_In_A = Intersection_Size / SIZE(Bot_A_Set)
LET: Density_In_B = Intersection_Size / SIZE(Bot_B_Set)

# Retrieve each group's threshold from their Freenet contract
LET: Threshold_A = Get_Group_Config(Bot_A).min_intersection_density_self
LET: Threshold_B = Get_Group_Config(Bot_B).min_intersection_density_self

# Both thresholds must be satisfied (BidirectionalMin)
IF: (Density_In_A >= Threshold_A) AND (Density_In_B >= Threshold_B)
THEN: PROPOSE(Federation_Event)
```

**Key Principles:**
- **Independent Thresholds**: Each group configures its own minimum overlap percentage
- **BidirectionalMin**: Both groups must satisfy their own threshold for federation proposal
- **Asymmetric Groups**: Handles different group sizes fairly (small groups can require higher thresholds)
- **Group Autonomy**: Thresholds stored in each group's Freenet contract, changeable only via group vote

### Federation Contract
- Bots "sign" federation contract on Freenet after human consensus (70% approval)
- **Shared Freenet State**: Unified contract for confederated meshes
- Contract enables cross-mesh vouching (Shadow-Vouch)
- **Bridge Maintenance**: Bot proactively suggests connections when bridge density drops
- **Reciprocal Buffer**: Groups act as mutual buffers for each other
- **Trust Identity**: Member's trust identity precedes them across meshes

## Privacy Guarantees

### Anonymous Operations
- All Freenet operations must preserve anonymity
- Never expose member identities in contract state
- Use hashed identifiers throughout

### Rendezvous Hashing
- Use rendezvous hashing strategy for bot discovery
- Monthly rotation: `URI = Hash(Secret + "2026-01")` (example format)
- Secret derived from group state, not pre-shared

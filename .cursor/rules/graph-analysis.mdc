---
description: Internal graph analysis for Blind Matchmaker (MST optimization within single group)
globs: **/*graph*.rs,**/*topology*.rs,**/*matchmaker*.rs
alwaysApply: false
---

# Internal Graph Analysis (Blind Matchmaker)

## Scope: Internal to Single Stroma Group

This module applies ONLY to analyzing and optimizing the trust graph **within a single Stroma Signal group**. This is distinct from external federation between separate groups.

## Purpose

Build a **Minimum Spanning Tree of Trust** within the group using the least number of strategic introductions.

**See**: `docs/ALGORITHMS.md` for complete mathematical foundations, complexity analysis, and worked examples.

## Node Type Classification

### Dynamic Thresholds (Configurable)

**Node Types (Members IN the Signal group):**
- **Bridge**: MIN_VOUCH_THRESHOLD vouches (default: 2) - minimum membership, vulnerable
- **Validator**: >= MIN_VOUCH_THRESHOLD + 1 vouches (default: 3+) - resilient

**Note**: "Invitees" (Leaf Nodes) are OUTSIDE the Signal group with 1 vouch (being vetted). They are NOT part of the internal trust graph analysis.

**Alternative (Percentage-Based):**
```rust
fn calculate_thresholds(group_size: usize, config: &GroupConfig) -> Thresholds {
    if config.use_percentage_thresholds {
        Thresholds {
            min_vouch: config.min_vouch_threshold,  // Always 2 minimum
            validator: max(3, group_size * config.validator_percentile / 100),
        }
    } else {
        Thresholds {
            min_vouch: config.min_vouch_threshold,
            validator: config.validator_threshold_fixed,
        }
    }
}
```

## Topology Analysis

### Graph Construction
```rust
pub struct TrustGraph {
    members: Vec<Hash>,
    vouches: HashMap<Hash, Vec<Hash>>,  // member -> who vouched for them
}

impl TrustGraph {
    fn build_from_freenet(contract: &FreenetContract) -> Self {
        // Construct graph from Freenet Merkle Tree
        // Only knows: who has how many vouches
        // Does NOT know: relationship content, why vouches exist
    }
    
    fn vouch_count(&self, member: &Hash) -> usize {
        self.vouches.get(member).map(|v| v.len()).unwrap_or(0)
    }
    
    /// Classify members IN the Signal group
    /// Note: Invitees (1 vouch, OUTSIDE group) are not represented in this graph
    fn classify_node(&self, member: &Hash, thresholds: &Thresholds) -> NodeType {
        let count = self.vouch_count(member);
        
        if count == thresholds.min_vouch {
            NodeType::Bridge  // 2 vouches, minimum membership, vulnerable
        } else {
            NodeType::Validator  // 3+ vouches, resilient
        }
    }
}
```

### Cluster Detection
```rust
fn identify_internal_clusters(graph: &TrustGraph) -> Vec<Cluster> {
    // Use graph algorithms to find connected components
    // Identifies sub-communities within single group
    
    // Example algorithm: Union-Find or DFS
    let components = find_connected_components(graph);
    
    components.into_iter()
        .map(|members| Cluster {
            members,
            validators: members.iter()
                .filter(|m| graph.classify_node(m) == NodeType::Validator)
                .collect(),
        })
        .collect()
}
```

## Strategic Introduction Matching (Blind Matchmaker - DVR Optimized)

### Goal
Achieve fully intersectional mesh with **maximum distinct Validators**.

**Success Criteria:**
- [ ] High DVR (Distinct Validator Ratio) ‚Äî prioritize non-overlapping voucher sets
- [ ] No vulnerable Bridges (everyone has ‚â• 3 vouches for resilience)
- [ ] No disconnected islands (all clusters connected)
- [ ] Every member seen by 2+ perspectives from different clusters

**See**: `.beads/blind-matchmaker-dvr.bead` for full algorithm

### DVR-Optimized Algorithm (Hybrid)
```rust
fn generate_strategic_introductions(
    graph: &TrustGraph,
    clusters: &[Cluster],
) -> Vec<IntroductionPair> {
    let mut introductions = Vec::new();
    
    // Track vouchers used by existing distinct Validators
    let mut used_vouchers: HashSet<Hash> = HashSet::new();
    for dv in graph.get_distinct_validators() {
        used_vouchers.extend(graph.get_vouchers(dv));
    }
    
    let mut remaining_bridges: Vec<_> = graph.get_vulnerable_bridges().collect();
    
    // Priority 0 (NEW): DVR Optimization ‚Äî create DISTINCT Validators
    for bridge in &remaining_bridges.clone() {
        let bridge_cluster = clusters.find_cluster_for(bridge);
        
        // Find validator that:
        // 1. Is in different cluster
        // 2. NOT already used by another distinct Validator
        let dvr_optimal = graph.get_validators()
            .filter(|v| {
                let v_cluster = clusters.find_cluster_for(v);
                v_cluster != bridge_cluster  // Different cluster
                && !used_vouchers.contains(v)  // Not used by another distinct Validator
            })
            .max_by_key(|v| graph.centrality(v));
        
        if let Some(voucher) = dvr_optimal {
            introductions.push(IntroductionPair {
                person_a: *bridge,
                person_b: voucher,
                reason: "Create distinct Validator (DVR optimization)",
                priority: 0,  // Highest priority
                dvr_optimal: true,
            });
            
            // Reserve this voucher and bridge's voucher set
            used_vouchers.extend(graph.get_vouchers(*bridge));
            used_vouchers.insert(voucher);
            
            remaining_bridges.retain(|b| b != bridge);  // Handled
        }
    }
    
    // Priority 1: MST Fallback ‚Äî strengthen remaining Bridges (any cross-cluster)
    for bridge in &remaining_bridges {
        let bridge_cluster = clusters.find_cluster_for(bridge);
        
        // Find ANY validator from DIFFERENT cluster (no used_vouchers constraint)
        let mst_fallback = graph.get_validators()
            .filter(|v| {
                let v_cluster = clusters.find_cluster_for(v);
                v_cluster != bridge_cluster
            })
            .max_by_key(|v| graph.vouch_count(v));
        
        if let Some(voucher) = mst_fallback {
            introductions.push(IntroductionPair {
                person_a: *bridge,
                person_b: voucher,
                reason: "Strengthen Bridge (MST fallback)",
                priority: 1,
                dvr_optimal: false,
            });
        }
    }
    
    // Priority 2: Link disconnected islands
    if clusters.len() > 1 {
        // Connect top validators from each island
        for (island_a, island_b) in disconnected_island_pairs(clusters) {
            introductions.push(IntroductionPair {
                person_a: island_a.top_validator(),
                person_b: island_b.top_validator(),
                reason: "Bridge disconnected islands",
                priority: 2,
            });
        }
    }
    
    introductions.sort_by_key(|i| i.priority);
    introductions
}
```

### Efficiency Math
**Total new interactions needed:**
```
N(Leaves) + I(Disconnected_Islands) = Total
```

**Example:**
- 20-person group
- 5 Leaves (need connection to validator)
- 2 disconnected islands (need 1 bridge)
- Total: 5 + 1 = 6 new interactions
- Result: Entire 20-person group fully vetted

## Member Experience

### Proactive Suggestions
```
Bot ‚Üí Bridge Member (2 vouches, via PM):
"üí° Network Strengthening: You currently have 2 vouches (minimum required).
 I can introduce you to a Validator from a different part of the network
 to broaden your connections and make you more resilient.
 
 Would you like this introduction?"

[Bot creates Signal Poll: "Accept introduction?" with options: Accept, Decline]
```

### Strategic Pairing Notification
```
Bot ‚Üí Validator (via PM):
"üîó Strategic Introduction: I've identified a member (MemberHash_42) who
 would benefit from a connection to your part of the network.
 
 This helps strengthen our overall mesh topology. Would you be willing
 to have a brief intro chat? React with ‚úÖ"
```

## Privacy Boundaries

### What Bot Knows (Internal)
- ‚úÖ How many vouches each member has
- ‚úÖ Which members are in which internal clusters
- ‚úÖ Graph topology (who is Bridge vs Validator)
- ‚úÖ Optimal pairings for MST

### What Bot Does NOT Know
- ‚ùå Why members vouch for each other
- ‚ùå Relationship content or history
- ‚ùå Social graph details beyond vouch counts
- ‚ùå Personal information or identities (only hashes)

### Member Privacy
- Members never know WHY bot suggested an introduction
- Bot doesn't explain clustering logic to members
- Introductions feel natural, not algorithmic
- "Blind Matchmaker" = members don't see the optimization logic

## Contrast with External Federation

**Internal (Blind Matchmaker):**
- Goal: Optimize topology within single group
- Knowledge: Graph structure for strategic matching
- Privacy: Content of relationships unknown
- Outcome: Fully intersectional mesh

**External (Blind Rendezvous):**
- Goal: Discover and federate separate groups
- Knowledge: ZERO - only overlap count
- Privacy: Complete - no graph structure revealed
- Outcome: Cross-mesh vouching capability

## Implementation Requirements

### Graph Library
- Use `petgraph` crate for topology analysis
- Implement algorithms (see `docs/ALGORITHMS.md` for pseudocode):
  - **Union-Find** for connected components detection (O(N √ó Œ±(N)))
  - **Brandes' Algorithm** for betweenness centrality (O(N √ó E))
  - **Greedy MST Construction** for strategic introductions (O(N √ó E))

### Optimization
- Run topology analysis when:
  - New member admitted
  - Member ejected (topology may have changed)
  - Member requests `/mesh status`
- Cache analysis results, invalidate on state change
- Performance targets (see `docs/ALGORITHMS.md` Complexity Analysis):
  - 20 members: < 10ms
  - 100 members: < 50ms
  - 500 members: < 200ms
  - 1000 members: < 500ms

### Privacy Preservation
- Never log relationship details
- Never expose why bot suggested specific pairing
- Graph analysis results stored only in memory, never persisted
- Use hashed identifiers throughout
- See `docs/ALGORITHMS.md` "Privacy Guarantees" section for formal analysis

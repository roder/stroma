---
description: Operator CLI interface design and command patterns
globs: **/*cli*.rs,**/*main.rs
alwaysApply: false
---

# Operator CLI Standards

## Design Principle

**Operator CLI is for SERVICE MANAGEMENT ONLY** - not trust operations.

**Critical**: Operator cannot execute membership changes, trust operations, or override group decisions. CLI reflects operator least privilege principle.

## Command Structure

### Top-Level Commands

```bash
stroma <COMMAND> [OPTIONS]

Commands:
  bootstrap    Initialize new group with seed members (one-time only)
  run          Run bot service (normal operation)
  status       Show bot health and embedded kernel status
  verify       Verify configuration and state integrity
  export-pepper Export group pepper for backup (encrypted)
  version      Show version information
  help         Show help message
```

## Command Specifications

### `bootstrap` - Initialize New Group

**Purpose**: One-time setup for 3-member seed group

**Usage:**
```bash
stroma bootstrap \
  --config <PATH> \
  --signal-phone <PHONE> \
  --seed-members <@USER1,@USER2,@USER3> \
  --group-name <NAME>
```

**Options:**
- `--config <PATH>` - Path to config.toml (required)
- `--signal-phone <PHONE>` - Bot's Signal phone number (required)
- `--seed-members <CSV>` - Comma-separated seed members: @Alice,@Bob,@Carol (required, exactly 3)
- `--group-name <NAME>` - Human-readable group name (required)

**What It Does:**
1. Generates group pepper (if not exists) and writes to pepper_file
2. Initializes embedded Freenet kernel in dark mode
3. Hashes all 3 seed member Signal IDs with pepper
4. Creates initial vouch graph (triangle: all vouch each other)
5. Deploys TrustNetworkState contract to embedded kernel
6. Writes contract_key to config.toml
7. Outputs confirmation and contract details

**Validation:**
- Exactly 3 seed members (no more, no less)
- Valid phone number format
- Config file writable
- Signal authentication succeeds

**Output:**
```
‚úÖ Bootstrap Complete

Embedded Freenet Kernel: Initialized (dark mode)
Contract Deployed: 0x123abc...
Contract key written to: /etc/stroma/config.toml

Seed Members:
- @Alice (hash: 0xabc...)
- @Bob (hash: 0xdef...)
- @Carol (hash: 0x789...)

All members have 2 vouches each (initial triangle).
Group pepper: /var/lib/stroma/pepper.secret (BACKUP THIS!)

Ready to start bot service: stroma run --config /etc/stroma/config.toml
```

**Error Handling:**
- Signal authentication failure ‚Üí clear error message with remediation
- Invalid seed members count ‚Üí show usage, require exactly 3
- Config file not writable ‚Üí show permission error
- Pepper already exists ‚Üí ask for confirmation before overwriting

---

### `run` - Normal Operation

**Purpose**: Run bot service with embedded Freenet kernel

**Usage:**
```bash
stroma run --config <PATH>
```

**Options:**
- `--config <PATH>` - Path to config.toml (required)
- `--log-level <LEVEL>` - Override log level: trace, debug, info, warn, error (optional)

**What It Does:**
1. Loads configuration from config.toml
2. Initializes embedded Freenet kernel with configured mode
3. Loads existing contract (contract_key from config)
4. Authenticates with Signal
5. Starts event loop:
   - Monitors Freenet state stream
   - Handles Signal messages
   - Performs health checks (every N minutes)
6. Runs until interrupted (Ctrl+C or SIGTERM)

**Output (Continuous):**
```
[2026-01-27 10:23:45] INFO  Stroma v1.0.0 starting...
[2026-01-27 10:23:46] INFO  Config loaded: /etc/stroma/config.toml
[2026-01-27 10:23:47] INFO  Embedded Freenet kernel initialized (dark mode)
[2026-01-27 10:23:48] INFO  Contract loaded: 0x123abc...
[2026-01-27 10:23:49] INFO  Signal authenticated: +1234567890
[2026-01-27 10:23:50] INFO  Bot service running (Press Ctrl+C to stop)
[2026-01-27 10:23:50] INFO  Subscribed to contract state stream
[2026-01-27 10:24:00] INFO  Health check: All members pass trust thresholds
...
```

**Graceful Shutdown:**
```
^C
[2026-01-27 10:30:12] INFO  Received shutdown signal
[2026-01-27 10:30:12] INFO  Stopping state stream monitoring
[2026-01-27 10:30:13] INFO  Flushing embedded Freenet kernel state
[2026-01-27 10:30:14] INFO  Disconnecting from Signal
[2026-01-27 10:30:15] INFO  Shutdown complete
```

---

### `status` - Health Check

**Purpose**: Show bot and embedded kernel health

**Usage:**
```bash
stroma status [--config <PATH>]
```

**Options:**
- `--config <PATH>` - Path to config.toml (optional, defaults to /etc/stroma/config.toml)

**Output:**
```
‚úÖ Stroma Status

Bot: Running
Embedded Freenet Kernel: Active (dark mode)
Signal Connection: Connected (+1234567890)
Contract State: Synced

Group: My Trust Network
Contract: 0x123abc...
Members: 47
Mesh Health: 100/100 ‚úÖ (38% density)

Last Health Check: 2 minutes ago
Uptime: 3 days, 5 hours, 23 minutes

Embedded Kernel Stats:
- Data dir: /var/lib/stroma/freenet
- Network peers: 15
- Last sync: 30 seconds ago
```

**If bot not running:**
```
‚ùå Stroma Status

Bot: Not Running
Embedded Freenet Kernel: N/A

Run with: stroma run --config /etc/stroma/config.toml
```

---

### `verify` - Validate Configuration

**Purpose**: Verify config and state integrity without starting bot

**Usage:**
```bash
stroma verify --config <PATH>
```

**Options:**
- `--config <PATH>` - Path to config.toml (required)

**Checks:**
- Config file exists and is readable
- All required fields present
- Pepper file exists and is readable (600 permissions)
- Contract key is valid format
- Data directories exist and are writable
- Signal phone number is valid format

**Output (Success):**
```
‚úÖ Configuration Valid

Config: /etc/stroma/config.toml
Pepper: /var/lib/stroma/pepper.secret ‚úÖ (600 permissions)
Contract: 0x123abc... ‚úÖ (valid format)
Data dirs: ‚úÖ (exist and writable)
Signal phone: +1234567890 ‚úÖ

Ready to run: stroma run --config /etc/stroma/config.toml
```

**Output (Errors):**
```
‚ùå Configuration Invalid

Config: /etc/stroma/config.toml ‚úÖ
Pepper: /var/lib/stroma/pepper.secret ‚ùå (not found)
Contract: (empty) ‚ö†Ô∏è  (run bootstrap first)
Data dirs: /var/lib/stroma ‚ùå (not writable)

Errors:
- Pepper file not found: Generate with `openssl rand -base64 32 > pepper.secret`
- Data directory not writable: Check permissions with `ls -la /var/lib/stroma`
```

---

### `export-pepper` - Backup Group Pepper

**Purpose**: Export pepper for secure backup (encrypted)

**Usage:**
```bash
stroma export-pepper \
  --config <PATH> \
  --output <FILE> \
  --encrypt
```

**Options:**
- `--config <PATH>` - Path to config.toml (required)
- `--output <FILE>` - Output file for encrypted pepper (required)
- `--encrypt` - Encrypt with passphrase (recommended)

**Interactive:**
```bash
stroma export-pepper --config config.toml --output pepper.backup --encrypt

Enter passphrase for encryption: ********
Confirm passphrase: ********

‚úÖ Pepper exported and encrypted

Source: /var/lib/stroma/pepper.secret
Output: pepper.backup (encrypted)

Store this file in a secure location!
To restore: stroma import-pepper --input pepper.backup
```

**Warning:**
```
‚ö†Ô∏è  WARNING: The pepper is the cryptographic root of your group's identity.

- If lost: All member hashes become invalid (breaks group)
- If leaked: Group privacy could be compromised
- If changed: All existing members cannot be re-hashed

BACKUP SECURELY AND NEVER LOSE THIS FILE!
```

---

### `version` - Version Information

**Purpose**: Show version and build information

**Usage:**
```bash
stroma version
```

**Output:**
```
Stroma v1.0.0

Build:
- Rust: 1.93.0
- Target: x86_64-unknown-linux-musl
- Features: embedded-kernel
- Embedded Freenet: v0.1.107

Dependencies:
- freenet-stdlib: 0.1.30
- winterfell: 0.9.1
- ring: 0.17.8
- tokio: 1.35.1

Built: 2026-01-27 10:23:45 UTC
Commit: abc123def456
```

---

## Forbidden Commands (Operator Least Privilege)

### ‚ùå NEVER Implement These

**Membership Commands:**
```bash
# ‚ùå FORBIDDEN
stroma add-member @User         # Violates automatic-only rule
stroma remove-member @User      # Violates automatic-only rule
stroma override-ejection @User  # Violates trust protocol
```

**Trust Commands:**
```bash
# ‚ùå FORBIDDEN
stroma vouch @User              # Only members via Signal bot
stroma flag @User               # Only members via Signal bot
stroma reset-standing @User     # Violates immutability
```

**Configuration Commands:**
```bash
# ‚ùå FORBIDDEN
stroma set-config key=value     # Requires group vote, not operator
stroma force-config update      # Bypasses consensus
stroma federate-with <GROUP>    # Requires group vote
```

**Why Forbidden**: Operator is service runner, not privileged admin. All trust operations go through Signal bot with Freenet verification.

## Future Commands (Phase 4+)

### `rotate` - Shadow Handover (NOT IN MVP)

**Purpose**: Rotate bot Signal identity while preserving cryptographic trust

**Status**: DEFERRED TO PHASE 4+

**Usage (Future):**
```bash
stroma rotate \
  --config <PATH> \
  --new-phone <PHONE> \
  --reason <REASON>
```

**Options:**
- `--config <PATH>` - Path to config.toml (required)
- `--new-phone <PHONE>` - New Signal phone number (required)
- `--reason <REASON>` - Rotation reason: "ban_recovery", "rotation", "security_upgrade" (required)

**What It Will Do (Phase 4+):**
1. Generate new bot keypair
2. Create Succession Document signed by old bot key
3. Deploy Succession Document to Freenet contract
4. Start Bot-New with new Signal credentials
5. Validate cryptographic succession
6. Announce identity change to Signal group
7. Gracefully shutdown Bot-Old

**MVP Workaround**: Manually register new Signal account and restart service.

See `.beads/federation-roadmap.bead` for Shadow Handover Protocol specification.

## CLI Implementation Patterns

### Use `clap` for Argument Parsing

```rust
use clap::{Parser, Subcommand};

#[derive(Parser)]
#[command(name = "stroma")]
#[command(about = "Stroma trust network bot", long_about = None)]
#[command(version)]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    /// Initialize new group with seed members (one-time only)
    Bootstrap {
        /// Path to config file
        #[arg(short, long)]
        config: PathBuf,
        
        /// Bot's Signal phone number
        #[arg(long)]
        signal_phone: String,
        
        /// Seed members (exactly 3): @Alice,@Bob,@Carol
        #[arg(long)]
        seed_members: String,
        
        /// Group name
        #[arg(long)]
        group_name: String,
    },
    
    /// Run bot service (normal operation)
    Run {
        /// Path to config file
        #[arg(short, long)]
        config: PathBuf,
        
        /// Override log level
        #[arg(long)]
        log_level: Option<String>,
    },
    
    /// Show bot health status
    Status {
        /// Path to config file
        #[arg(short, long, default_value = "/etc/stroma/config.toml")]
        config: PathBuf,
    },
    
    /// Verify configuration and state
    Verify {
        /// Path to config file
        #[arg(short, long)]
        config: PathBuf,
    },
    
    /// Export group pepper for backup
    ExportPepper {
        /// Path to config file
        #[arg(short, long)]
        config: PathBuf,
        
        /// Output file
        #[arg(short, long)]
        output: PathBuf,
        
        /// Encrypt with passphrase
        #[arg(long)]
        encrypt: bool,
    },
}
```

### Main Entry Point

```rust
#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let cli = Cli::parse();
    
    match cli.command {
        Commands::Bootstrap { config, signal_phone, seed_members, group_name } => {
            cli::bootstrap::run(config, signal_phone, seed_members, group_name).await?;
        }
        Commands::Run { config, log_level } => {
            cli::run::run(config, log_level).await?;
        }
        Commands::Status { config } => {
            cli::utils::status(config).await?;
        }
        Commands::Verify { config } => {
            cli::utils::verify(config).await?;
        }
        Commands::ExportPepper { config, output, encrypt } => {
            cli::utils::export_pepper(config, output, encrypt).await?;
        }
    }
    
    Ok(())
}
```

## Error Messages (User-Friendly)

### Good Error Messages

```rust
// ‚úÖ GOOD: Clear, actionable, helpful
return Err(format!(
    "Pepper file not found: {}\n\n\
     Generate with: openssl rand -base64 32 > pepper.secret\n\
     Or run: stroma bootstrap --config config.toml ...",
    pepper_path.display()
).into());

// ‚úÖ GOOD: Explains why and how to fix
return Err(format!(
    "Invalid seed members count: {} (need exactly 3)\n\n\
     Seed group must have exactly 3 members for initial triangle.\n\
     Example: --seed-members @Alice,@Bob,@Carol",
    count
).into());
```

### Bad Error Messages

```rust
// ‚ùå BAD: Technical jargon, no context
return Err("IO error".into());

// ‚ùå BAD: No remediation guidance
return Err("Config invalid".into());

// ‚ùå BAD: Exposes internal details
return Err(format!("Panic at line 123 in module foo: {:?}", e).into());
```

## Output Formatting

### Use Emojis for Status

```rust
// ‚úÖ Success
println!("‚úÖ Bootstrap Complete");

// ‚ùå Error
eprintln!("‚ùå Configuration Invalid");

// ‚ö†Ô∏è  Warning
println!("‚ö†Ô∏è  Pepper file has insecure permissions (should be 600)");

// üîç Info
println!("üîç Verifying configuration...");
```

### Structured Output

```rust
// Status command output
println!("‚úÖ Stroma Status\n");
println!("Bot: {}", status.bot_state);
println!("Embedded Freenet Kernel: {} ({})", status.kernel_state, status.kernel_mode);
println!("Signal Connection: {} ({})", status.signal_state, status.phone);
println!();
println!("Group: {}", group_name);
println!("Contract: {}", contract_key);
println!("Members: {}", member_count);
println!("Mesh Health: {}/100 {} ({}% density)", health_score, emoji, density);
```

## Configuration File Handling

### Load Config

```rust
use serde::Deserialize;
use std::fs;

#[derive(Deserialize)]
struct Config {
    signal: SignalConfig,
    freenet: FreenetConfig,
    group: GroupConfig,
    bot: BotConfig,
    logging: LoggingConfig,
}

fn load_config(path: &Path) -> Result<Config, Error> {
    let contents = fs::read_to_string(path)
        .map_err(|e| format!("Failed to read config: {}", e))?;
    
    toml::from_str(&contents)
        .map_err(|e| format!("Failed to parse config: {}\n\nCheck TOML syntax", e))
}
```

### Write Contract Key After Bootstrap

```rust
fn write_contract_key(config_path: &Path, contract_key: &str) -> Result<(), Error> {
    // Read existing config
    let mut contents = fs::read_to_string(config_path)?;
    
    // Update contract_key line
    // Replace: contract_key = ""
    // With: contract_key = "0x123abc..."
    contents = contents.replace(
        r#"contract_key = """#,
        &format!(r#"contract_key = "{}""#, contract_key),
    );
    
    // Write back
    fs::write(config_path, contents)?;
    
    Ok(())
}
```

## Security Constraints

### Never Accept Trust Operations from CLI

```rust
// ‚úÖ REQUIRED: Reject any attempt to execute trust operations via CLI
match cli.command {
    Commands::AddMember { .. } => {
        eprintln!("‚ùå Error: Operators cannot manually add members");
        eprintln!("\nMembership changes are automatic based on Freenet contract state.");
        eprintln!("Members use /invite command via Signal bot.");
        std::process::exit(1);
    }
    _ => { /* ... */ }
}
```

### Never Show Cleartext Signal IDs

```rust
// ‚úÖ GOOD: Show hashes only
println!("Seed Members:");
println!("- @Alice (hash: 0xabc...)");

// ‚ùå BAD: Shows cleartext Signal IDs
println!("Seed Members:");
println!("- Alice (+1234567890)");  // ‚ùå FORBIDDEN - violates privacy
```

## Help Text

### Command Help

```bash
$ stroma bootstrap --help

Initialize new group with seed members (one-time only)

Usage: stroma bootstrap --config <PATH> --signal-phone <PHONE> --seed-members <MEMBERS> --group-name <NAME>

Options:
  -c, --config <PATH>          Path to config.toml
      --signal-phone <PHONE>   Bot's Signal phone number
      --seed-members <MEMBERS> Exactly 3 seed members: @Alice,@Bob,@Carol
      --group-name <NAME>      Human-readable group name
  -h, --help                   Print help

Example:
  stroma bootstrap \
    --config /etc/stroma/config.toml \
    --signal-phone "+1234567890" \
    --seed-members @Alice,@Bob,@Carol \
    --group-name "My Trust Network"
```

### Top-Level Help

```bash
$ stroma --help

Stroma trust network bot

Usage: stroma <COMMAND>

Commands:
  bootstrap      Initialize new group with seed members (one-time)
  run            Run bot service (normal operation)
  status         Show bot health and embedded kernel status
  verify         Verify configuration and state integrity
  export-pepper  Export group pepper for backup
  version        Show version information
  help           Print this message or the help of the given subcommand(s)

Options:
  -h, --help     Print help
  -V, --version  Print version

For more information on a specific command:
  stroma <COMMAND> --help
```

## Testing CLI Commands

### Unit Tests

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_parse_seed_members() {
        let input = "@Alice,@Bob,@Carol";
        let members = parse_seed_members(input).unwrap();
        
        assert_eq!(members.len(), 3);
        assert_eq!(members[0], "Alice");
        assert_eq!(members[1], "Bob");
        assert_eq!(members[2], "Carol");
    }
    
    #[test]
    fn test_reject_invalid_seed_count() {
        let input = "@Alice,@Bob";  // Only 2
        let result = parse_seed_members(input);
        
        assert!(result.is_err());
        assert!(result.unwrap_err().contains("exactly 3"));
    }
}
```

### Integration Tests

```rust
#[tokio::test]
async fn test_bootstrap_command() {
    let temp_dir = tempdir().unwrap();
    let config_path = temp_dir.path().join("config.toml");
    
    // Create minimal config
    create_test_config(&config_path);
    
    // Run bootstrap
    let result = cli::bootstrap::run(
        config_path.clone(),
        "+1234567890".to_string(),
        "@Alice,@Bob,@Carol".to_string(),
        "Test Group".to_string(),
    ).await;
    
    assert!(result.is_ok());
    
    // Verify contract_key was written
    let config_contents = fs::read_to_string(config_path).unwrap();
    assert!(config_contents.contains("contract_key = \"0x"));
}
```

## Embedded Kernel Lifecycle

### Startup Sequence

```rust
async fn start_embedded_kernel(config: &FreenetConfig) -> Result<FreenetKernel, Error> {
    println!("üîç Initializing embedded Freenet kernel...");
    
    let kernel = FreenetKernel::builder()
        .mode(NetworkMode::Dark)  // Anonymous routing
        .data_dir(&config.data_dir)
        .build()
        .await
        .map_err(|e| format!("Failed to start embedded kernel: {}", e))?;
    
    println!("‚úÖ Embedded Freenet kernel initialized (dark mode)");
    
    Ok(kernel)
}
```

### Shutdown Sequence

```rust
async fn shutdown_gracefully(kernel: FreenetKernel, signal: SignalBot) -> Result<(), Error> {
    println!("\nüîç Shutting down gracefully...");
    
    // Stop monitoring state stream
    println!("  Stopping state stream monitoring...");
    
    // Flush kernel state
    println!("  Flushing embedded Freenet kernel state...");
    kernel.flush().await?;
    
    // Disconnect Signal
    println!("  Disconnecting from Signal...");
    signal.disconnect().await?;
    
    println!("‚úÖ Shutdown complete");
    
    Ok(())
}
```

## See Also

- `.beads/architecture-decisions.bead` - Decision #9 (embedded kernel), #10 (distribution)
- `docs/OPERATOR-GUIDE.md` - Complete operator documentation
- `.cursor/rules/freenet-contract-design.mdc` - Contract patterns
- `.cursor/rules/security-guardrails.mdc` - Operator constraints

---

**Last Updated**: 2026-01-27

---
description: Security guardrails and quality standards that must never be violated
alwaysApply: true
---

# Security & Quality Guardrails

**Philosophical Grounding**: Security guardrails embody the "protect irreversible harms first" principle. Anonymity leaks, trust map seizure, and power centralization cannot be undone — they take priority over recoverable concerns like ease of use or faster onboarding. See `.beads/philosophical-foundations.bead` for the full decision framework.

## Threat Model: Trust Map Seizure

**Primary Threat**: State-level adversary or compromised operator attempts to seize trust map to identify group members and relationships.

**Three-Layer Defense** (ALL layers REQUIRED):
1. **No Centralized Storage**: Freenet distributed (no single seizure point)
2. **Cryptographic Privacy**: Only hashes in memory/storage (zeroization)
3. **Metadata Isolation**: 1-on-1 PMs, operator least-privilege

**Result**: Even if adversary compromises bot/server, they only get hashes and topology, not identities or relationship details.

## Threat Model: Coordinated Infiltration

**Secondary Threat**: Coordinated bad actors attempt to infiltrate by exploiting same-cluster vouching.

**Attack Vector**:
1. Bad actor Alice joins legitimately (meets cross-cluster requirement)
2. Alice invites confederate Bob, vouches for Bob
3. Alice's friend Carol (same cluster) vouches for Bob
4. If same-cluster vouching allowed: Bob admitted with 2 same-cluster vouches
5. Repeat: Alice, Bob, Carol form infiltration cluster that self-amplifies
6. **Result**: Group compromised from within

**Defense: Cross-Cluster Vouching Requirement** (MANDATORY):
- Every new member MUST have vouches from 2+ DIFFERENT clusters
- Same-cluster vouching does NOT count toward admission
- Prevents self-amplification of infiltration clusters
- Forces bad actors to deceive multiple independent social contexts

**Result**: Even if one cluster is compromised, they cannot unilaterally expand. Infiltration requires building genuine trust across multiple independent parts of the network — which doesn't scale for attackers.

**See**: `.beads/cross-cluster-requirement.bead` for full rationale and implementation

## Critical Security Constraints

### Trust Map Protection Violations (BLOCK)
- ❌ **NEVER** store trust map in centralized database (Layer 1 violation)
- ❌ **NEVER** store Signal IDs in cleartext (Layer 2 violation)
- ❌ **NEVER** log member identifiers to disk (Layer 2 violation)
- ❌ **NEVER** expose vetting in group chat (Layer 3 violation)
- ❌ **NEVER** expose social graph structure to external parties
- ❌ **NEVER** use pre-shared keys for federation (creates seizure target)
- ❌ **NEVER** use deterministic hashing (must use HMAC with group-secret pepper)
- ❌ **NEVER** retain vetting session data after admission (must be ephemeral)
- ❌ **NEVER** allow operator to export or query trust map manually

### Memory Safety Violations (BLOCK)
- ❌ **NEVER** leave sensitive buffers in memory after use
- ❌ **NEVER** skip zeroization of cryptographic keys
- ❌ **NEVER** use `unsafe` blocks without explicit security review

### UX Boundary Violations (BLOCK)
- ❌ **NEVER** require members to generate ZK/STARK proofs
- ❌ **NEVER** require members to sign cryptographic messages (beyond Signal's built-in)
- ❌ **NEVER** require members to install software beyond Signal
- ❌ **NEVER** require members to handle or manage cryptographic keys
- ❌ **NEVER** expose proof data, Merkle trees, or hashes to members
- ❌ **NEVER** design flows where members transmit proofs to the bot
- ✅ **ALWAYS** keep ALL cryptographic operations inside the bot
- ✅ **ALWAYS** use Signal commands as the ONLY member interface
- ✅ **ALWAYS** abstract technical complexity from non-technical users

**Rationale**: Stroma is designed for non-technical users. Signal is the only interface. The bot is the sole cryptographic actor — it generates proofs, verifies proofs, computes Merkle roots, and submits outcomes. Members simply send commands like `/vouch @Alice`.

### Phase 0 Trust Model (ACCEPT)

**Bot is trusted in Phase 0**. This is an intentional architectural decision, not a gap to be fixed.

**Why Bot-Trust is Acceptable**:
1. **Contract STARK doesn't help**: Bot has all inputs to forge valid proofs anyway
2. **Signal attestation doesn't help**: Proves sender, not message content
3. **Member proofs violate UX**: Members only use Signal commands
4. **Operator accountability**: Social/legal consequences provide sufficient deterrent

**What Provides Defense**:
- Cross-cluster vouching requirement (can't rubber-stamp confederates)
- Blind Matchmaker DVR (limits attacker placement for colluding vouchers)
- Federation cross-validation (different operators must agree on cross-mesh)

**AGENT GUIDANCE**: Do NOT add complexity pursuing "trustlessness" that doesn't actually achieve it. The bot being trusted is a known, accepted constraint for Phase 0. Focus on the protections that DO work (cross-cluster, DVR, federation).

**See**: `.beads/architecture-decisions.bead` section "Trustlessness Analysis" for full rationale.

### Trust Model Violations (BLOCK)
- ❌ **NEVER** add grace periods for ejection (no 48-hour warnings, no re-verification windows)
- ❌ **NEVER** make trust decisions without Freenet verification
- ❌ **NEVER** bypass ZK-proof verification
- ❌ **NEVER** allow `Standing < 0` to persist (immediate ejection required)
- ❌ **NEVER** allow vouch count < MIN_VOUCH_THRESHOLD (immediate ejection required)
- ❌ **NEVER** use polling for state monitoring (must use real-time stream)
- ❌ **NEVER** admit members with < 2 vouches from different clusters (cross-cluster REQUIRED)
- ❌ **NEVER** accept same-cluster vouches toward admission threshold (infiltration vector)

### Cross-Cluster Vouching Violations (BLOCK - Infiltration Prevention)
- ❌ **NEVER** admit member if both vouchers are from the same cluster
- ❌ **NEVER** allow same-cluster vouching to count toward admission
- ❌ **NEVER** bypass cluster detection for admission decisions
- ✅ **ALWAYS** verify vouchers are from different clusters before admission
- ✅ **ALWAYS** reject admission if cross-cluster requirement not met
- ✅ **ALWAYS** enforce cross-cluster after bootstrap phase (2+ clusters exist)

**Bootstrap Exception**: First 3-5 members (single cluster) exempt until multiple clusters form.

**See**: `.beads/cross-cluster-requirement.bead`

### Vouch Invalidation Violations (BLOCK - NO UNILATERAL 2-POINT SWINGS)
- ❌ **NEVER** allow a single member's action to cause 2-point standing swing
- ❌ **NEVER** count a flag from a voucher as BOTH invalidating vouch AND adding flag
- ❌ **NEVER** implement: `Standing_change = -2` from single member's flag
- ✅ **ALWAYS** exclude voucher-flaggers from BOTH vouch count AND flag count
- ✅ **ALWAYS** ensure: flag from voucher = vouch invalidation only (1-point max effect)
- ✅ **ALWAYS** require multiple independent flags from non-vouchers for standing-based ejection

**Mathematical Enforcement**:
```rust
// ✅ REQUIRED PATTERN - Separate calculations
Voucher_Flaggers = All_Vouchers ∩ All_Flaggers
Effective_Vouches = All_Vouchers.len() - Voucher_Flaggers.len()
Regular_Flags = All_Flaggers.len() - Voucher_Flaggers.len()
Standing = Effective_Vouches as i32 - Regular_Flags as i32

// ❌ FORBIDDEN PATTERN - Any implementation that produces 2-point swings
if alice_flags_bob {
    bob_standing -= 2; // ❌ WRONG
    bob_standing -= 1; // ✅ CORRECT (vouch invalidation only)
}
```

## Supply Chain Security

### Mandatory Audits
- **Always** run `cargo-deny` before merging
- **Always** run `cargo-crev` for cryptographic verification
- **Always** review dependency changes for security implications

### Dependency Management
- Keep attack surface minimal
- Monitor binary size - significant increases indicate bloat
- Prefer well-audited crates over convenience libraries

## Code Review Checklist

### Before Merging
- [ ] No `unsafe` blocks without security justification
- [ ] No Signal IDs stored in cleartext
- [ ] All sensitive buffers zeroized
- [ ] Freenet state verified before Signal actions
- [ ] ZK-proofs verified for all trust operations
- [ ] No pre-shared keys in codebase
- [ ] `cargo-deny` and `cargo-crev` checks pass

### Gastown-Specific Checks
- [ ] Review Refinery output for unsafe blocks
- [ ] Check git hooks for accidental key commits
- [ ] Monitor Deacon build size reports
- [ ] Verify Beads contain security constraints

## Sandboxing Requirements

### Production Environment
- Bot must run in seccomp sandbox
- Only allow Signal and Freenet node traffic
- Block all other network access
- Static MUSL binary required

## Logging Security (Three-Layer Model)

**Threat Model**: Compromised bot logs must NOT enable trust map reconstruction or state recovery.

### Four Layers of Log Protection

| Layer | What's Protected | Rule |
|-------|------------------|------|
| **PII** | Signal IDs, phone numbers, names | ❌ NEVER log |
| **Trust Map** | Who vouched/flagged whom, relational data | ❌ NEVER log |
| **Persistence** | Chunk holder locations, attestations | ❌ NEVER log (even if computable) |
| **Federation** | Federated group IDs, names, URIs, overlap data | ❌ NEVER log |

### Logging Violations (BLOCK)

```rust
// ❌ FORBIDDEN - reveals trust map
tracing::info!("Vouch recorded: {} vouched for {}", voucher_hash, target_hash);
tracing::debug!("Flag from {} to {}", flagger_hash, target_hash);
tracing::info!("Ejecting {} (standing: {})", member_hash, standing);

// ❌ FORBIDDEN - reveals persistence locations  
tracing::info!("Chunk stored at peer {}", holder_hash);
tracing::debug!("Attestation received from {}", holder_hash);

// ❌ FORBIDDEN - reveals PII
tracing::info!("Processing message from {}", signal_id);

// ❌ FORBIDDEN - reveals federation relationships
tracing::info!("Federated with group {}", group_hash);
tracing::debug!("PSI-CA overlap: {} members", overlap_count);
tracing::info!("Discovery: found group at {}", uri);
```

### Allowed Logging Patterns

```rust
// ✅ ALLOWED - operation types only (no identifiers)
tracing::info!("Vouch recorded");
tracing::info!("Member admitted");
tracing::info!("Member ejected");
tracing::info!("Chunk distribution completed (all chunks 3/3)");

// ✅ ALLOWED - aggregate counts (no identifiers)
tracing::info!("Network: {} members", count);
tracing::debug!("Clusters detected: {}", cluster_count);
tracing::info!("Federated groups: {}", count);  // count only

// ✅ ALLOWED - errors without identifiers
tracing::error!("Signal API failed: {}", error_type);
tracing::warn!("Chunk distribution partial: 7/8 chunks fully replicated");
```

### Compromised Bot Test

Before merging logging code, verify:
> If adversary has full access to bot logs, can they reconstruct:
> 1. Who is in the group? **Must be NO**
> 2. Who vouched for whom? **Must be NO**
> 3. Where are persistence chunks? **Computable** (deterministic assignment - security comes from encryption, not obscurity)
> 4. Which groups are federated? **Must be NO**

**Note on #3**: Chunk holder locations are computable via rendezvous hashing (deterministic assignment). Still don't log them - defense in depth, unnecessary operational info.

### Log Levels

| Level | Audience | Content |
|-------|----------|---------|
| ERROR | Operators | Failures (no identifiers) |
| WARN | Operators | Recoverable issues (no identifiers) |
| INFO | Operators | Operations completed (counts only) |
| DEBUG | Contributors | Internal flow (no sensitive data) |

**See**: `.beads/architectural-decisions-open.bead` Decision #9

## Error Handling Security

### Information Leakage Prevention
- Never expose internal state in error messages
- Use generic error messages for security-critical failures
- Error messages must pass "Compromised Bot Test"

## Testing Security

### Test Data Hygiene
- Never commit test keys or salts to git
- Use deterministic test fixtures (fixed seeds for reproducibility)
- Clean up test data immediately
- Never use production-like identifiers in tests
- Test ephemeral state cleanup (verify data deletion after threshold)
- Test HMAC-based hashing with fixed test pepper

## Architecture Violations (BLOCK)

### Centralization Anti-Patterns
- ❌ **NEVER** introduce centralized trust authority
- ❌ **NEVER** require admin coordination for federation
- ❌ **NEVER** store trust state outside Freenet
- ❌ **NEVER** give operator special privileges beyond service runner role

### State Management Violations
- ❌ **NEVER** make Signal group the source of truth
- ❌ **NEVER** bypass Freenet state verification
- ❌ **NEVER** cache trust decisions locally without verification
- ❌ **NEVER** allow operator to modify GroupConfig without group vote
- ❌ **NEVER** hardcode consensus thresholds (must be in Freenet contract)
- ❌ **NEVER** allow vouches from people outside Stroma group (only Members can vouch)
- ❌ **NEVER** create "waiting room" as separate chat (outside = not in group, binary state)
- ❌ **NEVER** restrict vouching to only Validators (ANY Member can vouch)

## Bot Deployment Violations (BLOCK)

### Multi-Tenancy Anti-Patterns
- ❌ **NEVER** design bot to manage multiple Signal groups (1:N)
- ❌ **NEVER** multiplex messages across groups
- ❌ **NEVER** share Freenet contracts across groups
- ❌ **NEVER** use single phone number for multiple groups

### Correct Architecture (1:1)
- ✅ **DO** deploy one bot instance per group
- ✅ **DO** use separate phone numbers per group
- ✅ **DO** isolate state across bot instances
- ✅ **DO** use systemd service templates for multi-group deployment

**See**: `.beads/bot-deployment-model.bead`

## Bot Governance Violations (BLOCK)

### Bot Decision-Making Anti-Patterns
- ❌ **NEVER** allow bot to make membership decisions independently
- ❌ **NEVER** allow bot to change settings without Freenet consensus
- ❌ **NEVER** allow bot to execute actions without contract approval
- ❌ **NEVER** bypass Freenet verification before Signal operations

### Correct Architecture (Execute-Only)
- ✅ **DO** make bot Signal admin (technical requirement)
- ✅ **DO** enforce: bot executes ONLY contract-approved actions
- ✅ **DO** require Freenet consensus for all settings changes
- ✅ **DO** verify contract state before EVERY Signal operation

**See**: `.beads/governance-model.bead`

## Operator Least Privilege Constraints (BLOCK)

### Operator Privilege Violations
- ❌ **NEVER** allow operator to manually execute membership changes
- ❌ **NEVER** allow operator to override group decisions
- ❌ **NEVER** allow operator to change consensus thresholds unilaterally
- ❌ **NEVER** allow operator to bypass ejection protocol
- ❌ **NEVER** allow operator access to cleartext Signal IDs
- ❌ **NEVER** allow operator to unilaterally federate groups
- ❌ **NEVER** allow operator to modify GroupConfig without group consensus
- ❌ **NEVER** require operator to manually execute commands (must be automatic)

### Configuration Management
- ✅ **DO** store all configuration in Freenet contract
- ✅ **DO** require group vote for configuration changes (via Signal Polls)
- ✅ **DO** make configuration discoverable via `/mesh config`
- ✅ **DO** log all operator actions to Freenet contract
- ✅ **DO** treat operator as just another member (with service runner duties only)
- ✅ **DO** enforce `config_change_threshold` for all config updates
- ✅ **DO** use Signal Polls for all group decisions (NOT reactions)
- ✅ **DO** implement automatic execution of contract-approved actions

### Audit Requirements
- ✅ **DO** log all operator actions with timestamps (service start/stop/restart only)
- ✅ **DO** make audit trail queryable by any member
- ✅ **DO** verify bot automatically executes only contract-approved actions
- ✅ **DO** flag any attempt to bypass group consensus
- ✅ **DO** ensure operator role is limited to service management only

## Voting Mechanism Constraints (BLOCK)

### Vote Privacy Violations
- ❌ **NEVER** expose who voted what (anonymity required)
- ❌ **NEVER** track individual votes in Freenet contract
- ❌ **NEVER** use emoji reactions for voting (exposes voter identity)
- ❌ **NEVER** log vote patterns or voter behavior

### Correct Architecture (Native Polls)
- ✅ **DO** use Signal's native poll feature (anonymous voting)
- ✅ **DO** store only aggregated results (approve count, reject count)
- ✅ **DO** use protocol v8 poll support via forked libsignal-service-rs
- ✅ **DO** preserve vote anonymity (only totals, never individuals)

**Why Polls Not Reactions:**
- Polls preserve voter anonymity (Signal doesn't expose who voted what)
- Reactions are public (everyone sees who reacted with what emoji)
- Anonymity is critical for contentious decisions (federation, config changes)

**See**: `.beads/voting-mechanism.bead`, `.beads/poll-implementation-gastown.bead`

## Bot Storage Constraints (BLOCK - Server Seizure Threat)

### Message Persistence Violations
- ❌ **NEVER** persist message history to disk (exposes vetting conversations)
- ❌ **NEVER** store vetting conversation content (exposes relationship context)
- ❌ **NEVER** use default Presage SqliteStore without modification (stores all messages)
- ❌ **NEVER** store invitation reasons or relationship context
- ❌ **NEVER** persist Signal IDs in database (even encrypted)
- ❌ **NEVER** maintain contact database on disk

### Correct Architecture (Minimal Store)
- ✅ **DO** implement custom minimal ProtocolStore
- ✅ **DO** store ONLY Signal protocol state (sessions, pre-keys)
- ✅ **DO** encrypt any persistent state (small protocol state file only)
- ✅ **DO** prefer in-memory over disk for all non-protocol data
- ✅ **DO** make vetting conversations ephemeral (never written to disk)
- ✅ **DO** use Presage Manager API with custom Store implementation

### Server Seizure Threat Model

**If bot server seized, adversary should get:**
- Small encrypted file (~100KB) with Signal protocol state only
- NO message history
- NO Signal IDs (only hashed in Freenet contract)
- NO vetting conversation transcripts
- NO relationship context ("Great activist from...")
- NO contact database or metadata

**Why Default SqliteStore is Forbidden:**
- Stores complete message history (all vetting conversations)
- Stores contact database (potentially links to Signal IDs)
- Stores group metadata
- Even encrypted, reveals conversation patterns and content
- Violates ephemeral vetting principle

**Implementation Pattern:**
```rust
// ❌ FORBIDDEN
let store = SqliteStore::open_with_passphrase(db_path, pass, OnNewIdentity::Trust).await?;

// ✅ REQUIRED
pub struct StromaProtocolStore {
    // In-memory (ephemeral)
    sessions: HashMap<ServiceId, Session>,
    pre_keys: HashMap<u32, PreKey>,
    
    // Minimal encrypted file for restart only
    protocol_state_file: EncryptedProtocolState,  // ~100KB
}

let store = StromaProtocolStore::new()?;
let manager = Manager::with_store(store, options).await?;
```

**See**: `.beads/technology-stack.bead` for implementation guidance

## Persistence Peer Security (BLOCK - Reciprocal Persistence Network)

### Why This Exists

**Problem**: Freenet data falls off if no peers subscribed.
**Solution**: Bots replicate each other's encrypted chunks.
**Threat**: Persistence peers are adversaries who may be malicious.

**See**: `.beads/persistence-model.bead` for full architecture.

### Adversarial Peer Model (CRITICAL)

ALL persistence peers are assumed to be adversaries:
- May be malicious actors trying to reconstruct trust maps
- May refuse to return chunks during recovery (DoS)
- May collude with other peers
- May be fake bots (Sybil attack)
- May delete chunks without notice

### Persistence Security Violations (BLOCK)

- ❌ **NEVER** allow chunk owner to choose holders (collusion risk)
- ❌ **NEVER** store chunks unencrypted (adversaries can read)
- ❌ **NEVER** use single replica (3 copies per chunk required)
- ❌ **NEVER** store per-chunk relationships in registry (scaling, attack surface)
- ❌ **NEVER** trust federated peers more than random peers (same adversarial model)
- ❌ **NEVER** conflate persistence discovery with federation discovery

### Correct Architecture (Zero Trust + Chunking + Deterministic Assignment)

- ✅ **DO** encrypt with key derived from Signal ACI identity before chunking
- ✅ **DO** use 64KB chunks, 3 copies each (1 local + 2 remote)
- ✅ **DO** use deterministic holder selection per-chunk (rendezvous hashing, not owner-chosen)
- ✅ **DO** keep registry minimal (O(N) bot list, not per-chunk relationships)
- ✅ **DO** verify holders actually have chunks (challenge-response)
- ✅ **DO** treat ALL persistence peers as adversaries
- ✅ **DO** use Signal protocol store as single cryptographic identity

**Why deterministic is acceptable**: Anyone can compute who holds whose chunks. But chunks are encrypted (holder can't read), and attack requires compromising ALL chunk holders + ACI key. Larger states = more chunks = more distribution = harder to seize. Deterministic assignment removes registry as high-value attack target.

### Write-Blocking States

| State | Condition | Writes |
|-------|-----------|--------|
| ACTIVE | All chunks have 2+ replicas | Allowed |
| PROVISIONAL | No suitable peers available | Allowed (warned) |
| DEGRADED | Any chunk ≤1 replica, peers available | **BLOCKED** |
| ISOLATED | N=1 network | Allowed (at risk) |

- ❌ **NEVER** write in DEGRADED state (must restore chunk replicas first)
- ✅ **DO** block writes until persistence confirmed

### Separate Concerns: Security vs Fairness

**Chunk holders and fairness partners are DIFFERENT bots (by algorithm).**

```
Bot-A's perspective (500KB state = 8 chunks):
  FAIRNESS: I hold chunks FOR Bot-B, Bot-C, ... (~2x my state size)
  SECURITY: ~8-16 bots hold MY chunks (deterministic per-chunk assignment)
  
  Note: Anyone can COMPUTE who holds whose chunks (rendezvous hashing)
        But chunks are ENCRYPTED (need ALL chunks + ACI key to reconstruct)
```

- ❌ **NEVER** combine security and fairness in same bot set (collusion risk)
- ✅ **DO** keep them as separate, independent concerns (algorithm ensures separation)

### Recovery Requires Signal Store Backup

**No separate keypair file needed.** The Signal protocol store IS the cryptographic identity.

- ❌ **NEVER** skip Signal store backup in operator documentation
- ❌ **NEVER** create a separate keypair file (use Signal ACI key)
- ✅ **DO** warn operator: Signal store is ONLY recovery path
- ✅ **DO** document Signal store backup procedure prominently in OPERATOR-GUIDE
- ✅ **DO** derive all encryption keys from Signal ACI identity via HKDF

**See**: `.beads/contract-encryption.bead`, `.beads/discovery-protocols.bead`

#!/usr/bin/env bash
# Gastown Pre-Push Hook with CI Status Check
# Generic hook for any repository in gastown workspace
#
# Installation (per repository):
#   cp <repo>/scripts/hooks/pre-push <repo>/.git/hooks/pre-push
#
# This hook:
# 2. Runs quality gates for ALL pushes (fmt, clippy, tests) - Layer 1 defense
# 3. Checks CI status before pushing to main branch (any GitHub repo)
# 4. Blocks push if quality gates fail or main CI is red (unless --no-verify)
#
# Defense in depth:
# - Layer 1: Pre-push quality gates (this hook)
# - Layer 2: Refinery validates before merge to main

set -e

# ============================================================================
# Quality Gates (all pushes to remote)
# ============================================================================

remote="$1"
url="$2"

# Check for environment variable to skip quality gates (WIP pushes)
if [ -n "$GASTOWN_SKIP_QUALITY_GATES" ]; then
    echo "âš ï¸  [Gastown] Skipping quality gates (GASTOWN_SKIP_QUALITY_GATES set)" >&2
    echo "   Use --no-verify to skip next time" >&2
    cat  # Pass through stdin
else
    # Run quality gates for all pushes
    while read local_ref local_sha remote_ref remote_sha; do
        branch_name=$(basename "$remote_ref")
        
        # Skip quality gates for branch deletions (local_sha is all zeros)
        if [ "$local_sha" = "0000000000000000000000000000000000000000" ]; then
            echo "â„¹ï¸  [Gastown] Skipping quality gates for branch deletion: $branch_name" >&2
            # Re-emit the push details for the next section
            echo "$local_ref $local_sha $remote_ref $remote_sha"
            continue
        fi
        
        # Skip quality gates for beads-sync branch (automated sync, already validated)
        if [ "$remote_ref" = "refs/heads/beads-sync" ]; then
            echo "â„¹ï¸  [Gastown] Skipping quality gates for beads-sync branch" >&2
            # Re-emit the push details for the next section
            echo "$local_ref $local_sha $remote_ref $remote_sha"
            continue
        fi
        
        # Check if any Rust files are being pushed
        # Compare the range of commits being pushed
        if [ "$remote_sha" = "0000000000000000000000000000000000000000" ]; then
            # New branch: check all commits from origin/main (or first commit if no main)
            # First try to find commits not on origin/main
            if git rev-parse origin/main >/dev/null 2>&1; then
                range="origin/main..$local_sha"
            elif git rev-parse main >/dev/null 2>&1; then
                range="main..$local_sha"
            else
                # No main branch, check all commits in this branch
                range="$local_sha"
            fi
        else
            # Existing branch, check commits between remote and local
            range="$remote_sha..$local_sha"
        fi
        
        # Check if any .rs files or Cargo.toml changed in this push
        # For single commit (no '..'), use git show instead of git diff
        if [[ "$range" != *".."* ]]; then
            rust_files_changed=$(git show --name-only --format='' "$range" 2>/dev/null | grep -E '\.(rs|toml)$' || true)
        else
            rust_files_changed=$(git diff --name-only "$range" 2>/dev/null | grep -E '\.(rs|toml)$' || true)
        fi
        
        if [ -z "$rust_files_changed" ]; then
            echo "â„¹ï¸  [Gastown] No Rust files changed, skipping quality gates for $branch_name" >&2
            # Re-emit the push details for the next section
            echo "$local_ref $local_sha $remote_ref $remote_sha"
            continue
        fi
        
        echo "ðŸ” [Gastown] Running quality gates for push to $branch_name..." >&2
        echo "   ðŸ“¦ Rust files changed:" >&2
        echo "$rust_files_changed" | head -10 | sed 's/^/      /' >&2
        if [ $(echo "$rust_files_changed" | wc -l) -gt 10 ]; then
            echo "      ... and $(( $(echo "$rust_files_changed" | wc -l) - 10 )) more" >&2
        fi

        # Detect if this is a Rust project
        if [ -f "Cargo.toml" ]; then
            echo "   â†’ Running cargo fmt --check" >&2
            if ! cargo fmt --check 2>&1 | head -20 >&2; then
                echo "" >&2
                echo "âŒ ERROR: Code formatting check failed" >&2
                echo "" >&2
                echo "ðŸ“‹ To fix:" >&2
                echo "  1. Run: cargo fmt" >&2
                echo "  2. Commit the formatting changes" >&2
                echo "  3. Push again" >&2
                echo "" >&2
                echo "ðŸš¨ Emergency bypass: git push --no-verify" >&2
                echo "" >&2
                exit 1
            fi
            echo "   âœ… Formatting check passed" >&2

            echo "   â†’ Running cargo clippy" >&2
            if ! cargo clippy --all-targets --all-features -- -D warnings 2>&1 | tail -50 >&2; then
                echo "" >&2
                echo "âŒ ERROR: Clippy linting failed" >&2
                echo "" >&2
                echo "ðŸ“‹ To fix:" >&2
                echo "  1. Review clippy warnings above" >&2
                echo "  2. Fix all warnings" >&2
                echo "  3. Push again" >&2
                echo "" >&2
                echo "ðŸš¨ Emergency bypass: git push --no-verify" >&2
                echo "" >&2
                exit 1
            fi
            echo "   âœ… Clippy check passed" >&2

            # Check if nextest is available
            if command -v cargo-nextest >/dev/null 2>&1; then
                echo "   â†’ Running cargo nextest" >&2
                if ! cargo nextest run --all-features 2>&1 | tail -50 >&2; then
                    echo "" >&2
                    echo "âŒ ERROR: Tests failed" >&2
                    echo "" >&2
                    echo "ðŸ“‹ To fix:" >&2
                    echo "  1. Review test failures above" >&2
                    echo "  2. Fix failing tests" >&2
                    echo "  3. Push again" >&2
                    echo "" >&2
                    echo "ðŸš¨ Emergency bypass: git push --no-verify" >&2
                    echo "" >&2
                    exit 1
                fi
                echo "   âœ… Tests passed" >&2
            else
                echo "   âš ï¸  cargo-nextest not found, running cargo test" >&2
                if ! cargo test --all-features 2>&1 | tail -50 >&2; then
                    echo "" >&2
                    echo "âŒ ERROR: Tests failed" >&2
                    echo "" >&2
                    echo "ðŸ“‹ To fix:" >&2
                    echo "  1. Review test failures above" >&2
                    echo "  2. Fix failing tests" >&2
                    echo "  3. Push again" >&2
                    echo "" >&2
                    echo "ðŸš¨ Emergency bypass: git push --no-verify" >&2
                    echo "" >&2
                    exit 1
                fi
                echo "   âœ… Tests passed" >&2
            fi

            echo "" >&2
            echo "âœ… All quality gates passed!" >&2
            echo "" >&2
        else
            echo "   â„¹ï¸  Not a Rust project, skipping quality gates" >&2
        fi

        # Re-emit the push details for the next section to consume
        echo "$local_ref $local_sha $remote_ref $remote_sha"
    done
fi | {
    # ============================================================================
    # Step 3: CI Status Check (only for pushes to main)
    # ============================================================================

    # Read push details from stdin (piped from quality gates section)
    while read local_ref local_sha remote_ref remote_sha; do
    # Check if pushing to main branch
    if [ "$remote_ref" = "refs/heads/main" ]; then
        echo "ðŸ” [Gastown] Checking CI status on main branch..." >&2

        # Check if gh CLI is available
        if ! command -v gh >/dev/null 2>&1; then
            echo "âš ï¸  Warning: gh CLI not found, skipping CI check" >&2
            echo "   Install with: brew install gh" >&2
            exit 0
        fi

        # Check if gh is authenticated
        if ! gh auth status >/dev/null 2>&1; then
            echo "âš ï¸  Warning: gh CLI not authenticated, skipping CI check" >&2
            echo "   Run: gh auth login" >&2
            exit 0
        fi

        # Auto-detect repository (works for any repo)
        repo=$(gh repo view --json nameWithOwner -q .nameWithOwner 2>/dev/null)
        if [ -z "$repo" ]; then
            echo "âš ï¸  Warning: Could not determine repository, skipping CI check" >&2
            exit 0
        fi

        # Check main branch CI status
        echo "   Repository: $repo" >&2
        ci_state=$(gh api "repos/$repo/commits/main/status" --jq '.state' 2>/dev/null || echo "unknown")

        case "$ci_state" in
            "success")
                echo "âœ… CI is passing on main" >&2
                exit 0
                ;;
            "pending")
                echo "â³ CI is currently running on main" >&2
                echo "   Allowing push (check will complete asynchronously)" >&2
                exit 0
                ;;
            "failure"|"error")
                echo "" >&2
                echo "âŒ ERROR: CI is currently FAILING on main branch" >&2
                echo "   Repository: $repo" >&2
                echo "   CI State: $ci_state" >&2
                echo "" >&2
                echo "Cannot push to main while CI is broken." >&2
                echo "" >&2
                echo "ðŸ“‹ To fix:" >&2
                echo "  1. File P0 bug: bd create --title='CI BROKEN: ...' --type=bug --priority=0" >&2
                echo "  2. Check failure: gh run list --branch=main --limit=5" >&2
                echo "  3. Fix or revert the breaking commit" >&2
                echo "  4. Verify CI passes before pushing" >&2
                echo "" >&2
                echo "ðŸš¨ Emergency bypass: git push --no-verify" >&2
                echo "   (Use only for reverting the breaking commit or critical hotfixes)" >&2
                echo "" >&2
                exit 1
                ;;
            "unknown"|"")
                echo "âš ï¸  Warning: Could not determine CI state (might be no checks configured)" >&2
                echo "   Repository: $repo" >&2
                echo "   Allowing push, but verify CI manually" >&2
                exit 0
                ;;
            *)
                echo "âš ï¸  Warning: Unknown CI state: $ci_state" >&2
                echo "   Repository: $repo" >&2
                echo "   Allowing push, but verify CI manually" >&2
                exit 0
                ;;
        esac
    fi
    done
}

# If not pushing to main, allow
exit 0

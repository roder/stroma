#!/usr/bin/env bash
# Gastown Pre-Push Hook with CI Status Check
# Generic hook for any repository in gastown workspace
#
# Installation (per repository):
#   cp <repo>/scripts/hooks/pre-push <repo>/.git/hooks/pre-push
#
# This hook:
# 1. Runs bd hooks for beads sync (if available)
# 2. Runs quality gates for ALL pushes (fmt, clippy, tests) - Layer 1 defense
# 3. Checks CI status before pushing to main branch (any GitHub repo)
# 4. Blocks push if quality gates fail or main CI is red (unless --no-verify)
#
# Defense in depth:
# - Layer 1: Pre-push quality gates (this hook)
# - Layer 2: Refinery validates before merge to main

set -e

# ============================================================================
# Step 1: Run bd hooks for beads sync
# ============================================================================

if command -v bd >/dev/null 2>&1; then
    # bd is available, run its pre-push hook logic
    bd hooks run pre-push "$@" || exit $?
fi

# ============================================================================
# Step 2: Quality Gates (all pushes to remote)
# ============================================================================

remote="$1"
url="$2"

# Check for environment variable to skip quality gates (WIP pushes)
if [ -n "$GASTOWN_SKIP_QUALITY_GATES" ]; then
    echo "âš ï¸  [Gastown] Skipping quality gates (GASTOWN_SKIP_QUALITY_GATES set)" >&2
    echo "   Use --no-verify to skip next time" >&2
    cat  # Pass through stdin
else
    # Run quality gates for all pushes
    while read local_ref local_sha remote_ref remote_sha; do
        echo "ðŸ” [Gastown] Running quality gates for push to $(basename $remote_ref)..." >&2

        # Detect if this is a Rust project
        if [ -f "Cargo.toml" ]; then
            echo "   ðŸ“¦ Rust project detected" >&2
            echo "   â†’ Running cargo fmt --check" >&2
            if ! cargo fmt --check 2>&1 | head -20 >&2; then
                echo "" >&2
                echo "âŒ ERROR: Code formatting check failed" >&2
                echo "" >&2
                echo "ðŸ“‹ To fix:" >&2
                echo "  1. Run: cargo fmt" >&2
                echo "  2. Commit the formatting changes" >&2
                echo "  3. Push again" >&2
                echo "" >&2
                echo "ðŸš¨ Emergency bypass: git push --no-verify" >&2
                echo "" >&2
                exit 1
            fi
            echo "   âœ… Formatting check passed" >&2

            echo "   â†’ Running cargo clippy" >&2
            if ! cargo clippy --all-targets --all-features -- -D warnings 2>&1 | tail -50 >&2; then
                echo "" >&2
                echo "âŒ ERROR: Clippy linting failed" >&2
                echo "" >&2
                echo "ðŸ“‹ To fix:" >&2
                echo "  1. Review clippy warnings above" >&2
                echo "  2. Fix all warnings" >&2
                echo "  3. Push again" >&2
                echo "" >&2
                echo "ðŸš¨ Emergency bypass: git push --no-verify" >&2
                echo "" >&2
                exit 1
            fi
            echo "   âœ… Clippy check passed" >&2

            # Check if nextest is available
            if command -v cargo-nextest >/dev/null 2>&1; then
                echo "   â†’ Running cargo nextest" >&2
                if ! cargo nextest run --all-features 2>&1 | tail -50 >&2; then
                    echo "" >&2
                    echo "âŒ ERROR: Tests failed" >&2
                    echo "" >&2
                    echo "ðŸ“‹ To fix:" >&2
                    echo "  1. Review test failures above" >&2
                    echo "  2. Fix failing tests" >&2
                    echo "  3. Push again" >&2
                    echo "" >&2
                    echo "ðŸš¨ Emergency bypass: git push --no-verify" >&2
                    echo "" >&2
                    exit 1
                fi
                echo "   âœ… Tests passed" >&2
            else
                echo "   âš ï¸  cargo-nextest not found, running cargo test" >&2
                if ! cargo test --all-features 2>&1 | tail -50 >&2; then
                    echo "" >&2
                    echo "âŒ ERROR: Tests failed" >&2
                    echo "" >&2
                    echo "ðŸ“‹ To fix:" >&2
                    echo "  1. Review test failures above" >&2
                    echo "  2. Fix failing tests" >&2
                    echo "  3. Push again" >&2
                    echo "" >&2
                    echo "ðŸš¨ Emergency bypass: git push --no-verify" >&2
                    echo "" >&2
                    exit 1
                fi
                echo "   âœ… Tests passed" >&2
            fi

            echo "" >&2
            echo "âœ… All quality gates passed!" >&2
            echo "" >&2
        else
            echo "   â„¹ï¸  Not a Rust project, skipping quality gates" >&2
        fi

        # Re-emit the push details for the next section to consume
        echo "$local_ref $local_sha $remote_ref $remote_sha"
    done
fi | {
    # ============================================================================
    # Step 3: CI Status Check (only for pushes to main)
    # ============================================================================

    # Read push details from stdin (piped from quality gates section)
    while read local_ref local_sha remote_ref remote_sha; do
    # Check if pushing to main branch
    if [ "$remote_ref" = "refs/heads/main" ]; then
        echo "ðŸ” [Gastown] Checking CI status on main branch..." >&2

        # Check if gh CLI is available
        if ! command -v gh >/dev/null 2>&1; then
            echo "âš ï¸  Warning: gh CLI not found, skipping CI check" >&2
            echo "   Install with: brew install gh" >&2
            exit 0
        fi

        # Check if gh is authenticated
        if ! gh auth status >/dev/null 2>&1; then
            echo "âš ï¸  Warning: gh CLI not authenticated, skipping CI check" >&2
            echo "   Run: gh auth login" >&2
            exit 0
        fi

        # Auto-detect repository (works for any repo)
        repo=$(gh repo view --json nameWithOwner -q .nameWithOwner 2>/dev/null)
        if [ -z "$repo" ]; then
            echo "âš ï¸  Warning: Could not determine repository, skipping CI check" >&2
            exit 0
        fi

        # Check main branch CI status
        echo "   Repository: $repo" >&2
        ci_state=$(gh api "repos/$repo/commits/main/status" --jq '.state' 2>/dev/null || echo "unknown")

        case "$ci_state" in
            "success")
                echo "âœ… CI is passing on main" >&2
                exit 0
                ;;
            "pending")
                echo "â³ CI is currently running on main" >&2
                echo "   Allowing push (check will complete asynchronously)" >&2
                exit 0
                ;;
            "failure"|"error")
                echo "" >&2
                echo "âŒ ERROR: CI is currently FAILING on main branch" >&2
                echo "   Repository: $repo" >&2
                echo "   CI State: $ci_state" >&2
                echo "" >&2
                echo "Cannot push to main while CI is broken." >&2
                echo "" >&2
                echo "ðŸ“‹ To fix:" >&2
                echo "  1. File P0 bug: bd create --title='CI BROKEN: ...' --type=bug --priority=0" >&2
                echo "  2. Check failure: gh run list --branch=main --limit=5" >&2
                echo "  3. Fix or revert the breaking commit" >&2
                echo "  4. Verify CI passes before pushing" >&2
                echo "" >&2
                echo "ðŸš¨ Emergency bypass: git push --no-verify" >&2
                echo "   (Use only for reverting the breaking commit or critical hotfixes)" >&2
                echo "" >&2
                exit 1
                ;;
            "unknown"|"")
                echo "âš ï¸  Warning: Could not determine CI state (might be no checks configured)" >&2
                echo "   Repository: $repo" >&2
                echo "   Allowing push, but verify CI manually" >&2
                exit 0
                ;;
            *)
                echo "âš ï¸  Warning: Unknown CI state: $ci_state" >&2
                echo "   Repository: $repo" >&2
                echo "   Allowing push, but verify CI manually" >&2
                exit 0
                ;;
        esac
    fi
    done
}

# If not pushing to main, allow
exit 0
